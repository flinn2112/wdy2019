28.01.2019                                                                Nur Test Zeugs $TMP - keine DB-Änderungen                                                                       1
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
28.01.2019 16:16:40
method WDDOEXIT .
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method BAK_FILL_LB_YEAR_FROM.
* 1/2019 KEMPF_S - die Listbox mit den verfügbaren Jahren wird bedarfsweise(eventgesteuert) ausgeführt(abh. v. anderen Listboxen).
  DATA  lo_nd_node TYPE REF TO if_wd_context_node.
  DATA: lt_node    TYPE wd_this->Elements_node_from_year_lb,
        lt_viof    TYPE STANDARD TABLE OF ZVIOF,
        lv_year    TYPE NUMC4.
* navigate from <CONTEXT> to <NODE_FROM_YEAR> via lead selection
  lo_nd_node = wd_context->path_get_node( path = `NODE_TRANS_COST.NODE_FROM_YEAR_LB` ).
  DATA:
       lv_objekt   TYPE ZVIOFOBJEK.
 IF lo_nd_node IS INITIAL.
   "+Fehlermeldung
    RETURN.
 ENDIF.
  DATA(lo_nd_object_repository) = wd_context->get_child_node( name = wd_this->wdctx_object_repository ).
  DATA(lo_el_object_repository) = lo_nd_object_repository->get_element( ).
* get single attribute
  lo_el_object_repository->get_attribute(
    EXPORTING
      name =  `OBJECT_ID`
    IMPORTING
      value = lv_objekt ).
  IF lo_nd_node IS INITIAL.
    "+Fehlermeldung
    RETURN.
  ENDIF.
  "Kein Start-Jahr gesetzt -> wenigstens so ab 2010 holen
  IF IV_START_YEAR IS SUPPLIED AND NOT IV_START_YEAR IS INITIAL.
    lv_year = 10000 - IV_START_YEAR.
  ELSE.
    lv_year = 2010.
    lv_year = 10000 -  lv_year.
  ENDIF.
  IF SY-SYSID = 'MZE'. "Testdaten sind hier nur bedingt gepflegt.
    lv_year = 7993.
  ENDIF.
" Daten aus der Customizing Tabelle holen.
  SELECT ZZCJAHR FROM ZVIOF INTO CORRESPONDING FIELDS OF TABLE lt_viof
    WHERE ZZOBJEK = lv_objekt AND ZZCJAHR <= lv_year
    ORDER BY ZZCJAHR ZZFOLGE.
    DELETE ADJACENT DUPLICATES FROM lt_viof COMPARING  ZZCJAHR ZZFOLGE.
  LOOP AT lt_viof ASSIGNING FIELD-SYMBOL(<lfs_v>).
      APPEND INITIAL LINE TO lt_node ASSIGNING FIELD-SYMBOL(<lfs_data>).
      <lfs_data>-YEAR = 10000 - <lfs_v>-ZZCJAHR.
  ENDLOOP.
  SORT lt_node BY YEAR ASCENDING.
  IF NOT lo_nd_node IS INITIAL.
    lo_nd_node->bind_table( new_items = lt_node set_initial_elements = abap_true ).
  ENDIF.
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method GET_VERMARKTUNG .
  "1/2019 KEMPF_S
  "Zur Verwendung in SupplyFunktionen.
  DATA LT_RNG_OBJECT_ID   TYPE ZVTT_OBJEKT_RNG.
  DATA LT_VERMARKTUNG TYPE ZVTT_OBJ_VERMARKTUNG.
  DATA LT_RETURN          TYPE ZVTT_RETURN.
  zcl_common_service=>instance->get_as_range(
    EXPORTING
      iv_data         = IV_OBJEKT
    CHANGING
      ct_range        = LT_RNG_OBJECT_ID ).
  CALL FUNCTION 'Z_V_GETLIST_OBJ_VERMARKTUNG_BL'
       EXPORTING
         I_RNG_OBJECT_ID             = LT_RNG_OBJECT_ID
       IMPORTING
         E_TAB_OBJ_VERMARKTUNG       = LT_VERMARKTUNG
         E_TAB_RETURN                = LT_RETURN
                .
  IF IV_JAHR IS SUPPLIED AND NOT IV_JAHR IS INITIAL.
  ELSE. "niedrigste
    SORT LT_VERMARKTUNG BY VERMARKTUNG ASCENDING.
    READ TABLE LT_VERMARKTUNG INDEX 1 TRANSPORTING VERMARKTUNG INTO DATA(ls_v).
    RV_VERMARKTUNG = ls_v-VERMARKTUNG.
  ENDIF.
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method ONACTIONXXX .
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method ONACTIONDEL_TRANSPORT_COST .
    DATA lo_el_node TYPE REF TO if_wd_context_element.
    DATA: lv_path   TYPE STRING.
  "2019 KEMPF_S f. Transportkosten
  "noch auszubauen -> abhängig v. aktiven Tab wird eine Aktion durchgeführt.
  "Das aktive Tab ist in Membervar MV_ACTIVE_TAB gespeichert.
  "Im zugehörigen DDK Knoten wird der Eintrag als zu Löschen ACTION = 3 markiert.
      DATA lo_nd_node TYPE REF TO if_wd_context_node.
      DATA lr_node TYPE REF TO DATA.
      FIELD-SYMBOLS: <lfs_data> TYPE ANY.
      CASE me->WD_THIS->MV_TCOST_ACTIVE_TAB.
         WHEN 'TAB_VORTRANSPORT'.
            DATA ls_node_v TYPE wd_this->Element_node_vortransport.
            DATA ls_node_vd TYPE wd_this->Element_node_vortrans_ddk.
            lo_nd_node = wd_context->path_get_node( path = `NODE_TRANS_COST.NODE_VORTRANSPORT` ).
            lo_el_node = lo_nd_node->get_element( ).
            lv_path = `NODE_TRANS_COST.NODE_VORTRANS_DDK`.
            IF NOT lo_el_node IS INITIAL.
              lo_el_node->get_static_attributes(
              IMPORTING
                static_attributes = ls_node_v ).
            ENDIF.
            DATA(lo_nd_node_d) = wd_context->path_get_node( path = LV_PATH ). "
             IF NOT lo_nd_node_d IS BOUND.
               "+ ERROR Message
               RETURN.
             ENDIF.
              MOVE-CORRESPONDING ls_node_v TO ls_node_vd.
              ls_node_vd-action = 3.
              me->APPEND_TRANSCOST_DELETED(
                exporting
                  IV_PATH    = LV_PATH
                  IR_ELEMENT = lo_el_node
                  IS_DATA    = ls_node_vd
              ).
          WHEN 'TAB_MAUT'.
            DATA ls_node_m  TYPE wd_this->Element_node_maut.
            DATA ls_node_md TYPE wd_this->Element_node_maut_ddk. "Löschdaten
            lo_nd_node = wd_context->path_get_node( path = `NODE_TRANS_COST.NODE_MAUT` ).
            lo_el_node = lo_nd_node->get_element( ).
            IF NOT lo_el_node IS INITIAL.
              lo_el_node->get_static_attributes(
              IMPORTING
                static_attributes = ls_node_m ).
            ENDIF.
            lv_path = `NODE_TRANS_COST.NODE_MAUT_DDK`.
            lo_nd_node_d = wd_context->path_get_node( path = LV_PATH ). "
             IF NOT lo_nd_node_d IS BOUND.
               "+ ERROR Message
               RETURN.
             ENDIF.
              MOVE-CORRESPONDING ls_node_m TO ls_node_md.
              ls_node_md-action = 3.
              me->APPEND_TRANSCOST_DELETED(
                exporting
                  IV_PATH    = LV_PATH
                  IR_ELEMENT = lo_el_node
                  IS_DATA    = ls_node_md "mit den löschdaten
              ).
           WHEN 'TAB_UEBERNAHME'.
             DATA ls_node_u  TYPE wd_this->Element_node_uebernahme.
             DATA ls_node_ud TYPE wd_this->Element_node_uebernahme_ddk.
             lo_nd_node = wd_context->path_get_node( path = `NODE_TRANS_COST.NODE_UEBERNAHME` ).
             lo_el_node = lo_nd_node->get_element( ).
             IF NOT lo_el_node IS INITIAL.
              lo_el_node->get_static_attributes(
              IMPORTING
                static_attributes = ls_node_u ).
            ENDIF.
             lv_path = `NODE_TRANS_COST.NODE_UEBERNAHME_DDK`.
             lo_nd_node_d = wd_context->path_get_node( path = LV_PATH ). "
             IF NOT lo_nd_node_d IS BOUND.
               "+ ERROR Message
               RETURN.
             ENDIF.
              MOVE-CORRESPONDING ls_node_u TO ls_node_ud.
              ls_node_ud-action = 3.
              me->APPEND_TRANSCOST_DELETED(
                exporting
                  IV_PATH    = LV_PATH
                  IR_ELEMENT = lo_el_node
                  IS_DATA    = ls_node_ud "mit den löschdaten
              ).
           WHEN 'TAB_ECOTAX'.
              DATA ls_node_e  TYPE wd_this->Element_node_ecotax.
              DATA ls_node_ed TYPE wd_this->Element_node_ecotax_ddk.
              lo_nd_node = wd_context->path_get_node( path = `NODE_TRANS_COST.NODE_ECOTAX` ).
              lo_el_node = lo_nd_node->get_element( ).
              IF NOT lo_el_node IS INITIAL.
              lo_el_node->get_static_attributes(
                IMPORTING
                  static_attributes = ls_node_e ).
              ENDIF.
              lv_path = `NODE_TRANS_COST.NODE_ECOTAX_DDK`.
              lo_nd_node_d = wd_context->path_get_node( path = LV_PATH ). "
              IF NOT lo_nd_node_d IS BOUND.
               "+ ERROR Message
                RETURN.
              ENDIF.
              MOVE-CORRESPONDING ls_node_e TO ls_node_ed.
              ls_node_ed-action = 3.
              me->APPEND_TRANSCOST_DELETED(
                exporting
                  IV_PATH    = LV_PATH
                  IR_ELEMENT = lo_el_node
                  IS_DATA    = ls_node_ed "mit den löschdaten
              ).
      ENDCASE.
      IF lo_nd_node IS BOUND.
        lo_nd_node->REMOVE_ELEMENT( lo_el_node ).
      ENDIF.
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method ONACTIONON_SELECT_TO_FOLGE .
    "KEMPF_S 1/2019
  "Wenn der Eintrag gewählt wird, dann muss der Wert im Mautknoten entsprechend gesetzt werden.
  "Das Event feuert z.B. auf dem Knoten NODE_MAUT
  "Der ChildKnoten hat die Selektion dazu.
  "Damit es nur eine Funktion für alle Listboxen braucht, wird der Knotenname des Unterknotens ermittelt.
  DATA lv_sub_node_name TYPE STRING.
  DATA(lv_name) = CONTEXT_ELEMENT->GET_NODE( )->GET_NODE_INFO( )->GET_NAME( ). "DEV
  DATA lv_value TYPE STRING.
  DATA: lv_field TYPE STRING VALUE `ZZBISFOLGE`.
*  DATA lr_data TYPE REF TO DATA.
*  FIELD-SYMBOLS: <lfs_data> TYPE ANY,
*                 <lfs_value> TYPE ANY.
  CASE lv_name.
     WHEN 'NODE_VORTRANSPORT'.
      lv_sub_node_name = 'NODE_VT_TO_FOLGE'.
      "CREATE DATA lr_data TYPE wd_this->ELEMENT_NODE_VT_FROM_FOLGE.
     WHEN 'NODE_UEBERNAHME'.
      lv_sub_node_name = 'NODE_UN_TO_FOLGE'.
      "CREATE DATA lr_data TYPE wd_this->ELEMENT_NODE_UN_FROM_FOLGE.
     WHEN 'NODE_MAUT'.
      lv_sub_node_name = 'NODE_MAUT_TO_FOLGE'.
      "CREATE DATA lr_data TYPE wd_this->ELEMENT_NODE_MAUT_FROM_FOLGE.
    WHEN 'NODE_ECOTAX'.
      lv_sub_node_name = 'NODE_ETAX_TO_FOLGE'.
      "CREATE DATA lr_data TYPE wd_this->ELEMENT_NODE_ETAX_FROM_FOLGE.
    WHEN OTHERS.
      RETURN.
  ENDCASE.
  DATA(lr_child) = CONTEXT_ELEMENT->GET_CHILD_NODE( LV_SUB_NODE_NAME ).
  DATA(lr_el)    = lr_child->GET_LEAD_SELECTION( ).
  "ASSIGN lr_data->* TO <lfs_data>.
*   get all declared attributes
    lr_el->GET_ATTRIBUTE(
      EXPORTING
        NAME  = lv_field
      IMPORTING
        VALUE = lv_value " DATA -> string
    ).
   IF NOT LV_VALUE IS INITIAL.
        CONTEXT_ELEMENT->set_attribute(
          name =  lv_field
          value = lv_value ).
    ENDIF.
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method SPLY_MAUT_COST.
  "1/2019 KEMPF_S -> literale hier, damit der Code besser kopiert und geändert werden kann.
  DATA: lv_node_data_name     TYPE STRING VALUE `NODE_TRANS_COST.NODE_MAUT`.
  DATA: lv_node_values_name   TYPE STRING .
  DATA: lv_node_sub_name      TYPE STRING VALUE 'NODE_MAUT_VALUES'.
  DATA LO_ND_NODE_VALUES      TYPE REF TO IF_WD_CONTEXT_NODE.
  DATA LT_NODE_VALUES         TYPE WD_THIS->ELEMENTS_NODE_MAUT_VALUES.
* 1/2019 KEMPF_S - die Listbox mit den verfügbaren Jahren wird bedarfsweise(eventgesteuert) ausgeführt(abh. v. anderen Listboxen).
  DATA  lo_nd_node_data TYPE REF TO if_wd_context_node.
  DATA:
       lv_year    TYPE NUMC4.
  DATA:
       lv_objekt   TYPE ZVIOFOBJEK,
       lv_xyear    TYPE ZVDE_JAHR. "f. Komplementberechnung
  DATA(lo_nd_object_repository) = wd_context->get_child_node( name = wd_this->wdctx_object_repository ).
  DATA(lo_el_object_repository) = lo_nd_object_repository->get_element( ).
  DATA LO_EL_NODE_DATA TYPE REF TO IF_WD_CONTEXT_ELEMENT.
  DATA LS_NODE_DATA    TYPE WD_THIS->ELEMENT_NODE_MAUT.
  DATA LT_NODE_DATA    TYPE WD_THIS->ELEMENTS_NODE_MAUT.
  DATA(x) = NODE->GET_NODE_INFO( )->GET_NAME( ).
  "zusammengesetzt
  lv_node_values_name = lv_node_data_name && `.` && lv_node_sub_name.
* get single attribute
  lo_el_object_repository->get_attribute(
    EXPORTING
      name =  `OBJECT_ID`
    IMPORTING
      value = lv_objekt ).
*   navigate from <CONTEXT> to <NODE_TO_YEAR> via lead selection
    LO_ND_NODE_VALUES = WD_CONTEXT->PATH_GET_NODE( PATH = lv_node_values_name ).
   IF LO_ND_NODE_VALUES IS INITIAL.
      RETURN.
   ENDIF.
    LO_ND_NODE_VALUES->GET_STATIC_ATTRIBUTES_TABLE( IMPORTING TABLE = LT_NODE_VALUES ).
    SELECT * FROM ZVTRANS_MAUT_PER INTO @DATA(ls_maut_perc).
      APPEND INITIAL LINE TO LT_NODE_VALUES ASSIGNING FIELD-SYMBOL(<lfs_m>).
      <lfs_m>-PERCENT = ls_maut_perc-PROZENT.
    ENDSELECT.
  IF NOT lo_nd_node_values IS INITIAL.
     "LO_ND_NODE_VALUES->bind_table( new_items = LT_NODE_VALUES  set_initial_elements = abap_true ).
  ENDIF.
*
  "nur dev
    x = LO_ND_NODE_VALUES->GET_NODE_INFO( )->GET_NAME( ).
*   navigate from <CONTEXT> to <NODE_VORTRANSPORT> via lead selection
    LO_ND_NODE_DATA = WD_CONTEXT->PATH_GET_NODE( PATH = lv_node_data_name ).
*   get element via lead selection
    LO_EL_NODE_DATA = LO_ND_NODE_DATA->GET_ELEMENT( ).
    IF LO_EL_NODE_DATA IS INITIAL.
      RETURN.
    ENDIF.
*   get all declared attributes
    PARENT_ELEMENT->GET_NODE( )->GET_STATIC_ATTRIBUTES(
      IMPORTING
        STATIC_ATTRIBUTES = LS_NODE_DATA ).
  LO_ND_NODE_DATA->GET_STATIC_ATTRIBUTES_TABLE( IMPORTING TABLE = LT_NODE_DATA ).
  TRANSCOST_ASSOCIATE_LISTBOX(
    EXPORTING
      IO_NODE_DATA     = LO_ND_NODE_DATA
      IO_NODE_VALUES   = LO_ND_NODE_VALUES
      IV_NODE_NAME     = lv_node_sub_name
      IT_VALUES        = LT_NODE_VALUES
      IT_DATA          = LT_NODE_DATA
      IV_DATA_FIELD    = `ZZPERCENT_MAUT`
      IV_VALUE_FIELD   = 'PERCENT'
      "IV_SET_INITIAL_ELEMENTS = ABAP_TRUE
  ).
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method SPLY_VORTRANSPORT_COST.
  "1/2019 KEMPF_S -> literale hier, damit der Code besser kopiert und geändert werden kann.
  DATA: lv_node_data_name     TYPE STRING VALUE `NODE_TRANS_COST.NODE_VORTRANSPORT`.
  DATA: lv_node_values_name   TYPE STRING .
  DATA: lv_node_sub_name      TYPE STRING VALUE 'NODE_VORTRANS_VALUE'.
  DATA LO_ND_NODE_VALUES      TYPE REF TO IF_WD_CONTEXT_NODE.
  DATA LT_NODE_VALUES         TYPE WD_THIS->ELEMENTS_NODE_VORTRANS_VALUES.
* 1/2019 KEMPF_S - die Listbox mit den verfügbaren Daten wird bedarfsweise(eventgesteuert) ausgeführt(abh. v. anderen Listboxen).
  DATA  lo_nd_node_data TYPE REF TO if_wd_context_node.
  DATA:
       lv_year    TYPE NUMC4.
  DATA:
       lv_objekt   TYPE ZVIOFOBJEK,
       lv_xyear    TYPE ZVDE_JAHR. "f. Komplementberechnung
  DATA(lo_nd_object_repository) = wd_context->get_child_node( name = wd_this->wdctx_object_repository ).
  DATA(lo_el_object_repository) = lo_nd_object_repository->get_element( ).
  DATA LO_EL_NODE_DATA TYPE REF TO IF_WD_CONTEXT_ELEMENT.
  DATA LS_NODE_DATA    TYPE WD_THIS->ELEMENT_NODE_VORTRANSPORT.
  DATA LT_NODE_DATA    TYPE WD_THIS->ELEMENTS_NODE_VORTRANSPORT.
  DATA(x) = NODE->GET_NODE_INFO( )->GET_NAME( ).
  "zusammengesetzt
  lv_node_values_name = lv_node_data_name && `.` && lv_node_sub_name.
* get single attribute
  lo_el_object_repository->get_attribute(
    EXPORTING
      name =  `OBJECT_ID`
    IMPORTING
      value = lv_objekt ).
*   navigate from <CONTEXT> to <NODE_TO_YEAR> via lead selection
    LO_ND_NODE_VALUES = WD_CONTEXT->PATH_GET_NODE( PATH = lv_node_values_name ).
   IF LO_ND_NODE_VALUES IS INITIAL.
      RETURN.
   ENDIF.
    LO_ND_NODE_VALUES->GET_STATIC_ATTRIBUTES_TABLE( IMPORTING TABLE = LT_NODE_VALUES ).
    SELECT * FROM ZVTRANS_VRTR_BTR INTO @DATA(ls_data).
      APPEND INITIAL LINE TO LT_NODE_VALUES ASSIGNING FIELD-SYMBOL(<lfs_data>).
      <lfs_data>-BETRAG_STRING = ls_data-BETRAG.
    ENDSELECT.
  IF NOT lo_nd_node_values IS INITIAL.
     "LO_ND_NODE_VALUES->bind_table( new_items = LT_NODE_VALUES  set_initial_elements = abap_true ).
  ENDIF.
*
  "nur dev
    x = LO_ND_NODE_VALUES->GET_NODE_INFO( )->GET_NAME( ).
*   navigate from <CONTEXT> to <NODE_VORTRANSPORT> via lead selection
    LO_ND_NODE_DATA = WD_CONTEXT->PATH_GET_NODE( PATH = lv_node_data_name ).
*   get element via lead selection
    LO_EL_NODE_DATA = LO_ND_NODE_DATA->GET_ELEMENT( ).
    IF LO_EL_NODE_DATA IS INITIAL.
      RETURN.
    ENDIF.
*   get all declared attributes
    PARENT_ELEMENT->GET_NODE( )->GET_STATIC_ATTRIBUTES(
      IMPORTING
        STATIC_ATTRIBUTES = LS_NODE_DATA ).
  LO_ND_NODE_DATA->GET_STATIC_ATTRIBUTES_TABLE( IMPORTING TABLE = LT_NODE_DATA ).
  TRANSCOST_ASSOCIATE_LISTBOX(
    EXPORTING
      IO_NODE_DATA     = LO_ND_NODE_DATA
      IO_NODE_VALUES   = LO_ND_NODE_VALUES
      IV_NODE_NAME     = lv_node_sub_name
      IT_VALUES        = LT_NODE_VALUES
      IT_DATA          = LT_NODE_DATA
      IV_DATA_FIELD   = `ZZBETRAG_VORTRANSPORT`        "der Name des Feldes in der Tabelle der Daten
    IV_VALUE_FIELD   = `BETRAG_STRING`                "der Name im Knoten der Listbox/Werte
      "IV_SET_INITIAL_ELEMENTS = ABAP_TRUE
  ).
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method WDDOBEFORENAVIGATION .
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method WDDOINIT .
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method WDDOPOSTPROCESSING .
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method WDDOAPPLICATIONSTATECHANGE .
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method PRINT_RETURN_MESSAGE .
*   get message manager
  DATA: l_current_controller TYPE REF TO if_wd_controller,
        l_message_manager    TYPE REF TO if_wd_message_manager,
        l_class_name         TYPE string,
        l_return_msg         TYPE string.
  l_current_controller ?= wd_this->wd_get_api( ).
  CALL METHOD l_current_controller->get_message_manager
    RECEIVING
      message_manager = l_message_manager.
  l_return_msg = message.
*   report message
  CALL METHOD l_message_manager->report_warning
    EXPORTING
      message_text  = l_return_msg.
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
METHOD WRITE_VALIDATION_ERROR_MSG .
*   get message manager
  DATA: l_current_controller TYPE REF TO if_wd_controller,
        l_message_manager    TYPE REF TO if_wd_message_manager.
  l_current_controller ?= wd_this->wd_get_api( ).
  l_current_controller->get_message_manager( RECEIVING message_manager = l_message_manager ).
*   report message
  l_message_manager->report_attribute_error_message(
    EXPORTING
      message_text   = message
      element        = element
      attribute_name = attribute
   ).
ENDMETHOD.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method PRINT_ALL_RETURN_MESSAGES .
***************************************************************************************************
* RTH - 16.05.2007
* Beschreibung:
* Liesst alle Returm Msgs aus und gibt sie auf der View wieder.
***************************************************************************************************
  data:
     lstr_return              type bapiret2.
*   get message manager
  data:
     l_current_controller     type ref to if_wd_controller,
     l_message_manager        type ref to if_wd_message_manager.
  l_current_controller ?= wd_this->wd_get_api( ).
  l_message_manager = l_current_controller->get_message_manager( ) .
  loop at i_tab_return into lstr_return.
    case lstr_return-type.
      when 'E'.
        l_message_manager->report_error_message(
          message_text = lstr_return-message ).
      when 'S'.
        l_message_manager->report_success(
          message_text = lstr_return-message ).
      when 'W'.
        l_message_manager->report_warning(
          message_text = lstr_return-message ).
    endcase.
  endloop.
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
METHOD GET_IS_LOCK .
*******************************************************************************************
* RTH - 20.01.2005
* Description:
* Returns the lock state stored in Componentcontroller Context Node OBJECT_REPOSITORY.
*******************************************************************************************
  DATA:
    node_object_repository           TYPE REF TO if_wd_context_node,
    elem_object_repository           TYPE REF TO if_wd_context_element,
    stru_object_repository           TYPE if_componentcontroller=>element_OBJECT_REPOSITORY .
* navigate from <CONTEXT> to <OBJECT_REPOSITORY> via lead selection
  node_object_repository = wd_context->get_child_node( name = `OBJECT_REPOSITORY` ).
* get element via lead selection
  elem_object_repository = node_object_repository->get_element(  ).
* get all declared attributes
  elem_object_repository->get_static_attributes(
    IMPORTING
      static_attributes = stru_object_repository ).
  lock_state = stru_object_repository-is_locked.
ENDMETHOD.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
METHOD GET_SELECTED_KEY .
************************************************************************************************
* RTH - 21.02.2006
* Description:
* Returns the selected key of the valueset specified by the argument VALUESET_ID
************************************************************************************************
  DATA:
    node_value_sets                     TYPE REF TO if_wd_context_node,
    elem_value_sets                     TYPE REF TO if_wd_context_element.
*   navigate from <CONTEXT> to <VALUE_SETS> via lead selection
  node_value_sets = wd_context->get_child_node( name = `VALUE_SETS` ).
*   get element via lead selection
  elem_value_sets = node_value_sets->get_element(  ).
*   get single attribute
  elem_value_sets->get_attribute( EXPORTING name = valueset_id IMPORTING value = selected_key ).
ENDMETHOD.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
METHOD SET_IS_LOCK .
*******************************************************************************************
* RTH - 20.01.2005
* Description:
* Sets the lock state to Componentcontroller Context Node OBJECT_REPOSITORY.
*******************************************************************************************
  DATA:
    node_object_repository           TYPE REF TO if_wd_context_node,
    elem_object_repository           TYPE REF TO if_wd_context_element,
    stru_object_repository           TYPE if_componentcontroller=>element_OBJECT_REPOSITORY .
* navigate from <CONTEXT> to <OBJECT_REPOSITORY> via lead selection
  node_object_repository = wd_context->get_child_node( name = `OBJECT_REPOSITORY` ).
* get element via lead selection
  elem_object_repository = node_object_repository->get_element(  ).
  elem_object_repository->set_attribute( name = 'IS_LOCKED' value = lock_state ).
ENDMETHOD.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
METHOD SET_IS_READONLY .
  DATA:
    node_object_repository              TYPE REF TO if_wd_context_node,
    elem_object_repository              TYPE REF TO if_wd_context_element .
*   navigate from <CONTEXT> to <OBJECT_REPOSITORY> via lead selection
  node_object_repository = wd_context->get_child_node( name = `OBJECT_REPOSITORY` ).
*   get element via lead selection
  elem_object_repository = node_object_repository->get_element(  ).
  elem_object_repository->set_attribute( name = 'IS_READONLY' value = i_is_readonly ).
ENDMETHOD.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method DISABLE_COMPONENT .
    data lo_nd_enable type ref to if_wd_context_node.
    data lo_el_enable type ref to if_wd_context_element.
    data ls_enable type wd_this->element_enable.
    data lv_enable_root type wd_this->element_enable-enable_root.
*   navigate from <CONTEXT> to <ENABLE> via lead selection
    lo_nd_enable = wd_context->path_get_node( path = `VIEW_PROPERTIES.ENABLE` ).
*   get element via lead selection
    lo_el_enable = lo_nd_enable->get_element( ).
*   set single attribute
    lo_el_enable->set_attribute(
      name =  `ENABLE_ROOT`
      value = abap_false ).
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
METHOD GET_CURRENT_PROCESS .
  DATA:
    node_object_repository              TYPE REF TO if_wd_context_node,
    elem_object_repository              TYPE REF TO if_wd_context_element.
  node_object_repository = wd_context->get_child_node( name = `OBJECT_REPOSITORY` ).
  elem_object_repository = node_object_repository->get_element(  ).
  elem_object_repository->get_attribute( EXPORTING  name =  `CURRENT_PROCESS` IMPORTING value = e_current_process ).
ENDMETHOD.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
METHOD GET_OBJECT_ID .
******************************************************************************
* RTH 18.01.2005
* Description:
* This method returns the object ID from the interface component context node
* OBJECT_REPOSITORY.
******************************************************************************
  DATA:
    node_object_repository           TYPE REF TO if_wd_context_node,
    elem_object_repository           TYPE REF TO if_wd_context_element,
    stru_object_repository           TYPE if_componentcontroller=>element_OBJECT_REPOSITORY ,
    item_object_id                      LIKE stru_object_repository-object_id.
* navigate from <CONTEXT> to <OBJECT_REPOSITORY> via lead selection
  node_object_repository = wd_context->get_child_node( name = `OBJECT_REPOSITORY` ).
* get element via lead selection
  elem_object_repository = node_object_repository->get_element(  ).
* get single attribute
  elem_object_repository->get_attribute(
    EXPORTING
      name =  `OBJECT_ID`
    IMPORTING
      value = item_object_id ).
  object_id = item_object_id.
ENDMETHOD.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
METHOD GET_TRANSACTION_MODUS .
*******************************************************************************************
* RTH - A long time ago
* Description:
* Returns the transaction mode that determinates if the action is 'CREATE' or 'EDIT'.
* The transaction mode is definied in the master components "ZV_OBJECT_CREATE" and
* "ZV_OBJECT_CHANGE" using a interface node.
*******************************************************************************************
  DATA:
    node_object_repository_md           TYPE REF TO if_wd_context_node,
    elem_object_repository_md           TYPE REF TO if_wd_context_element.
*  navigate from <CONTEXT> to <OBJECT_REPOSITORY_MD> via lead selection
  node_object_repository_md = wd_context->get_child_node( name = `OBJECT_REPOSITORY` ).
*  get element via lead selection
  elem_object_repository_md = node_object_repository_md->get_element(  ).
*  get single attribute
  elem_object_repository_md->get_attribute( EXPORTING  name = `TRANSACTION_MODE` IMPORTING value = transaction ).
ENDMETHOD.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method HIDE_COMPONENT .
  data lo_nd_visibility type ref to if_wd_context_node.
  data lo_el_visibility type ref to if_wd_context_element.
  data ls_visibility type wd_this->element_visibility.
  data lv_visibility_root type wd_this->element_visibility-visibility_root.
*   navigate from <CONTEXT> to <VISIBILITY> via lead selection
  lo_nd_visibility = wd_context->path_get_node( path = `VIEW_PROPERTIES.VISIBILITY` ).
*   get element via lead selection
  lo_el_visibility = lo_nd_visibility->get_element( ).
*   set single attribute
  lo_el_visibility->set_attribute(
    name =  `VISIBILITY_ROOT`
    value = cl_wd_uielement=>e_visible-none ).
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method INIT_VIEW .
  DATA lv_mussfeld                          type wdui_state value 1.
  DATA lo_nd_view_properties TYPE REF TO if_wd_context_node.
  DATA lo_el_view_properties TYPE REF TO if_wd_context_element.
  DATA ls_view_properties TYPE wd_this->Element_view_properties.
  "DATA lv_mussfeld TYPE wd_this->Element_view_properties-mussfeld.
* navigate from <CONTEXT> to <VIEW_PROPERTIES> via lead selection
  lo_nd_view_properties = wd_context->get_child_node( name = wd_this->wdctx_view_properties ).
* get element via lead selection
  lo_el_view_properties = lo_nd_view_properties->get_element( ).
* set single attribute
  lo_el_view_properties->set_attribute(
    name =  `MUSSFELD`
    value = lv_mussfeld ).
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
METHOD SET_TRANSACTION_MODE .
******************************************************************************************
* RTH - 20.01.2006
* Description:
* Sets the value of argument TRANSACTION_MODE into Interface Context Node OBJECT_REPOSITORY_MD.
******************************************************************************************
  DATA:
    node_object_repository_md           TYPE REF TO if_wd_context_node,
    elem_object_repository_md           TYPE REF TO if_wd_context_element .
*   navigate from <CONTEXT> to <OBJECT_REPOSITORY_MD> via lead selection
  node_object_repository_md = wd_context->get_child_node( name = `OBJECT_REPOSITORY` ).
*   get element via lead selection
  elem_object_repository_md = node_object_repository_md->get_element(  ).
  elem_object_repository_md->set_attribute( name = 'TRANSACTION_MODE' value = transaction_mode ).
ENDMETHOD.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method CHECK_INPUT_FIELDS .
  e_valid = abap_true.
* Zeitungskennzahl prüfen, falls Daten Postversand sichtbar
  DATA lo_nd_daten_postversand_p TYPE REF TO if_wd_context_node.
  DATA lo_el_daten_postversand_p TYPE REF TO if_wd_context_element.
  DATA ls_daten_postversand_p TYPE wd_this->Element_daten_postversand_p.
  DATA lv_daten_postversand_visible TYPE wd_this->Element_daten_postversand_p-daten_postversand_visible.
  lo_nd_daten_postversand_p = wd_context->get_child_node( name = wd_this->wdctx_daten_postversand_p ).
  lo_el_daten_postversand_p = lo_nd_daten_postversand_p->get_element( ).
* get single attribute
  lo_el_daten_postversand_p->get_attribute(
    EXPORTING
      name =  `DATEN_POSTVERSAND_VISIBLE`
    IMPORTING
      value = lv_daten_postversand_visible ).
*
  if lv_daten_postversand_visible = abap_true.
    DATA lo_nd_daten_postversand TYPE REF TO if_wd_context_node.
    DATA lo_el_daten_postversand TYPE REF TO if_wd_context_element.
    DATA ls_daten_postversand TYPE wd_this->Element_daten_postversand.
    DATA lv_zeitungskennzahl TYPE wd_this->Element_daten_postversand-zeitungskennzahl.
* navigate from <CONTEXT> to <DATEN_POSTVERSAND> via lead selection
    lo_nd_daten_postversand = wd_context->get_child_node( name = wd_this->wdctx_daten_postversand ).
* get element via lead selection
    lo_el_daten_postversand = lo_nd_daten_postversand->get_element( ).
* get single attribute
    lo_el_daten_postversand->get_attribute(
      EXPORTING
        name =  `ZEITUNGSKENNZAHL`
      IMPORTING
        value = lv_zeitungskennzahl ).
*    if lv_zeitungskennzahl is initial.
*      wd_this->write_validation_error_msg(
*        attribute = 'ZEITUNGSKENNZAHL'
*        element = lo_el_daten_postversand
*        message = 'Bitte geben Sie einen Wert für die Zeitungskennzahl an'
*      ).
*      e_valid = abap_false.
*    endif.
  endif.
* Prüfe, ob mindestens 1 Druckort angegeben
  DATA lo_nd_druck_ansprechprtnr TYPE REF TO if_wd_context_node.
  DATA lo_el_druck_ansprechprtnr TYPE REF TO if_wd_context_element.
  DATA ls_druck_ansprechprtnr TYPE wd_this->Element_druck_ansprechprtnr.
  DATA lv_druckort_nr TYPE wd_this->Element_druck_ansprechprtnr-druckort_nr.
  lo_nd_druck_ansprechprtnr = wd_context->get_child_node( name = wd_this->wdctx_druck_ansprechprtnr ).
* get element via lead selection
  lo_el_druck_ansprechprtnr = lo_nd_druck_ansprechprtnr->get_element( ).
  if LO_EL_DRUCK_ANSPRECHPRTNR is initial.
    wd_this->WRITE_TRANSACTION_MSG(
      EXPORTING
        MSG_TEXT = 'Objekt benötigt mindestens einen Druckort.'
        MSG_TYPE = 'ERROR'
    ).
  endif.
* Prüfe, ob mindestens eine Versandart angegeben
  DATA lo_nd_versandarten TYPE REF TO if_wd_context_node.
*  DATA lt_versandarten TYPE wd_this->Elements_versandarten.
  DATA lo_el_versandarten TYPE REF TO if_wd_context_element.
  lo_nd_versandarten = wd_context->get_child_node( name = wd_this->wdctx_versandarten ).
  LO_EL_VERSANDARTEN = LO_ND_VERSANDARTEN->get_element( ).
  if LO_EL_VERSANDARTEN is initial.
    wd_this->WRITE_TRANSACTION_MSG(
  EXPORTING
    MSG_TEXT = 'Objekt benötigt mindestens eine Versandart.'
    MSG_TYPE = 'ERROR'
).
    e_valid = abap_false.
  endif.
* Prüfe, ob Spedition angegeben
  DATA lo_nd_spdn_ansprechpartner TYPE REF TO if_wd_context_node.
*  DATA lt_spdn_ansprechpartner TYPE wd_this->Elements_spdn_ansprechpartner.
  DATA lo_el_spdn_ansprechpartner TYPE REF TO if_wd_context_element.
  lo_nd_spdn_ansprechpartner = wd_context->get_child_node( name = wd_this->wdctx_spdn_ansprechpartner ).
  LO_EL_SPDN_ANSPRECHPARTNER = LO_ND_SPDN_ANSPRECHPARTNER->get_element( ).
  if LO_EL_SPDN_ANSPRECHPARTNER is initial.
    wd_this->WRITE_TRANSACTION_MSG(
  EXPORTING
    MSG_TEXT = 'Objekt benötigt mindestens eine Spedition.'
    MSG_TYPE = 'ERROR'
).
    e_valid = abap_false.
  endif.
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method map_status .
************************************************************************************************
* RTH - 20.04.2006
* Description:
* Sets the value of flag E_STR_OBJEKT->FREIG_STAT_VERSAND into the object repository.
************************************************************************************************
  data:
    node_init_obj_versand                 type ref to if_wd_context_node,
    node_exporting_init                 type ref to if_wd_context_node,
    node_e_str_object_init              type ref to if_wd_context_node,
    elem_e_str_object_init              type ref to if_wd_context_element,
    stru_e_str_object_init              type if_componentcontroller=>element_e_str_object_init ,
    item_freig_stat_versand               like stru_e_str_object_init-freig_stat_versand.
  node_init_obj_versand = wd_context->get_child_node( name = `INIT_OBJ_VERSAND` ).
  node_exporting_init = node_init_obj_versand->get_child_node( name = `EXPORTING_INIT` ).
  node_e_str_object_init = node_exporting_init->get_child_node( name = `E_STR_OBJECT_INIT` ).
*  get element via lead selection
  elem_e_str_object_init = node_e_str_object_init->get_element(  ).
*  get single attribute
  elem_e_str_object_init->get_attribute( exporting name =  `FREIG_STAT_VERSAND` importing  value = item_freig_stat_versand ).
  data:
    node_object_repository              type ref to if_wd_context_node,
    elem_object_repository              type ref to if_wd_context_element.
* navigate from <CONTEXT> to <OBJECT_REPOSITORY> via lead selection
  node_object_repository = wd_context->get_child_node( name = `OBJECT_REPOSITORY` ).
* get element via lead selection
  elem_object_repository = node_object_repository->get_element(  ).
* get all declared attributes
  elem_object_repository->set_attribute( name = 'FREIGABE_STATUS_VERSAND' value = item_freig_stat_versand  ).
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method SET_SC_INIT_INPUT .
    DATA:
      node_init_obj_versand                 TYPE REF TO if_wd_context_node,
      node_importing_init                 TYPE REF TO if_wd_context_node,
      elem_importing_init                 TYPE REF TO if_wd_context_element .
*   navigate from <CONTEXT> to <INIT_OBJ_VERSAND> via lead selection
    node_init_obj_versand = wd_context->get_child_node( name = `INIT_OBJ_VERSAND` ).
*   navigate from <INIT_OBJ_VERSAND> to <IMPORTING_INIT> via lead selection
    node_importing_init = node_init_obj_versand->get_child_node( name = `IMPORTING_INIT` ).
*   get element via lead selection
    elem_importing_init = node_importing_init->get_element(  ).
    elem_importing_init->set_attribute( name = 'I_OBJECT_ID' value = object_id ).
    elem_importing_init->set_attribute( name = 'I_LOCK' value = is_locked ).
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method ADD_SPEDITION .
*
* Schlüssel aus DDK VS lesen
*
  DATA lo_nd_value_sets TYPE REF TO if_wd_context_node.
  DATA lo_el_value_sets TYPE REF TO if_wd_context_element.
  DATA ls_value_sets TYPE wd_this->Element_value_sets.
  DATA lv_spedition_ddk TYPE wd_this->Element_value_sets-spedition_ddk.
  lo_nd_value_sets = wd_context->get_child_node( name = wd_this->wdctx_value_sets ).
  lo_el_value_sets = lo_nd_value_sets->get_element( ).
  lo_el_value_sets->get_attribute(
    EXPORTING
      name =  `SPEDITION_DDK`
    IMPORTING
      value = lv_spedition_ddk ).
* Schlüssel hat Wert '#', falls nichts ausgewählt wurde
  if lv_spedition_ddk ne '#'.
*
*   Tabelle aus DDK Node lesen
*
    DATA lo_nd_spedition_anspr_ddk TYPE REF TO if_wd_context_node.
    DATA lt_spedition_anspr_ddk TYPE wd_this->Elements_spedition_anspr_ddk.
    lo_nd_spedition_anspr_ddk = wd_context->get_child_node( name = wd_this->wdctx_spedition_anspr_ddk ).
    lo_nd_spedition_anspr_ddk->get_static_attributes_table( importing table = lt_spedition_anspr_ddk ).
*
*   Relevante Zeile aus Tabelle lesen und in Struktur speichern
*
    DATA lstr_spedition TYPE ZVST_VERSAND_SPEDITION.
    READ TABLE lt_spedition_anspr_ddk WITH KEY spedition_NR = lv_spedition_ddk
    INTO lstr_spedition.
*
*   Ansprechpartner hinzufügen
*
    DATA ltab_ansprechpartner TYPE ZVTT_ANSPRECHPARTNER.
    DATA lstr_ansprechpartner TYPE ZVST_ANSPRECHPARTNER.
    DATA lv_string TYPE ZVDE_STRING.
    DATA lv_eltern_id TYPE ZVDE_ELTERN_ID.
    lv_eltern_id = lv_spedition_ddk.
    CALL FUNCTION 'ZV_GET_ANSPRECHPARTNER_MAPI'
      EXPORTING
        IV_ELTERN_ID       =  lv_eltern_id
        IV_ART             =  'SP'
     IMPORTING
       ETAB_RESULT        = ltab_ansprechpartner
*       ETAB_RETURN        =
              .
    READ TABLE LTAB_ANSPRECHPARTNER index 1 into LSTR_ANSPRECHPARTNER.
*    LOOP AT LTAB_ANSPRECHPARTNER INTO LSTR_ANSPRECHPARTNER.
*      if sy-TABIX eq 1.
*        exit.
*       endif.
*    ENDLOOP.
    CONCATENATE LSTR_ANSPRECHPARTNER-VORNAME LSTR_ANSPRECHPARTNER-NACHNAME into lv_string SEPARATED BY SPACE.
    LSTR_spedition-ANSPRECHPARTNER_NAME = lv_string.
*
*   Bestehende Zeile ersetzen
*
    DATA: lo_nd_spdn_ansprechpartner  TYPE REF TO IF_WD_CONTEXT_NODE,
          lo_el_spdn_ansprechpartner TYPE REF TO if_wd_context_element,
          lt_spdn_ansprechprtnr     TYPE WD_THIS->ELEMENTS_spdn_ansprechpartner,
          ls_spdn_ansprechprtnr     TYPE WD_THIS->ELEMENT_spdn_ansprechpartner.
    LO_ND_spdn_ansprechpartner = WD_CONTEXT->GET_CHILD_NODE( name = wd_this->WDCTX_SPDN_ANSPRECHPARTNER ).
    lo_el_spdn_ansprechpartner = lo_nd_spdn_ansprechpartner->get_element(  ).
      IF lo_el_spdn_ansprechpartner IS NOT INITIAL.
        "Zu entfernende Zeile speichern
          lo_el_spdn_ansprechpartner->get_static_attributes(
          IMPORTING
            static_attributes = ls_spdn_ansprechprtnr ).
        "Zeile aus Tabelle entfernen
        lo_nd_spdn_ansprechpartner->remove_element( lo_el_spdn_ansprechpartner ).
        "Entfernte Zeile zu DDK hinzufügen
        lo_nd_spedition_anspr_ddk = wd_context->get_child_node( name = wd_this->wdctx_spedition_anspr_ddk ).
        lo_nd_spedition_anspr_ddk->get_static_attributes_table( importing table = lt_spedition_anspr_ddk ).
          " Zeile aus interner Tabelle löschen
           DELETE lt_spedition_anspr_ddk WHERE
           spedition_NR EQ lv_spedition_ddk.
        APPEND ls_spdn_ansprechprtnr TO lt_spedition_anspr_ddk.
        SORT lt_spedition_anspr_ddk ASCENDING.
        lo_nd_spedition_anspr_ddk->bind_table( new_items = lt_spedition_anspr_ddk set_initial_elements = abap_true ).
      ENDIF.
    APPEND lstr_spedition TO LT_SPDN_ANSPRECHPRTNR.
    SORT lt_spdn_ansprechprtnr ASCENDING.
    LO_ND_SPDN_ANSPRECHPARTNER->BIND_TABLE(
      exporting
        NEW_ITEMS            = LT_SPDN_ANSPRECHPRTNR
        SET_INITIAL_ELEMENTS = ABAP_false
    ).
    " Werte für DDK neu laden
    WD_THIS->FILL_VS_SPEDITION_DDK( ).
*
*   Auswahl im Context aktualisieren
*
      DATA lo_nd_e_str_object_init TYPE REF TO if_wd_context_node.
      DATA lo_el_e_str_object_init TYPE REF TO if_wd_context_element.
      DATA ls_e_str_object_init TYPE wd_this->Element_e_str_object_init.
      DATA lv_zzspdnr TYPE wd_this->Element_e_str_object_init-zzspdnr.
      lo_nd_e_str_object_init = wd_context->path_get_node( path = `INIT_OBJ_VERSAND.EXPORTING_INIT.E_STR_OBJECT_INIT` ).
      lo_el_e_str_object_init = lo_nd_e_str_object_init->get_element( ).
      lv_zzspdnr = lv_spedition_ddk.
*     set single attribute
      lo_el_e_str_object_init->set_attribute(
        name =  `ZZSPDNR`
        value = lv_zzspdnr ).
  else.
* TODO: Fehlermeldung ausgeben
  endif.
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
METHOD RESET_VALUES_CHANGED .
  DATA:
    node_init_obj_versand                 TYPE REF TO if_wd_context_node,
    node_exporting_init                 TYPE REF TO if_wd_context_node,
    node_e_str_object_init              TYPE REF TO if_wd_context_node,
    elem_e_str_object_init              TYPE REF TO if_wd_context_element,
    stru_e_str_object_init              TYPE if_componentcontroller=>element_e_str_object_init .
*   navigate from <CONTEXT> to <INIT_OBJ_VERSAND> via lead selection
  node_init_obj_versand = wd_context->get_child_node( name = `INIT_OBJ_VERSAND` ).
*   navigate from <INIT_OBJ_VERSAND> to <EXPORTING_INIT> via lead selection
  node_exporting_init = node_init_obj_versand->get_child_node( name = `EXPORTING_INIT` ).
*   navigate from <EXPORTING_INIT> to <E_STR_OBJECT_INIT> via lead selection
  node_e_str_object_init = node_exporting_init->get_child_node( name = `E_STR_OBJECT_INIT` ).
  node_e_str_object_init->reset_changed_by_client( ).
ENDMETHOD.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method SET_POPUP_SIZE .
  wd_this->popup_height = '600'.
  wd_this->popup_width = '600'.
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method sc_init_obj_versand .
  data:
    node_init_obj_versand   type ref to if_wd_context_node,
    node_exporting_init   type ref to if_wd_context_node,
    node_e_str_object_init   type ref to if_wd_context_node,
    node_e_tab_return_init   type ref to if_wd_context_node,
    node_importing_init   type ref to if_wd_context_node,
    lri_element    type ref to if_wd_context_element,
    loa_elements   type wdr_context_element_set.
* declarations for fuba parameters
  data:
    attr_e_lock    type zvde_sperrkennzeichen.
  data:
    stru_c_e_str_object_init    type if_componentcontroller=>element_e_str_object_init.
  data:
    itab_c_e_tab_return_init    type if_componentcontroller=>elements_e_tab_return_init,
    stru_c_e_tab_return_init    like line of itab_c_e_tab_return_init,
    itab_f_e_tab_return_init    type zvtt_return.
  field-symbols:
    <stru_f_e_tab_return_init>    like line of itab_f_e_tab_return_init.
  data:
    attr_i_lock    type zvde_sperrkennzeichen.
  data:
    attr_i_object_id    type zvst_objekt-objekt.
  data:
    lv_authorized       type zvde_authorized.
* get all involved child nodes
  node_init_obj_versand = wd_context->get_child_node( `INIT_OBJ_VERSAND` ).
  node_exporting_init = node_init_obj_versand->get_child_node( `EXPORTING_INIT` ).
  node_e_str_object_init = node_exporting_init->get_child_node( `E_STR_OBJECT_INIT` ).
  node_e_tab_return_init = node_exporting_init->get_child_node( `E_TAB_RETURN_INIT` ).
  node_importing_init = node_init_obj_versand->get_child_node( `IMPORTING_INIT` ).
* get input from context
  node_importing_init->get_attribute(
    exporting
      name = `I_LOCK`
    importing
      value = attr_i_lock ).
  node_importing_init->get_attribute(
    exporting
      name = `I_OBJECT_ID`
    importing
      value = attr_i_object_id ).
* the invocation - errors are always fatal !!!
  call function 'ZV_INIT_OBJ_VERSAND_MAPI'
    exporting
      i_object_id  = attr_i_object_id
      i_lock       = attr_i_lock
    importing
      e_str_object = stru_c_e_str_object_init
      e_lock       = attr_e_lock
      e_tab_return = itab_f_e_tab_return_init
      ev_authorized = lv_authorized.
if lv_authorized eq abap_true.
*
*   OBJ_BEZ_NR basteln
*
  data lo_nd_value_sets type ref to if_wd_context_node.
  data lo_el_value_sets type ref to if_wd_context_element.
  data ls_value_sets type wd_this->element_value_sets.
  data lv_obj_bez_nr type wd_this->element_value_sets-obj_bez_nr.
  lo_nd_value_sets = wd_context->get_child_node( name = wd_this->wdctx_value_sets ).
  lo_el_value_sets = lo_nd_value_sets->get_element( ).
  concatenate stru_c_e_str_object_init-obj_bez stru_c_e_str_object_init-objekt into lv_obj_bez_nr separated by space.
  lo_el_value_sets->set_attribute(
    name =  `OBJ_BEZ_NR`
    value = lv_obj_bez_nr ).
**  "Initialwerte für DDKs
*
*  data lo_nd_e_str_object_init type ref to if_wd_context_node.
*
*  data lo_el_e_str_object_init type ref to if_wd_context_element.
*  data ls_e_str_object_init type wd_this->element_e_str_object_init.
*
*  lo_nd_e_str_object_init = wd_context->path_get_node( path = `INIT_OBJ_VERSAND.EXPORTING_INIT.E_STR_OBJECT_INIT` ).
*
*  lo_el_e_str_object_init = lo_nd_e_str_object_init->get_element( ).
*
**   get all declared attributes
*  lo_el_e_str_object_init->get_static_attributes(
*    importing
*      static_attributes = ls_e_str_object_init ).
* Aufklebertyp
  data lv_aufklebertyp_ddk type wd_this->element_value_sets-aufklebertyp_ddk.
  if stru_c_e_str_object_init-vs_aufkleber_typ is initial.
    lv_aufklebertyp_ddk = 1.
  else.
    lv_aufklebertyp_ddk = stru_c_e_str_object_init-vs_aufkleber_typ.
  endif.
  lo_el_value_sets->set_attribute(
    name =  `AUFKLEBERTYP_DDK`
    value = lv_aufklebertyp_ddk ).
  node_e_str_object_init->bind_structure( stru_c_e_str_object_init ).
endif.
* store output to context
  node_exporting_init->set_attribute(
    exporting
      name = `E_LOCK_INIT`
      value = attr_e_lock ).
  wd_this->print_all_return_messages( itab_f_e_tab_return_init ).
  ev_authorized = lv_authorized.
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method ADD_DRUCKORT .
*
* Schlüssel aus DDK VS lesen
*
  DATA lo_nd_value_sets TYPE REF TO if_wd_context_node.
  DATA lo_el_value_sets TYPE REF TO if_wd_context_element.
  DATA ls_value_sets TYPE wd_this->Element_value_sets.
  DATA lv_druckort_ddk TYPE wd_this->Element_value_sets-druckort_ddk.
  lo_nd_value_sets = wd_context->get_child_node( name = wd_this->wdctx_value_sets ).
  lo_el_value_sets = lo_nd_value_sets->get_element( ).
  lo_el_value_sets->get_attribute(
    EXPORTING
      name =  `DRUCKORT_DDK`
    IMPORTING
      value = lv_druckort_ddk ).
* Schlüssel hat Wert '#', falls nichts ausgewählt wurde
  if lv_druckort_ddk ne '#'.
*
*   Tabelle aus DDK Node lesen
*
    DATA lo_nd_druckort_anspr_ddk TYPE REF TO if_wd_context_node.
    DATA lt_druckort_anspr_ddk TYPE wd_this->Elements_druckort_anspr_ddk.
    lo_nd_druckort_anspr_ddk = wd_context->get_child_node( name = wd_this->wdctx_druckort_anspr_ddk ).
    lo_nd_druckort_anspr_ddk->get_static_attributes_table( importing table = lt_druckort_anspr_ddk ).
*
*   Relevante Zeile aus Tabelle lesen und in Struktur speichern
*
    DATA lstr_druckort TYPE ZVST_DRUCKORT_ANSPRECHPARTNER.
    READ TABLE lt_druckort_anspr_ddk WITH KEY DRUCKORT_NR = lv_druckort_ddk
    INTO lstr_druckort.
*
*   Ansprechpartner hinzufügen
*
    DATA ltab_ansprechpartner TYPE ZVTT_ANSPRECHPARTNER.
    DATA lstr_ansprechpartner TYPE ZVST_ANSPRECHPARTNER.
    DATA lv_string TYPE ZVDE_STRING.
    DATA lv_eltern_id TYPE ZVDE_ELTERN_ID.
    lv_eltern_id = lv_druckort_ddk.
    CALL FUNCTION 'ZV_GET_ANSPRECHPARTNER_MAPI'
      EXPORTING
        IV_ELTERN_ID = lv_eltern_id
        IV_ART       = 'DR'
      IMPORTING
        ETAB_RESULT  = ltab_ansprechpartner
*       ETAB_RETURN  =
      .
    READ TABLE LTAB_ANSPRECHPARTNER index 1 into LSTR_ANSPRECHPARTNER.
*    LOOP AT LTAB_ANSPRECHPARTNER INTO LSTR_ANSPRECHPARTNER.
*      if sy-TABIX eq 1.
*        exit.
*       endif.
*    ENDLOOP.
    CONCATENATE LSTR_ANSPRECHPARTNER-VORNAME LSTR_ANSPRECHPARTNER-NACHNAME into lv_string SEPARATED BY SPACE.
    LSTR_DRUCKORT-ANSPRECHPARTNER_NAME = lv_string.
*
*   Action Flag setzen
*
    lstr_druckort-action = '1'.
*
*   Neue Zeile an bestehende Tabelle anhängen
*
    DATA lo_nd_druck_ansprechprtnr TYPE REF TO if_wd_context_node.
    DATA lt_druck_ansprechprtnr TYPE wd_this->Elements_druck_ansprechprtnr.
    lo_nd_druck_ansprechprtnr = wd_context->get_child_node( name = wd_this->wdctx_druck_ansprechprtnr ).
    lo_nd_druck_ansprechprtnr->get_static_attributes_table( importing table = lt_druck_ansprechprtnr ).
    DELETE LT_DRUCKORT_ANSPR_DDK WHERE
    DRUCKORT_NR NE lv_druckort_ddk.
    APPEND lstr_druckort TO LT_druck_ansprechprtnr.
    SORT lt_druck_ansprechprtnr ASCENDING.
    LO_ND_druck_ansprechprtnr->BIND_TABLE(
      exporting
        NEW_ITEMS            = LT_druck_ansprechprtnr
        SET_INITIAL_ELEMENTS = ABAP_true
    ).
*
*   Werte für DDK erneuern
*
    lo_nd_druckort_anspr_ddk = wd_context->get_child_node( name = wd_this->wdctx_druckort_anspr_ddk ).
    lo_nd_druckort_anspr_ddk->get_static_attributes_table( importing table = lt_druckort_anspr_ddk ).
    " Zeile aus interner Tabelle löschen
    DELETE LT_DRUCKORT_ANSPR_DDK WHERE
    DRUCKORT_NR EQ lv_druckort_ddk.
    SORT lt_druckort_anspr_ddk ASCENDING.
    " Tabelle neu binden
    lo_nd_druckort_anspr_ddk = wd_context->get_child_node( name = wd_this->wdctx_druckort_anspr_ddk ).
    lo_nd_druckort_anspr_ddk->bind_table( new_items = lt_druckort_anspr_ddk set_initial_elements = abap_true ).
    " Werte für DDK neu laden
    WD_THIS->FILL_VS_DRUCKORT_DDK( ).
  else.
* TODO: Fehlermeldung ausgeben
  endif.
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method ADD_VERSANDART .
*
* Schlüssel aus DDK VS lesen
*
  DATA lo_nd_value_sets TYPE REF TO if_wd_context_node.
  DATA lo_el_value_sets TYPE REF TO if_wd_context_element.
  DATA ls_value_sets TYPE wd_this->Element_value_sets.
  DATA lv_versandart_ddk TYPE wd_this->Element_value_sets-versandart_ddk.
  lo_nd_value_sets = wd_context->get_child_node( name = wd_this->wdctx_value_sets ).
  lo_el_value_sets = lo_nd_value_sets->get_element( ).
  lo_el_value_sets->get_attribute(
    EXPORTING
      name =  `VERSANDART_DDK`
    IMPORTING
      value = lv_versandart_ddk ).
* Schlüssel hat Wert '#', falls nichts ausgewählt wurde
  if lv_versandart_ddk ne '#'.
*
*   Tabelle aus DDK Node lesen
*
    DATA lo_nd_versandart_ddk TYPE REF TO if_wd_context_node.
    DATA lt_versandart_ddk TYPE wd_this->Elements_versandart_ddk.
    lo_nd_versandart_ddk = wd_context->get_child_node( name = wd_this->wdctx_versandart_ddk ).
    lo_nd_versandart_ddk->get_static_attributes_table( importing table = lt_versandart_ddk ).
*
*   Relevante Zeile aus Tabelle lesen und in Struktur speichern
*
    DATA lstr_versandart TYPE ZVST_versandart.
    READ TABLE lt_versandart_ddk WITH KEY VERSANDART = lv_versandart_ddk
    INTO lstr_versandart.
*
*   Action Flag setzen
*
    lstr_versandart-ACTION = '1'.
*
*   Neue Zeile an bestehende Tabelle anhängen
*
    DATA lo_nd_versandart TYPE REF TO if_wd_context_node.
    DATA lt_versandart TYPE wd_this->Elements_versandarten.
    lo_nd_versandart = wd_context->get_child_node( name = wd_this->wdctx_versandarten ).
    lo_nd_versandart->get_static_attributes_table( importing table = lt_versandart ).
    DELETE LT_versandart_DDK WHERE
    versandart NE lv_versandart_ddk.
    APPEND lstr_versandart TO LT_versandart.
    SORT lt_versandart ASCENDING.
    LO_ND_versandart->BIND_TABLE(
      exporting
        NEW_ITEMS            = LT_versandart
        SET_INITIAL_ELEMENTS = ABAP_true
    ).
*
*   Werte für DDK erneuern
*
    lo_nd_versandart_ddk = wd_context->get_child_node( name = wd_this->wdctx_versandart_ddk ).
    lo_nd_versandart_ddk->get_static_attributes_table( importing table = lt_versandart_ddk ).
    " Zeile aus interner Tabelle löschen
    DELETE LT_versandart_DDK WHERE
    VERSANDART EQ lv_versandart_ddk.
    SORT lt_versandart_ddk ASCENDING.
    " Tabelle neu binden
    lo_nd_versandart_ddk = wd_context->get_child_node( name = wd_this->wdctx_versandart_ddk ).
    lo_nd_versandart_ddk->bind_table( new_items = lt_versandart_ddk set_initial_elements = abap_true ).
    " Werte für DDK neu laden
    WD_THIS->FILL_VS_versandart_DDK( ).
  else.
* TODO: Fehlermeldung ausgeben
  endif.
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method BACKUP_VERSAND_OBJEKT .
  data:
    node_init_obj_versand               type ref to if_wd_context_node,
    node_exporting_init                 type ref to if_wd_context_node,
    node_e_str_object_init              type ref to if_wd_context_node,
    elem_e_str_object_init              type ref to if_wd_context_element,
    stru_e_str_object_init              type if_componentcontroller=>element_e_str_object_init .
*  navigate from <CONTEXT> to <INIT_OBJ_VERSAND> via lead selection
  node_init_obj_versand = wd_context->get_child_node( name = if_componentcontroller=>wdctx_init_obj_versand ).
*  navigate from <INIT_OBJ_VERSAND> to <EXPORTING_INIT> via lead selection
  node_exporting_init = node_init_obj_versand->get_child_node( name = if_componentcontroller=>wdctx_exporting_init ).
*  navigate from <EXPORTING_INIT> to <E_STR_OBJECT_INIT> via lead selection
  node_e_str_object_init = node_exporting_init->get_child_node( name = if_componentcontroller=>wdctx_e_str_object_init ).
*  get element via lead selection
  elem_e_str_object_init = node_e_str_object_init->get_element(  ).
*  get all declared attributes
  elem_e_str_object_init->get_static_attributes(
    importing
      static_attributes = stru_e_str_object_init ).
  wd_this->orig_str_object = stru_e_str_object_init.
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method FILL_VS_DRUCKORT_DDK .
  data: node_value_sets        type ref to if_wd_context_node,
        node_data              type ref to if_wd_context_node,
        l_current_controller   type ref to if_wd_controller.
  l_current_controller ?= wd_this->wd_get_api( ).
  node_value_sets = wd_context->get_child_node( name = WD_THIS->WDCTX_VALUE_SETS ).
  node_data = wd_context->get_child_node( name = wd_this->WDCTX_DRUCKORT_ANSPR_DDK ).
  zcl_valueset_helper=>fill_value_set(
    valueset_node = node_value_sets
    attribute = 'DRUCKORT_DDK'
    table_node = node_data
    key_field = 'DRUCKORT_NR'
    descr_field = 'DRUCKORT_NAME'
    DESCR_FIELD_I = 'DRUCKORT_ORT'
    key_in_descr = abap_true
  ).
  call method zcl_valueset_helper=>set_value_set_value
    exporting
      node       = node_value_sets
      attribute  = 'DRUCKORT_DDK'
      value      = zcl_vis_properties=>valueset_default_key
      controller = l_current_controller.
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
METHOD fill_vs_versandart_ddk .
  DATA: node_value_sets        TYPE REF TO if_wd_context_node,
        node_data              TYPE REF TO if_wd_context_node,
        l_current_controller   TYPE REF TO if_wd_controller.
  l_current_controller ?= wd_this->wd_get_api( ).
  node_value_sets = wd_context->get_child_node( name = wd_this->wdctx_value_sets ).
  node_data = wd_context->get_child_node( name = wd_this->wdctx_versandart_ddk ).
  zcl_valueset_helper=>fill_value_set(
    valueset_node = node_value_sets
    attribute = 'VERSANDART_DDK'
    table_node = node_data
    key_field = 'VERSANDART'
    descr_field = 'VERSANDART_BEZ'
    key_in_descr = abap_true
  ).
  CALL METHOD zcl_valueset_helper=>set_value_set_value
    EXPORTING
      node       = node_value_sets
      attribute  = 'VERSANDART_DDK'
      value      = zcl_vis_properties=>valueset_default_key
      controller = l_current_controller.
* Daten Postversand sollen nur bei vorhandener Versandart "Postversand" sichtbar sein
* Daten Postversand sollen nur bei vorhandener Transportart "P" sichtbar sein
  DATA lo_nd_versandarten TYPE REF TO if_wd_context_node.
  DATA lt_versandarten TYPE wd_this->elements_versandarten.
  DATA ls_versandarten TYPE zvst_versandart.
  lo_nd_versandarten = wd_context->get_child_node( name = wd_this->wdctx_versandarten ).
  lo_nd_versandarten->get_static_attributes_table( IMPORTING table = lt_versandarten ).
  " Suche nach Versandart "Postversand" in Versandarten-Tabelle
  " Suche nach Transportart "P" in Versandarten-Tabelle
  DATA lv_daten_postversand_visible TYPE wd_this->element_daten_postversand_p-daten_postversand_visible.
  lv_daten_postversand_visible = abap_false.
  LOOP AT lt_versandarten INTO ls_versandarten.
    "    DATA lv_postversand TYPE zvst_versandart-versandart_bez.
    "    lv_postversand = ls_versandarten-versandart_bez.
    "    TRANSLATE lv_postversand TO LOWER CASE.
    "    IF lv_postversand EQ 'postversand'.
    "      lv_daten_postversand_visible = abap_true.
    "    ENDIF.
    DATA  lv_transportart TYPE zvst_versandart-transportart.
    lv_transportart = ls_versandarten-transportart.
    IF lv_transportart EQ 'P'.
      lv_daten_postversand_visible = abap_true.
    ENDIF.
  ENDLOOP.
  DATA lo_nd_daten_postversand_p TYPE REF TO if_wd_context_node.
  DATA lo_el_daten_postversand_p TYPE REF TO if_wd_context_element.
  DATA ls_daten_postversand_p TYPE wd_this->element_daten_postversand_p.
  lo_nd_daten_postversand_p = wd_context->get_child_node( name = wd_this->wdctx_daten_postversand_p ).
  lo_el_daten_postversand_p = lo_nd_daten_postversand_p->get_element( ).
  IF lo_el_daten_postversand_p IS INITIAL.
  ENDIF.
*       set single attribute
  lo_el_daten_postversand_p->set_attribute(
    name =  `DATEN_POSTVERSAND_VISIBLE`
    value = lv_daten_postversand_visible ).
ENDMETHOD.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method FILL_VS_SPEDITION_DDK .
  data: node_value_sets        type ref to if_wd_context_node,
        node_data              type ref to if_wd_context_node,
        l_current_controller   type ref to if_wd_controller.
  l_current_controller ?= wd_this->wd_get_api( ).
  node_value_sets = wd_context->get_child_node( name = WD_THIS->WDCTX_VALUE_SETS ).
  node_data = wd_context->get_child_node( name = wd_this->WDCTX_SPEDITION_ANSPR_DDK ).
  zcl_valueset_helper=>fill_value_set(
    valueset_node = node_value_sets
    attribute = 'SPEDITION_DDK'
    table_node = node_data
    key_field = 'SPEDITION_NR'
    descr_field = 'SPEDITION_NAME'
    DESCR_FIELD_I = 'SPEDITION_ORT'
    key_in_descr = abap_true
  ).
  call method zcl_valueset_helper=>set_value_set_value
    exporting
      node       = node_value_sets
      attribute  = 'SPEDITION_DDK'
      value      = zcl_vis_properties=>valueset_default_key
      controller = l_current_controller.
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method INIT_DATEN_POSTVERSAND .
  DATA: lstr_result type ZVST_DATEN_POSTVERSAND,
      lv_objekt   type ZVDE_OBJEKT,
      ltab_return type zvtt_return.
  DATA lo_nd_object_repository TYPE REF TO if_wd_context_node.
  DATA lo_el_object_repository TYPE REF TO if_wd_context_element.
  DATA ls_object_repository TYPE wd_this->Element_object_repository.
  lo_nd_object_repository = wd_context->get_child_node( name = wd_this->wdctx_object_repository ).
  lo_el_object_repository = lo_nd_object_repository->get_element( ).
* get single attribute
  lo_el_object_repository->get_attribute(
    EXPORTING
      name =  `OBJECT_ID`
    IMPORTING
      value = lv_objekt ).
  CALL FUNCTION 'ZV_GET_DATEN_POSTVERSAND_MAPI'
    EXPORTING
      IV_OBJ      = lv_objekt
    IMPORTING
      ESTR_RESULT = lstr_result
      ETAB_RETURN = ltab_return.
  DATA lo_nd_daten_postversand TYPE REF TO if_wd_context_node.
  DATA lo_el_daten_postversand TYPE REF TO if_wd_context_element.
  DATA ls_daten_postversand TYPE wd_this->Element_daten_postversand.
* navigate from <CONTEXT> to <DATEN_POSTVERSAND> via lead selection
  lo_nd_daten_postversand = wd_context->get_child_node( name = wd_this->wdctx_daten_postversand ).
* get element via lead selection
  lo_el_daten_postversand = lo_nd_daten_postversand->get_element( ).
* set all declared attributes
  lo_nd_daten_postversand->set_static_attributes(
     static_attributes = lstr_result ).
** Daten Postversand sollen nur bei vorhandener Versandart "Postversand" sichtbar sein
*
*  DATA lo_nd_versandarten TYPE REF TO if_wd_context_node.
*
*  DATA lt_versandarten TYPE wd_this->Elements_versandarten.
*
*  DATA ls_versandarten TYPE ZVST_VERSANDART.
*
*  lo_nd_versandarten = wd_context->get_child_node( name = wd_this->wdctx_versandarten ).
*
*  lo_nd_versandarten->get_static_attributes_table( importing table = lt_versandarten ).
*
*  " Suche nach Versandart "Postversand" in Versandarten-Tabelle
*
*  DATA lv_daten_postversand_visible TYPE wd_this->Element_daten_postversand_p-daten_postversand_visible.
*  lv_daten_postversand_visible = abap_false.
*
*  loop at lt_versandarten into ls_versandarten.
*    DATA lv_postversand TYPE zvst_versandart-versandart_bez.
*    lv_postversand = ls_versandarten-versandart_bez.
*    translate lv_postversand to lower case.
*    if lv_postversand EQ 'postversand'.
*      lv_daten_postversand_visible = abap_true.
*    endif.
*  endloop.
*
*  DATA lo_nd_daten_postversand_p TYPE REF TO if_wd_context_node.
*
*  DATA lo_el_daten_postversand_p TYPE REF TO if_wd_context_element.
*  DATA ls_daten_postversand_p TYPE wd_this->Element_daten_postversand_p.
*
*  lo_nd_daten_postversand_p = wd_context->get_child_node( name = wd_this->wdctx_daten_postversand_p ).
*
*  lo_el_daten_postversand_p = lo_nd_daten_postversand_p->get_element( ).
*  IF lo_el_daten_postversand_p IS INITIAL.
*  ENDIF.
*
**       set single attribute
*  lo_el_daten_postversand_p->set_attribute(
*    name =  `DATEN_POSTVERSAND_VISIBLE`
*    value = lv_daten_postversand_visible ).
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
METHOD init_radiobutton_sortenbez .
  DATA lo_nd_sortenbez TYPE REF TO if_wd_context_node.
  DATA lo_el_sortenbez TYPE REF TO if_wd_context_element.
  DATA ls_sortenbez TYPE wd_this->element_sortenbez.
  DATA lo_el_e_str_object_init TYPE REF TO if_wd_context_element.
  DATA lv_vs_sortenbez_fill TYPE wd_this->element_e_str_object_init-vs_sortenbez_fill.
  DATA lv_vs_sortenbez_num TYPE wd_this->element_e_str_object_init-vs_sortenbez_num.
  lo_el_e_str_object_init = wd_context->path_get_node( path = `INIT_OBJ_VERSAND.EXPORTING_INIT.E_STR_OBJECT_INIT` )->get_element( ).
  lo_el_e_str_object_init->get_attribute(
    EXPORTING
      name =  `VS_SORTENBEZ_FILL`
    IMPORTING
      value = lv_vs_sortenbez_fill ).
  lo_el_e_str_object_init->get_attribute(
    EXPORTING
      name =  `VS_SORTENBEZ_NUM`
    IMPORTING
      value = lv_vs_sortenbez_num ).
  lo_nd_sortenbez = wd_context->path_get_node( path = `RADIOBUTTONS.SORTENBEZ` ).
  lo_nd_sortenbez->invalidate( ).
  lo_el_sortenbez = lo_nd_sortenbez->create_element( ).
  ls_sortenbez-sortenbez = 'Sortenbezeichnung ---*'.
  lo_el_sortenbez->set_static_attributes(
     static_attributes = ls_sortenbez ).
  lo_nd_sortenbez->bind_element(
    EXPORTING
      new_item             = lo_el_sortenbez
      set_initial_elements = abap_false ).
  lo_el_sortenbez = lo_nd_sortenbez->create_element( ).
  ls_sortenbez-sortenbez = 'Sortenbezeichnung beginnt mit ---A'.
  lo_el_sortenbez->set_static_attributes(
     static_attributes = ls_sortenbez ).
  lo_nd_sortenbez->bind_element(
    EXPORTING
      new_item             = lo_el_sortenbez
      set_initial_elements = abap_false ).
  IF ( lv_vs_sortenbez_fill EQ 'X' ).
    lo_nd_sortenbez->set_lead_selection( lo_el_sortenbez ).
  ENDIF.
  lo_el_sortenbez = lo_nd_sortenbez->create_element( ).
  ls_sortenbez-sortenbez = 'Sortenbezeichnung numerisch'.
  lo_el_sortenbez->set_static_attributes(
     static_attributes = ls_sortenbez ).
  lo_nd_sortenbez->bind_element(
    EXPORTING
      new_item             = lo_el_sortenbez
      set_initial_elements = abap_false ).
  IF ( lv_vs_sortenbez_num EQ 'X' ).
    lo_nd_sortenbez->set_lead_selection( lo_el_sortenbez ).
  ENDIF.
ENDMETHOD.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method INIT_DRUCKEREI_TABLE .
DATA: ltab_result type ZVTT_DRUCKORT_ANSPRECHPARTNER,
      lv_objekt   type ZVDE_OBJEKT,
      ltab_return type zvtt_return.
  DATA lo_nd_object_repository TYPE REF TO if_wd_context_node.
  DATA lo_el_object_repository TYPE REF TO if_wd_context_element.
  DATA ls_object_repository TYPE wd_this->Element_object_repository.
  lo_nd_object_repository = wd_context->get_child_node( name = wd_this->wdctx_object_repository ).
  lo_el_object_repository = lo_nd_object_repository->get_element( ).
* get single attribute
  lo_el_object_repository->get_attribute(
    EXPORTING
      name =  `OBJECT_ID`
    IMPORTING
      value = lv_objekt ).
CALL FUNCTION 'ZV_GET_DRUCKORTE_MAPI'
  EXPORTING
    IV_OBJ            = lv_objekt
 IMPORTING
   ETAB_RESULT       = ltab_result
   ETAB_RETURN       = ltab_return
          .
  DATA lo_nd_druck_ansprechprtnr TYPE REF TO if_wd_context_node.
  DATA lt_druck_ansprechprtnr TYPE wd_this->Elements_druck_ansprechprtnr.
  lo_nd_druck_ansprechprtnr = wd_context->get_child_node( name = wd_this->wdctx_druck_ansprechprtnr ).
  lo_nd_druck_ansprechprtnr->BIND_TABLE(
    EXPORTING
      NEW_ITEMS            =  ltab_result   " Liste von Elementen oder Modeldaten
*      SET_INITIAL_ELEMENTS = ABAP_TRUE    " Falls TRUE setzen der initialen Elemente, sonst Anfügen
*      INDEX                =     " Index eines Kontext Elementes
  ).
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method INIT_VERSANDARTEN_TABLE .
DATA: ltab_result type ZVTT_VERSANDART,
      lv_objekt   type ZVDE_OBJEKT,
      ltab_return type zvtt_return.
  DATA lo_nd_object_repository TYPE REF TO if_wd_context_node.
  DATA lo_el_object_repository TYPE REF TO if_wd_context_element.
  DATA ls_object_repository TYPE wd_this->Element_object_repository.
  lo_nd_object_repository = wd_context->get_child_node( name = wd_this->wdctx_object_repository ).
  lo_el_object_repository = lo_nd_object_repository->get_element( ).
* get single attribute
  lo_el_object_repository->get_attribute(
    EXPORTING
      name =  `OBJECT_ID`
    IMPORTING
      value = lv_objekt ).
CALL FUNCTION 'ZV_GET_VERSANDARTEN_MAPI'
  EXPORTING
    IV_OBJ            = lv_objekt
 IMPORTING
   ETAB_RESULT       = ltab_result
   ETAB_RETURN       = ltab_return
          .
  DATA lo_nd_versandarten TYPE REF TO if_wd_context_node.
  DATA lt_versandarten TYPE wd_this->Elements_versandarten.
  lo_nd_versandarten = wd_context->get_child_node( name = wd_this->wdctx_versandarten ).
  lo_nd_versandarten->BIND_TABLE(
    EXPORTING
      NEW_ITEMS            =  ltab_result   " Liste von Elementen oder Modeldaten
*      SET_INITIAL_ELEMENTS = ABAP_TRUE    " Falls TRUE setzen der initialen Elemente, sonst Anfügen
*      INDEX                =     " Index eines Kontext Elementes
  ).
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method INIT_VS_DRUCKORT_DDK .
DATA: LTAB_DRUCKORT TYPE ZVTT_DRUCKORT_ANSPRECHPARTNER.
  DATA lo_nd_e_str_object_init TYPE REF TO if_wd_context_node.
  DATA lo_el_e_str_object_init TYPE REF TO if_wd_context_element.
  DATA ls_e_str_object_init TYPE wd_this->Element_e_str_object_init.
  DATA: lv_objekt TYPE wd_this->Element_e_str_object_init-objekt,
        lv_lock type wdy_boolean.
* navigate from <CONTEXT> to <E_STR_OBJECT_INIT> via lead selection
  lo_nd_e_str_object_init = wd_context->path_get_node( path = `INIT_OBJ_VERSAND.EXPORTING_INIT.E_STR_OBJECT_INIT` ).
* get element via lead selection
  lo_el_e_str_object_init = lo_nd_e_str_object_init->get_element( ).
* get single attribute
  lo_el_e_str_object_init->get_attribute(
    EXPORTING
      name =  `OBJEKT`
    IMPORTING
      value = lv_objekt ).
  lv_lock = wd_this->GET_IS_LOCK( ).
  CALL FUNCTION 'ZV_OBJVERSAND_DRUCK_DDK_MAPI'
    EXPORTING
      I_OBJECT_ID       = LV_OBJEKT
      I_LOCK            = LV_LOCK
    IMPORTING
      E_TAB_DRUCKORT_ANSPRECHPARTNER   = LTAB_DRUCKORT
*      E_LOCK            = E_LOCK
.
  DATA lo_nd_druckort_anspr_ddk TYPE REF TO if_wd_context_node.
  DATA lo_el_druckort_anspr_ddk TYPE REF TO if_wd_context_element.
  DATA ls_druckort_anspr_ddk TYPE wd_this->Element_druckort_anspr_ddk.
  lo_nd_druckort_anspr_ddk = wd_context->get_child_node( name = wd_this->wdctx_druckort_anspr_ddk ).
  lo_el_druckort_anspr_ddk = lo_nd_druckort_anspr_ddk->get_element( ).
* set all declared attributes
  lo_nd_druckort_anspr_ddk->BIND_TABLE(
    EXPORTING
      NEW_ITEMS            =  LTAB_DRUCKORT " Liste von Elementen oder Modeldaten
  ).
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method INIT_VS_SPEDITION_DDK .
DATA: LTAB_SPEDITION TYPE ZVTT_SPEDITION_ANSPRECHPARTNER.
  DATA lo_nd_e_str_object_init TYPE REF TO if_wd_context_node.
  DATA lo_el_e_str_object_init TYPE REF TO if_wd_context_element.
  DATA ls_e_str_object_init TYPE wd_this->Element_e_str_object_init.
  DATA: lv_objekt TYPE wd_this->Element_e_str_object_init-objekt,
        lv_lock type wdy_boolean.
* navigate from <CONTEXT> to <E_STR_OBJECT_INIT> via lead selection
  lo_nd_e_str_object_init = wd_context->path_get_node( path = `INIT_OBJ_VERSAND.EXPORTING_INIT.E_STR_OBJECT_INIT` ).
* get element via lead selection
  lo_el_e_str_object_init = lo_nd_e_str_object_init->get_element( ).
* get single attribute
  lo_el_e_str_object_init->get_attribute(
    EXPORTING
      name =  `OBJEKT`
    IMPORTING
      value = lv_objekt ).
  lv_lock = wd_this->GET_IS_LOCK( ).
  CALL FUNCTION 'ZV_OBJVERSAND_SPDN_DDK_MAPI'
    EXPORTING
      I_OBJECT_ID       = LV_OBJEKT
      I_LOCK            = LV_LOCK
    IMPORTING
      E_TAB_SPEDITION_ANSP  = LTAB_SPEDITION
*      E_LOCK            = E_LOCK
.
  DATA lo_nd_spedition_anspr_ddk TYPE REF TO if_wd_context_node.
  DATA lo_el_spedition_anspr_ddk TYPE REF TO if_wd_context_element.
  DATA ls_spedition_anspr_ddk TYPE wd_this->Element_spedition_anspr_ddk.
  lo_nd_spedition_anspr_ddk = wd_context->get_child_node( name = wd_this->wdctx_spedition_anspr_ddk ).
  lo_el_spedition_anspr_ddk = lo_nd_spedition_anspr_ddk->get_element( ).
* set all declared attributes
  lo_nd_spedition_anspr_ddk->BIND_TABLE(
    EXPORTING
      NEW_ITEMS            =  LTAB_SPEDITION " Liste von Elementen oder Modeldaten
  ).
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method INIT_VS_VERSANDART_DDK .
DATA: LTAB_versandarten TYPE ZVTT_versandart.
  DATA lo_nd_e_str_object_init TYPE REF TO if_wd_context_node.
  DATA lo_el_e_str_object_init TYPE REF TO if_wd_context_element.
  DATA ls_e_str_object_init TYPE wd_this->Element_e_str_object_init.
  DATA: lv_objekt TYPE wd_this->Element_e_str_object_init-objekt,
        lv_lock type wdy_boolean.
* navigate from <CONTEXT> to <E_STR_OBJECT_INIT> via lead selection
  lo_nd_e_str_object_init = wd_context->path_get_node( path = `INIT_OBJ_VERSAND.EXPORTING_INIT.E_STR_OBJECT_INIT` ).
* get element via lead selection
  lo_el_e_str_object_init = lo_nd_e_str_object_init->get_element( ).
* get single attribute
  lo_el_e_str_object_init->get_attribute(
    EXPORTING
      name =  `OBJEKT`
    IMPORTING
      value = lv_objekt ).
  lv_lock = wd_this->GET_IS_LOCK( ).
  CALL FUNCTION 'ZV_OBJVERSAND_VERSART_DDK_MAPI'
    EXPORTING
      I_OBJECT_ID       = LV_OBJEKT
      I_LOCK            = LV_LOCK
    IMPORTING
      E_TAB_versandart   = LTAB_versandarten
*      E_LOCK            = E_LOCK
.
  DATA lo_nd_versandart_ddk TYPE REF TO if_wd_context_node.
  DATA lo_el_versandart_ddk TYPE REF TO if_wd_context_element.
  DATA ls_versandart_ddk TYPE wd_this->Element_versandart_ddk.
  lo_nd_versandart_ddk = wd_context->get_child_node( name = wd_this->wdctx_versandart_ddk ).
  lo_el_versandart_ddk = lo_nd_versandart_ddk->get_element( ).
* set all declared attributes
  lo_nd_versandart_ddk->BIND_TABLE(
    EXPORTING
      NEW_ITEMS            =  LTAB_versandarten " Liste von Elementen oder Modeldaten
  ).
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method WRITE_TRANSACTION_MSG .
*        get message manager
       DATA: l_current_controller TYPE REF TO if_wd_controller,
             l_message_manager    TYPE REF TO if_wd_message_manager.
       l_current_controller ?= wd_this->wd_get_api( ).
       CALL METHOD l_current_controller->get_message_manager
      RECEIVING
        message_manager = l_message_manager.
  CASE msg_type.
    WHEN 'ERROR'.
      l_message_manager->report_error_message( message_text = msg_text ).
    WHEN 'SUCCESS'.
      l_message_manager->report_success( message_text = msg_text ).
    WHEN 'WARNING'.
      l_message_manager->report_warning( message_text = msg_text ).
  ENDCASE.
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method SAVE_VERSAND .
  data: l_locked   type wdy_boolean,
        l_readonly type wdy_boolean.
  if wd_this->check_input_fields( ) eq abap_true.
data:
      l_object_id type zvde_objekt.
    l_object_id = wd_this->get_object_id( ).
    data:
      node_init_obj_versand                 type ref to if_wd_context_node,
      node_exporting_init                 type ref to if_wd_context_node,
      node_e_str_object_init              type ref to if_wd_context_node,
      elem_e_str_object_init              type ref to if_wd_context_element,
      stru_e_str_object_init              type if_componentcontroller=>element_e_str_object_init .
* navigate from <CONTEXT> to <INIT_OBJ_VERSAND> via lead selection
    node_init_obj_versand = wd_context->get_child_node( name = `INIT_OBJ_VERSAND` ).
* navigate from <INIT_OBJ_VERSAND> to <EXPORTING_INIT> via lead selection
    node_exporting_init = node_init_obj_versand->get_child_node( name = `EXPORTING_INIT` ).
* navigate from <EXPORTING_INIT> to <E_STR_OBJECT_INIT> via lead selection
    node_e_str_object_init = node_exporting_init->get_child_node( name = `E_STR_OBJECT_INIT` ).
* get element via lead selection
    elem_e_str_object_init = node_e_str_object_init->get_element(  ).
* get all declared attributes
    elem_e_str_object_init->get_static_attributes( IMPORTING static_attributes = stru_e_str_object_init ).
****
*
*      DATA lo_nd_object_repository TYPE REF TO if_wd_context_node.
*
*      DATA lo_el_object_repository TYPE REF TO if_wd_context_element.
*      DATA ls_object_repository TYPE wd_this->Element_object_repository.
*      DATA lv_object_id TYPE wd_this->Element_object_repository-object_id.
*
*      lo_nd_object_repository = wd_context->get_child_node( name = wd_this->wdctx_object_repository ).
*
*      lo_el_object_repository = lo_nd_object_repository->get_element( ).
*
*      lo_el_object_repository->get_attribute(
*        EXPORTING
*          name =  `OBJECT_ID`
*        IMPORTING
*          value = lv_object_id ).
*
*    ls_e_str_object_init-OBJEKT = lv_object_id.
*
****
    e_transaction_result = wd_this->sc_save_obj_versand(
      str_object = stru_e_str_object_init
    ).
    if e_transaction_result eq abap_true.
      if wd_this->get_transaction_modus( ) eq 1.
        l_locked = abap_true.
        l_readonly = abap_false.
*     SET THE TRANSACTION MODE NOW TO CHANGE (2) - BUT WE ARE STILL IN PROCESS_CREATE
        wd_this->set_transaction_mode( 2 ).
      else.
*     TRANSACTION MODE IS SET TO CHANGE - CHECK IF THE CREATE PROCESS IS STILL IN PROGRESS
        if wd_this->get_current_process( ) eq zcl_vis_properties=>process_create.
*       THE CREATE PROCESS IS STILL IN PROGRESS - KEEP THE OBJECT LOCKED AND THE FIELDS EDITABLE
          l_locked = abap_true.
          l_readonly = abap_false.
        else.
          l_readonly = abap_true.
          l_locked = abap_false.
        endif.
      endif.
      wd_this->reset_values_changed(  ).
      wd_this->set_is_lock( l_locked  ).
      wd_this->set_is_readonly( l_readonly ).
      wd_this->init( ).
      wd_this->write_transaction_msg( msg_type = 'SUCCESS' msg_text = 'Versand wurde erfolgreich gespeichert!' ).
    else.
      wd_this->write_transaction_msg( msg_type = 'ERROR' msg_text = 'Versand konnte nicht gespeichert werden!' ).
    endif.
  endif.
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method WDDOBEFOREACTION .
*  data lo_api_controller type ref to if_wd_view_controller.
*  data lo_action         type ref to if_wd_action.
*
*  lo_api_controller = wd_this->wd_get_api( ).
*  lo_action = lo_api_controller->get_current_action( ).
*  DATA(lo_ctxt) = lo_api_controller->GET_CONTEXT( ).
*  LO_CTXT->CONTROLLER->
*  me->WD_CONTEXT->GET_CONTEXT( ).
*
*  if lo_action is bound.
*    case lo_action->name.
*      when '...'.
*
*    endcase.
*  endif.
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
METHOD wddoinit .
ENDMETHOD.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method WDDOEXIT .
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method WDDOMODIFYVIEW .
  "KEMPF_S -> zu Beginn wird die aktive Tab festgestellt.
  "Es gibt zwei Buttons(NEW/DELETE), die abhängig von dem selektierten Tab handeln.
  DATA: lo_ts  TYPE REF TO CL_WD_TABSTRIP,
        lo_tbl TYPE REF TO CL_WD_TABLE.
  IF FIRST_TIME = ABAP_TRUE.
     DATA(lo_el) = view->GET_ELEMENT( ID = 'TS_TRANSPORT_COST' ).
     IF lo_el IS BOUND AND lo_el IS INSTANCE OF CL_WD_TABSTRIP.
       "BREAK-POINT.
       lo_ts ?= lo_el.
       lo_ts->GET_SELECTED_TAB(
*       exporting
*         CONTEXT_ELEMENT        = CONTEXT_ELEMENT
*         CONTEXT_NODE_PATH_NAME = CONTEXT_NODE_PATH_NAME
       receiving
         VALUE                  = me->WD_THIS->MV_TCOST_ACTIVE_TAB
     ).
   ENDIF.
  ENDIF.
  lo_el = view->GET_ELEMENT( ID = 'TS_TRANSPORT_COST' ).
    IF lo_el IS BOUND AND lo_el IS INSTANCE OF CL_WD_TABLE.
        "BREAK-POINT.
        lo_tbl ?= lo_el.
        lo_tbl->set_read_only( ABAP_FALSE
      ).
    ENDIF.
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method WDDOAFTERACTION .
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method WDDOONCONTEXTMENU .
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method ONACTIONADD_DRUCKORT .
WD_COMP_CONTROLLER->ADD_DRUCKORT( ).
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method ONACTIONADD_SPEDITION .
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method ONACTIONADD_VERSANDART .
  WD_COMP_CONTROLLER->ADD_VERSANDART( ).
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method ONACTIONDELETE_DRUCKORT .
  DATA lo_nd_druck_ansprechprtnr TYPE REF TO if_wd_context_node.
  DATA lo_el_druck_ansprechprtnr TYPE REF TO if_wd_context_element.
  DATA ls_druck_ansprechprtnr TYPE wd_this->Element_druck_ansprechprtnr.
  lo_nd_druck_ansprechprtnr = wd_context->get_child_node( name = wd_this->wdctx_druck_ansprechprtnr ).
  lo_nd_druck_ansprechprtnr = wd_context->path_get_node( path = `DRUCK_ANSPRECHPRTNR` ).
  CONTEXT_ELEMENT->get_static_attributes(
    IMPORTING
      static_attributes = ls_druck_ansprechprtnr ).
* Prüfen, ob einziger Druckort
  DATA lt_druck_ansprechprtnr TYPE wd_this->ELEMENTS_DRUCK_ANSPRECHPRTNR.
  lo_nd_druck_ansprechprtnr = wd_context->get_child_node( name = wd_this->wdctx_druck_ansprechprtnr ).
  lo_nd_druck_ansprechprtnr->get_static_attributes_table( importing table = lt_druck_ansprechprtnr ).
  DATA lv_len_druck_ansprechprtnr TYPE i.
  lv_len_druck_ansprechprtnr = lines( lt_druck_ansprechprtnr ).
  if lv_len_druck_ansprechprtnr EQ 1 or lv_len_druck_ansprechprtnr < 1.
    wd_comp_controller->write_validation_error_msg(
  attribute = 'DRUCK_ANSPRECHPRTNR'
  element = context_element
  message = 'Objekt benötigt mindestens einen Druckort.'
).
  else.
*
*   Action Flag setzen
*
    DATA lv_action TYPE ZVDE_ACTION.
    lv_action = LS_DRUCK_ANSPRECHPRTNR-action.
    if lv_action is initial.
      LS_DRUCK_ANSPRECHPRTNR-action = '3'. " Delete
    else.
      clear lv_action.
    endif.
*
*   Element aus Tabelle entfernen
*
    LO_nd_druck_ansprechprtnr->REMOVE_ELEMENT( CONTEXT_ELEMENT ).
*
*   Werte für DDK erneuern
*
    DATA lo_nd_druckort_anspr_ddk TYPE REF TO if_wd_context_node.
    DATA lt_druckort_anspr_ddk TYPE wd_this->Elements_druckort_anspr_ddk.
    lo_nd_druckort_anspr_ddk = wd_context->get_child_node( name = wd_this->wdctx_druckort_anspr_ddk ).
    lo_nd_druckort_anspr_ddk->get_static_attributes_table( importing table = lt_druckort_anspr_ddk ).
    LO_ND_druck_ansprechprtnr = WD_CONTEXT->GET_CHILD_NODE( name = wd_this->WDCTX_DRUCK_ANSPRECHPRTNR ).
    lo_nd_druckort_anspr_ddk = wd_context->get_child_node( name = wd_this->wdctx_druckort_anspr_ddk ).
    lo_nd_druckort_anspr_ddk->get_static_attributes_table( importing table = lt_druckort_anspr_ddk ).
    APPEND LS_DRUCK_ANSPRECHPRTNR TO lt_druckort_anspr_ddk.
    SORT LT_DRUCKORT_ANSPR_DDK ASCENDING.
    " Tabelle neu binden
    lo_nd_druckort_anspr_ddk = wd_context->get_child_node( name = wd_this->wdctx_druckort_anspr_ddk ).
    lo_nd_druckort_anspr_ddk->bind_table( new_items = lt_druckort_anspr_ddk set_initial_elements = abap_true ).
    " Werte für DDK neu laden
    WD_COMP_CONTROLLER->FILL_VS_DRUCKORT_DDK( ).
  endif.
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method ONACTIONDELETE_VERSANDART .
  DATA lo_nd_versandart TYPE REF TO if_wd_context_node.
  DATA lo_el_versandart TYPE REF TO if_wd_context_element.
  DATA ls_versandart TYPE wd_this->Element_versandarten.
  lo_nd_versandart = wd_context->get_child_node( name = wd_this->wdctx_versandarten ).
  lo_nd_versandart = wd_context->path_get_node( path = `VERSANDARTEN` ).
  CONTEXT_ELEMENT->get_static_attributes(
    IMPORTING
      static_attributes = ls_versandart ).
* Prüfen, ob einzige Versandart
  DATA lo_nd_versandarten TYPE REF TO if_wd_context_node.
  DATA lt_versandarten TYPE wd_this->Elements_versandarten.
  lo_nd_versandarten = wd_context->get_child_node( name = wd_this->wdctx_versandarten ).
  lo_nd_versandarten->get_static_attributes_table( importing table = lt_versandarten ).
  DATA lv_len_versandarten TYPE i.
  lv_len_versandarten = lines( lt_versandarten ).
  if lv_len_versandarten EQ 1 or lv_len_versandarten < 1.
        wd_comp_controller->write_validation_error_msg(
      attribute = 'VERSANDARTEN'
      element = context_element
      message = 'Objekt benötigt mindestens eine Versandart.'
    ).
else.
*
*   Action Flag setzen
*
  DATA lv_action TYPE ZVDE_ACTION.
  lv_action = LS_versandart-action.
  if lv_action is initial.
    LS_versandart-action = '3'. " Delete
  else.
    clear lv_action.
  endif.
*
*   Element aus Tabelle entfernen
*
  LO_nd_versandart->REMOVE_ELEMENT( CONTEXT_ELEMENT ).
*
*   Werte für DDK erneuern
*
  DATA lo_nd_versandart_ddk TYPE REF TO if_wd_context_node.
  DATA lt_versandart_ddk TYPE wd_this->Elements_versandart_ddk.
  lo_nd_versandart_ddk = wd_context->get_child_node( name = wd_this->wdctx_versandart_ddk ).
  lo_nd_versandart_ddk->get_static_attributes_table( importing table = lt_versandart_ddk ).
  LO_ND_versandart = WD_CONTEXT->GET_CHILD_NODE( name = wd_this->WDCTX_versandarten ).
  lo_nd_versandart_ddk = wd_context->get_child_node( name = wd_this->wdctx_versandart_ddk ).
  lo_nd_versandart_ddk->get_static_attributes_table( importing table = lt_versandart_ddk ).
  APPEND LS_versandart TO lt_versandart_ddk.
  SORT LT_versandart_DDK ASCENDING.
  " Tabelle neu binden
  lo_nd_versandart_ddk = wd_context->get_child_node( name = wd_this->wdctx_versandart_ddk ).
  lo_nd_versandart_ddk->bind_table( new_items = lt_versandart_ddk set_initial_elements = abap_true ).
  " Werte für DDK neu laden
  WD_COMP_CONTROLLER->FILL_VS_versandart_DDK( ).
endif.
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method ONACTIONREFRESH_DRUCK_NAME .
*  DATA lo_MD_POPUP_OBJEKTBEZ TYPE REF TO IG_MD_POPUP_OBJEKTBEZ .
*  lo_MD_POPUP_OBJEKTBEZ =   wd_this->get_md_popup_objektbez_ctr( ).
*  lo_md_popup_objektbez->refresh_valuesets( ).
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method ONACTIONSET_SPEDITION .
WD_COMP_CONTROLLER->ADD_SPEDITION( ).
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method onactionopen_add_druckort .
  data: context_node type ref to if_wd_context_node.
  data: lr_popup type ref to if_wd_window,
        lr_view_controller type ref to if_wd_view_controller.
  data: lr_api_comp_controller type ref to if_wd_component,
        lr_window_manager type ref to if_wd_window_manager.
  lr_api_comp_controller = wd_comp_controller->wd_get_api( ).
  lr_window_manager = lr_api_comp_controller->get_window_manager( ).
  lr_popup = lr_window_manager->create_window(
  modal               = abap_true
  window_name         = 'POPUP_DRUCKORT_WINDO'  "Name of the window created in step 2
  title               = 'Druckort hinzufügen'
  close_button        = abap_true
  button_kind         = if_wd_window=>co_buttons_none
  message_type        = if_wd_window=>co_msg_type_none
  close_in_any_case   = abap_true
*MESSAGE_DISPLAY_MODE = MESSAGE_DISPLAY_MODE
  ).
* set window parameters
  lr_popup->set_window_size( width = '600' height = '400' ).
  lr_popup->set_window_position( position = if_wd_window=>co_center ).
* Adds an action to the popup screen buttons
* lr_view_controller = wd_this->wd_get_api( ).
* lr_popup->subscribe_to_button_event(
* button = if_wd_window=>co_button_ok
* button_text = 'Yes'
* action_name = 'SUBMIT'
* action_view = lr_view_controller ).
  lr_popup->open( ).
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method onactionopen_set_spedition .
  data: context_node type ref to if_wd_context_node.
  data: lr_popup type ref to if_wd_window,
        lr_view_controller type ref to if_wd_view_controller.
  data: lr_api_comp_controller type ref to if_wd_component,
        lr_window_manager type ref to if_wd_window_manager.
  lr_api_comp_controller = wd_comp_controller->wd_get_api( ).
  lr_window_manager = lr_api_comp_controller->get_window_manager( ).
  lr_popup = lr_window_manager->create_window(
  modal               = abap_true
  window_name         = 'POPUP_SPED_WINDOW'  "Name of the window created in step 2
  title               = 'Spedition setzen'
  close_button        = abap_true
  button_kind         = if_wd_window=>co_buttons_none
  message_type        = if_wd_window=>co_msg_type_none
  close_in_any_case   = abap_true
*MESSAGE_DISPLAY_MODE = MESSAGE_DISPLAY_MODE
  ).
* set window parameters
  lr_popup->set_window_size( width = '600' height = '400' ).
  lr_popup->set_window_position( position = if_wd_window=>co_center ).
* Adds an action to the popup screen buttons
* lr_view_controller = wd_this->wd_get_api( ).
* lr_popup->subscribe_to_button_event(
* button = if_wd_window=>co_button_ok
* button_text = 'Yes'
* action_name = 'SUBMIT'
* action_view = lr_view_controller ).
  lr_popup->open( ).
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
METHOD onactionrb_sortenbez_change .
  DATA lo_el_sortenbez TYPE REF TO if_wd_context_element.
  DATA ls_sortenbez TYPE wd_this->element_sortenbez.
  DATA lv_sortenbez TYPE wd_this->element_sortenbez-sortenbez.
  DATA lo_el_e_str_object_init TYPE REF TO if_wd_context_element.
  DATA ls_e_str_object_init TYPE wd_this->element_e_str_object_init.
  DATA lv_vs_sortenbez_fill TYPE wd_this->element_e_str_object_init-vs_sortenbez_fill.
  DATA lv_vs_sortenbez_num TYPE wd_this->element_e_str_object_init-vs_sortenbez_num.
  lo_el_sortenbez =  wd_context->path_get_node( path = `RADIOBUTTONS.SORTENBEZ` )->get_element( ).
  lo_el_e_str_object_init = wd_context->path_get_node( path = `INIT_OBJ_VERSAND.EXPORTING_INIT.E_STR_OBJECT_INIT` )->get_element( ).
  lo_el_sortenbez->get_attribute(
    EXPORTING
      name =  `SORTENBEZ`
    IMPORTING
      value = lv_sortenbez ).
  lv_vs_sortenbez_num = ''.
  lv_vs_sortenbez_fill = ''.
  IF ( lv_sortenbez EQ 'Sortenbezeichnung numerisch' ).
    lv_vs_sortenbez_num = 'X'.
  ENDIF.
  IF ( lv_sortenbez EQ 'Sortenbezeichnung beginnt mit ---A' ).
    lv_vs_sortenbez_fill = 'X'.
  ENDIF.
  lo_el_e_str_object_init->set_attribute(
    name =  `VS_SORTENBEZ_FILL`
    value = lv_vs_sortenbez_fill ).
  lo_el_e_str_object_init->set_attribute(
    name =  `VS_SORTENBEZ_NUM`
    value = lv_vs_sortenbez_num ).
ENDMETHOD.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method WDDOEXIT .
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method WDDOEXIT .
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method WDDOEXIT .
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method WDDOEXIT .
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method WDDOEXIT .
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method WDDOEXIT .
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method WDDOEXIT .
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method WDDOEXIT .
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method WDDOEXIT .
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method WDDOINIT .
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method WDDOINIT .
  wd_this->init_view( ).
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method WDDOINIT .
  wd_this->init_view( ).
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method WDDOINIT .
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method WDDOINIT .
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method WDDOINIT .
  wd_this->INIT_VIEW( ).
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method WDDOINIT .
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method WDDOINIT .
  wd_this->INIT_VIEW( ).
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method WDDOINIT .
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method WDDOMODIFYVIEW .
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method WDDOMODIFYVIEW .
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method WDDOMODIFYVIEW .
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method WDDOMODIFYVIEW .
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method WDDOBEFOREACTION .
*  data lo_api_controller type ref to if_wd_view_controller.
*  data lo_action         type ref to if_wd_action.
*  lo_api_controller = wd_this->wd_get_api( ).
*  lo_action = lo_api_controller->get_current_action( ).
*  if lo_action is bound.
*    case lo_action->name.
*      when '...'.
*    endcase.
*  endif.
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method WDDOBEFOREACTION .
*  data lo_api_controller type ref to if_wd_view_controller.
*  data lo_action         type ref to if_wd_action.
*  lo_api_controller = wd_this->wd_get_api( ).
*  lo_action = lo_api_controller->get_current_action( ).
*  if lo_action is bound.
*    case lo_action->name.
*      when '...'.
*    endcase.
*  endif.
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method WDDOBEFOREACTION .
*  data lo_api_controller type ref to if_wd_view_controller.
*  data lo_action         type ref to if_wd_action.
*  lo_api_controller = wd_this->wd_get_api( ).
*  lo_action = lo_api_controller->get_current_action( ).
*  if lo_action is bound.
*    case lo_action->name.
*      when '...'.
*    endcase.
*  endif.
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method WDDOBEFOREACTION .
*  data lo_api_controller type ref to if_wd_view_controller.
*  data lo_action         type ref to if_wd_action.
*  lo_api_controller = wd_this->wd_get_api( ).
*  lo_action = lo_api_controller->get_current_action( ).
*  if lo_action is bound.
*    case lo_action->name.
*      when '...'.
*    endcase.
*  endif.
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method WDDOAFTERACTION .
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method WDDOAFTERACTION .
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method WDDOAFTERACTION .
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method WDDOAFTERACTION .
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method WDDOONCONTEXTMENU .
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method WDDOONCONTEXTMENU .
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method WDDOONCONTEXTMENU .
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method WDDOONCONTEXTMENU .
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method WDDOONCLOSE .
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method WDDOONCLOSE .
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method WDDOONCLOSE .
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method WDDOONCLOSE .
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method WDDOONCLOSE .
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method WDDOONOPEN .
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method WDDOONOPEN .
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method WDDOONOPEN .
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method WDDOONOPEN .
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method WDDOONOPEN .
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method CHECK_ANSP_EXIST .
  E_ANSP_EXIST = 'X'.
  DATA lo_nd_druckort_ergebnis TYPE REF TO if_wd_context_node.
  DATA lt_druckort_ergebnis TYPE wd_this->Elements_druckort_ergebnis.
  lo_nd_druckort_ergebnis = wd_context->get_child_node( name = wd_this->wdctx_druckort_ergebnis ).
  lo_nd_druckort_ergebnis->get_static_attributes_table( importing table = lt_druckort_ergebnis ).
  DATA ls_druckort_ergebnis TYPE ZVST_DRUCKORT_ANSPRECHPARTNER.
  loop at LT_DRUCKORT_ERGEBNIS into LS_DRUCKORT_ERGEBNIS.
    if LS_DRUCKORT_ERGEBNIS-SELECTED EQ 'X'
      AND LS_DRUCKORT_ERGEBNIS-ANSPRECHPARTNER_ID is initial.
      E_ANSP_EXIST = ''.
    endif.
  endloop.
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method check_user_input_something .
  DATA lo_nd_druckort_suche TYPE REF TO if_wd_context_node.
  DATA lo_el_druckort_suche TYPE REF TO if_wd_context_element.
  DATA ls_druckort_suche TYPE wd_this->Element_druckort_suche.
  lo_nd_druckort_suche = wd_context->get_child_node( name = wd_this->wdctx_druckort_suche ).
  lo_el_druckort_suche = lo_nd_druckort_suche->get_element( ).
* get all declared attributes
  lo_el_druckort_suche->get_static_attributes(
    IMPORTING
      static_attributes = ls_druckort_suche ).
  if LS_DRUCKORT_SUCHE-DRUCKORT_NR is not initial or
     LS_DRUCKORT_SUCHE-DRUCKORT_NAME is not initial or
     LS_DRUCKORT_SUCHE-DRUCKORT_ORT is not initial.
    e_user_input_something = 'X'.
  else.
    e_user_input_something = ''.
  endif.
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method GET_NUM_OF_SELECTIONS .
  num_of_selections = 0.
  DATA lo_nd_druckort_ergebnis TYPE REF TO if_wd_context_node.
  DATA lt_druckort_ergebnis TYPE wd_this->Elements_druckort_ergebnis.
  lo_nd_druckort_ergebnis = wd_context->get_child_node( name = wd_this->wdctx_druckort_ergebnis ).
  lo_nd_druckort_ergebnis->get_static_attributes_table( importing table = lt_druckort_ergebnis ).
  DATA ls_druckort_ergebnis TYPE ZVST_DRUCKORT_ANSPRECHPARTNER.
  loop at LT_druckort_ERGEBNIS into LS_druckort_ERGEBNIS.
    if LS_druckort_ERGEBNIS-SELECTED EQ 'X'.
      "AND LS_druckort_ERGEBNIS-ANSPRECHPARTNER_ID is initial.
      num_of_selections = num_of_selections + 1.
    endif.
  endloop.
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method INIT_VIEW .
  " Suche lesen
  DATA lo_nd_druckort_suche TYPE REF TO if_wd_context_node.
  DATA lo_el_druckort_suche TYPE REF TO if_wd_context_element.
  DATA ls_druckort_suche TYPE wd_this->Element_druckort_suche.
  lo_nd_druckort_suche = wd_context->get_child_node( name = wd_this->wdctx_druckort_suche ).
  lo_el_druckort_suche = lo_nd_druckort_suche->get_element( ).
  " Suche leeren
  lo_el_druckort_suche->get_static_attributes(
    IMPORTING
      static_attributes = ls_druckort_suche ).
  CLEAR LS_druckort_SUCHE.
  lo_el_druckort_suche->set_static_attributes(
     static_attributes = ls_druckort_suche ).
  " Tabelle lesen
  DATA lo_nd_druckort_ergebnis TYPE REF TO if_wd_context_node.
  DATA lt_druckort_ergebnis TYPE wd_this->Elements_druckort_ergebnis.
  lo_nd_druckort_ergebnis = wd_context->get_child_node( name = wd_this->wdctx_druckort_ergebnis ).
  lo_nd_druckort_ergebnis->get_static_attributes_table( importing table = lt_druckort_ergebnis ).
  " Tabelle leeren
  CLEAR LT_DRUCKORT_ERGEBNIS.
  lo_nd_druckort_ergebnis->bind_table( new_items = lt_druckort_ergebnis set_initial_elements = abap_true ).
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method sc_search_druckerei .
  DATA ITAB_F_E_TAB_RETURN_SEARCH TYPE ZVTT_RETURN.
  DATA ITAB_F_E_TAB_druckereien TYPE ZVTT_DRUCKORT.
  DATA lo_nd_druckort_suche TYPE REF TO if_wd_context_node.
  DATA lo_el_druckort_suche TYPE REF TO if_wd_context_element.
  DATA ls_druckort_suche TYPE wd_this->Element_druckort_suche.
  DATA lv_druckort_nr TYPE wd_this->Element_druckort_suche-druckort_nr.
  lo_nd_druckort_suche = wd_context->get_child_node( name = wd_this->wdctx_druckort_suche ).
  lo_el_druckort_suche = lo_nd_druckort_suche->get_element( ).
* get single attribute
  lo_el_druckort_suche->get_attribute(
    EXPORTING
      name =  `DRUCKORT_NR`
    IMPORTING
      value = lv_druckort_nr ).
  DATA lv_druckort_name TYPE wd_this->Element_druckort_suche-druckort_name.
  lo_nd_druckort_suche = wd_context->get_child_node( name = wd_this->wdctx_druckort_suche ).
  lo_el_druckort_suche = lo_nd_druckort_suche->get_element( ).
*   get single attribute
  lo_el_druckort_suche->get_attribute(
    EXPORTING
      name =  `DRUCKORT_NAME`
    IMPORTING
      value = lv_druckort_name ).
  DATA lv_druckort_ort TYPE wd_this->Element_druckort_suche-druckort_ort.
  lo_nd_druckort_suche = wd_context->get_child_node( name = wd_this->wdctx_druckort_suche ).
  lo_el_druckort_suche = lo_nd_druckort_suche->get_element( ).
*     get single attribute
  lo_el_druckort_suche->get_attribute(
    EXPORTING
      name =  `DRUCKORT_ORT`
    IMPORTING
      value = lv_druckort_ort ).
* the invocation - errors are always fatal !!!
  CALL FUNCTION 'Z_V_SEARCH_DRUCKEREIEN_MAPI'
    EXPORTING
      I_DRUCKEREI       = LV_DRUCKORT_NR
      I_NAME1           = LV_DRUCKORT_NAME
      I_ORT1            = LV_DRUCKORT_ORT
    IMPORTING
      E_TAB_RETURN      = ITAB_F_E_TAB_RETURN_SEARCH
      E_TAB_DRUCKEREIEN = ITAB_F_E_TAB_druckereien.
*
*   Ergebnisse in Tabelle setzen
*
  DATA lo_nd_druckort_ergebnis TYPE REF TO if_wd_context_node.
  DATA lt_druckort_ergebnis TYPE wd_this->Elements_druckort_ergebnis.
  DATA ls_druckort TYPE ZVST_DRUCKORT.
  DATA ls_druckort_ergebnis TYPE ZVST_DRUCKORT_ANSPRECHPARTNER.
  loop at ITAB_F_E_TAB_druckereien into LS_DRUCKORT.
    LS_druckort_ergebnis-DRUCKORT_NR = LS_DRUCKORT-DRUCKORT_NR.
    LS_druckort_ergebnis-DRUCKORT_NAME  = LS_DRUCKORT-ZZNAME1.
    LS_druckort_ergebnis-DRUCKORT_ORT = LS_DRUCKORT-ZZORT1.
    if LS_DRUCKORT_ERGEBNIS-ANSPRECHPARTNER_NAME is initial.
      LS_DRUCKORT_ERGEBNIS-ANSPRECHPARTNER_NAME = 'Ansprechpartner wählen'.
    endif.
    append LS_druckort_ergebnis to LT_druckort_ergebnis.
    clear LS_druckort_ergebnis.
  endloop.
  lo_nd_druckort_ergebnis = wd_context->get_child_node( name = wd_this->wdctx_druckort_ergebnis ).
  lo_nd_druckort_ergebnis->bind_table( new_items = lt_druckort_ergebnis set_initial_elements = abap_true ).
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method CHECK_ANSP_EXIST .
  E_ANSP_EXIST = 'X'.
  DATA lo_nd_spedition_ergebnis TYPE REF TO if_wd_context_node.
  DATA lt_spedition_ergebnis TYPE wd_this->Elements_spedition_ergebnis.
  lo_nd_spedition_ergebnis = wd_context->get_child_node( name = wd_this->wdctx_spedition_ergebnis ).
  lo_nd_spedition_ergebnis->get_static_attributes_table( importing table = lt_spedition_ergebnis ).
  DATA ls_spedition_ergebnis TYPE ZVST_versand_spedition.
  loop at LT_spedition_ERGEBNIS into LS_spedition_ERGEBNIS.
    if LS_spedition_ERGEBNIS-SELECTED EQ 'X'
      AND LS_spedition_ERGEBNIS-ANSPRECHPARTNER_ID is initial.
      E_ANSP_EXIST = ''.
    endif.
  endloop.
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method check_user_input_something .
  DATA lo_nd_spedition_suche TYPE REF TO if_wd_context_node.
  DATA lo_el_spedition_suche TYPE REF TO if_wd_context_element.
  DATA ls_spedition_suche TYPE wd_this->Element_spedition_suche.
  lo_nd_spedition_suche = wd_context->get_child_node( name = wd_this->wdctx_spedition_suche ).
  lo_el_spedition_suche = lo_nd_spedition_suche->get_element( ).
* get all declared attributes
  lo_el_spedition_suche->get_static_attributes(
    IMPORTING
      static_attributes = ls_spedition_suche ).
  if LS_spedition_SUCHE-spedition_NR is not initial or
     LS_spedition_SUCHE-spedition_NAME is not initial or
     LS_spedition_SUCHE-spedition_ORT is not initial.
    e_user_input_something = 'X'.
  else.
    e_user_input_something = ''.
  endif.
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method GET_NUM_OF_SELECTIONS .
  num_of_selections = 0.
  DATA lo_nd_spedition_ergebnis TYPE REF TO if_wd_context_node.
  DATA lt_spedition_ergebnis TYPE wd_this->Elements_spedition_ergebnis.
  lo_nd_spedition_ergebnis = wd_context->get_child_node( name = wd_this->wdctx_spedition_ergebnis ).
  lo_nd_spedition_ergebnis->get_static_attributes_table( importing table = lt_spedition_ergebnis ).
  DATA ls_spedition_ergebnis TYPE ZVST_versand_spedition.
  loop at LT_spedition_ERGEBNIS into LS_spedition_ERGEBNIS.
    if LS_spedition_ERGEBNIS-SELECTED EQ 'X'.
      "AND LS_spedition_ERGEBNIS-ANSPRECHPARTNER_ID is initial.
      num_of_selections = num_of_selections + 1.
    endif.
  endloop.
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method INIT_VIEW .
  " Suche lesen
  DATA lo_nd_spedition_suche TYPE REF TO if_wd_context_node.
  DATA lo_el_spedition_suche TYPE REF TO if_wd_context_element.
  DATA ls_spedition_suche TYPE wd_this->Element_spedition_suche.
  lo_nd_spedition_suche = wd_context->get_child_node( name = wd_this->wdctx_spedition_suche ).
  lo_el_spedition_suche = lo_nd_spedition_suche->get_element( ).
  " Suche leeren
  lo_el_spedition_suche->get_static_attributes(
    IMPORTING
      static_attributes = ls_spedition_suche ).
  CLEAR LS_spedition_SUCHE.
  lo_el_spedition_suche->set_static_attributes(
     static_attributes = ls_spedition_suche ).
  " Tabelle lesen
  DATA lo_nd_spedition_ergebnis TYPE REF TO if_wd_context_node.
  DATA lt_spedition_ergebnis TYPE wd_this->Elements_spedition_ergebnis.
  lo_nd_spedition_ergebnis = wd_context->get_child_node( name = wd_this->wdctx_spedition_ergebnis ).
  lo_nd_spedition_ergebnis->get_static_attributes_table( importing table = lt_spedition_ergebnis ).
  " Tabelle leeren
  CLEAR LT_spedition_ERGEBNIS.
  lo_nd_spedition_ergebnis->bind_table( new_items = lt_spedition_ergebnis set_initial_elements = abap_true ).
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method SC_SEARCH_SPEDITION.
  DATA ITAB_F_E_TAB_RETURN_SEARCH TYPE ZVTT_RETURN.
  DATA ITAB_F_E_TAB_spedition TYPE ZVTT_spedition.
  DATA lo_nd_spedition_suche TYPE REF TO if_wd_context_node.
  DATA lo_el_spedition_suche TYPE REF TO if_wd_context_element.
  DATA ls_spedition_suche TYPE wd_this->Element_spedition_suche.
  DATA lv_spedition_nr TYPE wd_this->Element_spedition_suche-spedition_nr.
  lo_nd_spedition_suche = wd_context->get_child_node( name = wd_this->wdctx_spedition_suche ).
  lo_el_spedition_suche = lo_nd_spedition_suche->get_element( ).
* get single attribute
  lo_el_spedition_suche->get_attribute(
    EXPORTING
      name =  `SPEDITION_NR`
    IMPORTING
      value = lv_spedition_nr ).
  DATA lv_spedition_name TYPE wd_this->Element_spedition_suche-spedition_name.
  lo_nd_spedition_suche = wd_context->get_child_node( name = wd_this->wdctx_spedition_suche ).
  lo_el_spedition_suche = lo_nd_spedition_suche->get_element( ).
*   get single attribute
  lo_el_spedition_suche->get_attribute(
    EXPORTING
      name =  `SPEDITION_NAME`
    IMPORTING
      value = lv_spedition_name ).
  DATA lv_spedition_ort TYPE wd_this->Element_spedition_suche-spedition_ort.
  lo_nd_spedition_suche = wd_context->get_child_node( name = wd_this->wdctx_spedition_suche ).
  lo_el_spedition_suche = lo_nd_spedition_suche->get_element( ).
*     get single attribute
  lo_el_spedition_suche->get_attribute(
    EXPORTING
      name =  `SPEDITION_ORT`
    IMPORTING
      value = lv_spedition_ort ).
* the invocation - errors are always fatal !!!
  CALL FUNCTION 'Z_V_SEARCH_SPEDITIONEN_MAPI'
    EXPORTING
      I_SPEDITION       = LV_spedition_NR
      I_SPEDITION_BEZ   = LV_spedition_NAME
      I_ORT1            = LV_spedition_ORT
    IMPORTING
      E_TAB_RETURN      = ITAB_F_E_TAB_RETURN_SEARCH
      E_TAB_speditionen = ITAB_F_E_TAB_spedition.
*
*   Ergebnisse in Tabelle setzen
*
  DATA lo_nd_spedition_ergebnis TYPE REF TO if_wd_context_node.
  DATA lt_spedition_ergebnis TYPE wd_this->Elements_spedition_ergebnis.
  DATA ls_spedition TYPE ZVST_spedition.
  DATA ls_spedition_ergebnis TYPE ZVST_versand_spedition.
  loop at ITAB_F_E_TAB_spedition into LS_spedition.
    LS_spedition_ergebnis-spedition_NR = LS_spedition-spedition.
    LS_spedition_ergebnis-spedition_NAME  = LS_spedition-SPEDITION_BEZ.
    LS_spedition_ergebnis-spedition_ORT = LS_spedition-ORT1.
    if LS_spedition_ERGEBNIS-ANSPRECHPARTNER_NAME is initial.
      LS_spedition_ERGEBNIS-ANSPRECHPARTNER_NAME = 'Ansprechpartner wählen'.
    endif.
    append LS_spedition_ergebnis to LT_spedition_ergebnis.
    clear LS_spedition_ergebnis.
  endloop.
  lo_nd_spedition_ergebnis = wd_context->get_child_node( name = wd_this->wdctx_spedition_ergebnis ).
  lo_nd_spedition_ergebnis->bind_table( new_items = lt_spedition_ergebnis set_initial_elements = abap_true ).
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method INIT_VIEW .
*
*   Druckort Nr aus Kontext lesen
*
  DATA lo_nd_druck_ansp_suche TYPE REF TO if_wd_context_node.
  DATA lo_el_druck_ansp_suche TYPE REF TO if_wd_context_element.
  DATA ls_druck_ansp_suche TYPE wd_this->Element_druck_ansp_suche.
  DATA lv_druckort_nr TYPE wd_this->Element_druck_ansp_suche-druckort_nr.
  lo_nd_druck_ansp_suche = wd_context->get_child_node( name = wd_this->wdctx_druck_ansp_suche ).
  lo_el_druck_ansp_suche = lo_nd_druck_ansp_suche->get_element( ).
  lo_el_druck_ansp_suche->get_attribute(
    EXPORTING
      name =  `DRUCKORT_NR`
    IMPORTING
      value = lv_druckort_nr ).
*
*   Tabelle Ansprechpartner zum Druckort befüllen
*
  DATA lt_ansprechpartner TYPE ZVTT_ANSPRECHPARTNER.
  DATA lv_eltern_id TYPE ZVDE_ELTERN_ID.
  lv_eltern_id = lv_druckort_nr.
    CALL FUNCTION 'ZV_GET_ANSPRECHPARTNER_MAPI'
      EXPORTING
        IV_ELTERN_ID = lv_eltern_id
        IV_ART       = 'DR'
      IMPORTING
        ETAB_RESULT  = lt_ansprechpartner
*       ETAB_RETURN  =
      .
  DATA lo_nd_ansprechpartner_tbl TYPE REF TO if_wd_context_node.
  DATA lt_ansprechpartner_tbl TYPE wd_this->Elements_ansprechpartner_tbl.
  lo_nd_ansprechpartner_tbl = wd_context->get_child_node( name = wd_this->wdctx_ansprechpartner_tbl ).
  lt_ansprechpartner_tbl = lt_ansprechpartner.
  lo_nd_ansprechpartner_tbl->bind_table( new_items = lt_ansprechpartner_tbl set_initial_elements = abap_true ).
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method INIT_VIEW .
*
*   spedition Nr aus Kontext lesen
*
  DATA lo_nd_sped_ansp_suche TYPE REF TO if_wd_context_node.
  DATA lo_el_sped_ansp_suche TYPE REF TO if_wd_context_element.
  DATA ls_sped_ansp_suche TYPE wd_this->Element_sped_ansp_suche.
  DATA lv_spedition_nr TYPE wd_this->Element_sped_ansp_suche-spedition.
  lo_nd_sped_ansp_suche = wd_context->get_child_node( name = wd_this->wdctx_sped_ansp_suche ).
  lo_el_sped_ansp_suche = lo_nd_sped_ansp_suche->get_element( ).
  lo_el_sped_ansp_suche->get_attribute(
    EXPORTING
      name =  `SPEDITION`
    IMPORTING
      value = lv_spedition_nr ).
*
*   Tabelle Ansprechpartner zum spedition befüllen
*
  DATA lt_ansprechpartner TYPE ZVTT_ANSPRECHPARTNER.
  DATA lv_eltern_id TYPE ZVDE_ELTERN_ID.
  lv_eltern_id = lv_spedition_nr.
    CALL FUNCTION 'ZV_GET_ANSPRECHPARTNER_MAPI'
      EXPORTING
        IV_ELTERN_ID = lv_eltern_id
        IV_ART       = 'SP'
      IMPORTING
        ETAB_RESULT  = lt_ansprechpartner
*       ETAB_RETURN  =
      .
  DATA lo_nd_ansprechpartner_tbl TYPE REF TO if_wd_context_node.
  DATA lt_ansprechpartner_tbl TYPE wd_this->Elements_ansprechpartner_tbl.
  lo_nd_ansprechpartner_tbl = wd_context->get_child_node( name = wd_this->wdctx_ansprechpartner_tbl ).
  lt_ansprechpartner_tbl = lt_ansprechpartner.
  lo_nd_ansprechpartner_tbl->bind_table( new_items = lt_ansprechpartner_tbl set_initial_elements = abap_true ).
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method HANDLEDEFAULT .
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method HANDLEDEFAULT .
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method HANDLEDEFAULT .
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method HANDLEDEFAULT .
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method HANDLEDEFAULT .
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method ONACTIONCANCEL .
  DATA lv_wc TYPE REF TO IF_WD_WINDOW_CONTROLLER.
  data lv_view TYPE REF TO IF_WD_VIEW_CONTROLLER.
  data lo_window  type ref to if_wd_window.
  lv_view = wd_this->wd_get_api( ).
  lv_wc = lv_view->GET_EMBEDDING_WINDOW_CTLR( ).
  lo_window =  lv_wc->GET_WINDOW( ).
  lo_window->CLOSE( ).
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method ONACTIONCANCEL .
  DATA lv_wc TYPE REF TO IF_WD_WINDOW_CONTROLLER.
  data lv_view TYPE REF TO IF_WD_VIEW_CONTROLLER.
  data lo_window  type ref to if_wd_window.
  lv_view = wd_this->wd_get_api( ).
  lv_wc = lv_view->GET_EMBEDDING_WINDOW_CTLR( ).
  lo_window =  lv_wc->GET_WINDOW( ).
  lo_window->CLOSE( ).
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method onactionsearch .
  "wd_comp_controller->map_search_vs_values( ).
*  if wd_this->check_user_input_something( ) eq abap_true.
    wd_this->SC_SEARCH_DRUCKEREI( ).
*    data:
*      lv_count            type i,
*      node_data           type ref to if_wd_context_node,
*      ltab_result         type ZVTT_DRUCKORT,
*      lstr_result         type ZVST_DRUCKORT.
*
*    node_data = wd_context->get_child_node( name = IF_V_DRUCKEREI_SUCHE=>WDCTX_E_TAB_DRUCKEREIEN ).
*
*    node_data->get_static_attributes_table(
*      importing
*        table  = ltab_result ).
*  else.
*
*    data:
*      lt_string_table          type string_table.
*
*    append 'Sie haben keinen Suchparameter eingegeben!' to lt_string_table.
*    append 'Wollen Sie die Suche wirklich so starten?' to lt_string_table.
*
*    wd_this->open_2btn_confirm_popup(
*        button_no_action = 'NOPE'
*        button_no_text = 'Nein'
*        button_no_tooltip = ''
*        button_yes_action = 'REALLY_SEARCH'
*        button_yes_text = 'Ja'
*        button_yes_tooltip = ''
*        message_text = lt_string_table
*        popup_height = '300'
*        popup_width = '300'
*        title = 'Suche starten?'
*    ).
*
*  endif.
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method onactionsearch .
  "wd_comp_controller->map_search_vs_values( ).
*  if wd_this->check_user_input_something( ) eq abap_true.
    wd_this->SC_SEARCH_SPEDITION( ).
*    data:
*      lv_count            type i,
*      node_data           type ref to if_wd_context_node,
*      ltab_result         type ZVTT_DRUCKORT,
*      lstr_result         type ZVST_DRUCKORT.
*
*    node_data = wd_context->get_child_node( name = IF_V_DRUCKEREI_SUCHE=>WDCTX_E_TAB_DRUCKEREIEN ).
*
*    node_data->get_static_attributes_table(
*      importing
*        table  = ltab_result ).
*  else.
*
*    data:
*      lt_string_table          type string_table.
*
*    append 'Sie haben keinen Suchparameter eingegeben!' to lt_string_table.
*    append 'Wollen Sie die Suche wirklich so starten?' to lt_string_table.
*
*    wd_this->open_2btn_confirm_popup(
*        button_no_action = 'NOPE'
*        button_no_text = 'Nein'
*        button_no_tooltip = ''
*        button_yes_action = 'REALLY_SEARCH'
*        button_yes_text = 'Ja'
*        button_yes_tooltip = ''
*        message_text = lt_string_table
*        popup_height = '300'
*        popup_width = '300'
*        title = 'Suche starten?'
*    ).
*
*  endif.
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method ONACTIONNOPE .
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method ONACTIONNOPE .
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method onactionconfirm .
*
*   Gewählte Zeile auslesen
*
  data: context_node type ref to if_wd_context_node.
  data: lt_ansprechpartner type zvtt_ansprechpartner, "STANDARD TABLE OF IF_WD_VIEW=>element_ansprechpartner_tbl,
        ls_ansprechpartner type zvst_ansprechpartner. "like line of lt_ansprechpartner.
  data: ld_element   type ref to if_wd_context_element.
  context_node = wd_context->get_child_node( name = 'ANSPRECHPARTNER_TBL').
  ld_element   = context_node->get_lead_selection( ).
  if ld_element is not initial.
    ld_element->get_static_attributes( importing
                                        static_attributes = ls_ansprechpartner ).
*
*   Zu speichernde Attribute auslesen und in passende Struktur speichern
*
    data lo_nd_sped_ansp_auswahl type ref to if_wd_context_node.
    data lo_el_sped_ansp_auswahl type ref to if_wd_context_element.
    data ls_sped_ansp_auswahl type wd_this->element_sped_ansp_auswahl.
    data lo_nd_sped_ansp_suche type ref to if_wd_context_node.
    data lo_el_sped_ansp_suche type ref to if_wd_context_element.
    data ls_sped_ansp_suche type wd_this->element_sped_ansp_suche.
    data lv_spedition_nr type wd_this->element_sped_ansp_suche-spedition.
    lo_nd_sped_ansp_suche = wd_context->get_child_node( name = wd_this->wdctx_sped_ansp_suche ).
    lo_el_sped_ansp_suche = lo_nd_sped_ansp_suche->get_element( ).
    lo_el_sped_ansp_suche->get_attribute(
      exporting
        name =  `SPEDITION`
      importing
        value = lv_spedition_nr ).
    ls_sped_ansp_auswahl-ansprechpartner_id = ls_ansprechpartner-lfdnr_apartner.
    ls_sped_ansp_auswahl-spedition_nr = lv_spedition_nr.
    concatenate ls_ansprechpartner-vorname ls_ansprechpartner-nachname into ls_sped_ansp_auswahl-ansprechpartner_name separated by space.
    lo_nd_sped_ansp_auswahl = wd_context->get_child_node( name = wd_this->wdctx_sped_ansp_auswahl ).
    lo_el_sped_ansp_auswahl = lo_nd_sped_ansp_auswahl->get_element( ).
    lo_el_sped_ansp_auswahl->set_static_attributes(
       static_attributes = ls_sped_ansp_auswahl ).
*
*   Ergebnistabelle aktualisieren
*
    data lo_nd_spedition_ergebnis type ref to if_wd_context_node.
    data lt_spedition_ergebnis type wd_this->elements_spedition_ergebnis.
    lo_nd_spedition_ergebnis = wd_context->get_child_node( name = wd_this->wdctx_spedition_ergebnis ).
    lo_nd_spedition_ergebnis->get_static_attributes_table( importing table = lt_spedition_ergebnis ).
    data ls_spedition_ergebnis type zvst_versand_spedition.
    data lt_spedition_ergebnis_result type wd_this->elements_spedition_ergebnis.
    loop at lt_spedition_ergebnis into ls_spedition_ergebnis.
      if ls_spedition_ergebnis-spedition_nr eq lv_spedition_nr.
        ls_spedition_ergebnis-ansprechpartner_id = ls_sped_ansp_auswahl-ansprechpartner_id.
        ls_spedition_ergebnis-ansprechpartner_name = ls_sped_ansp_auswahl-ansprechpartner_name.
      endif.
      append ls_spedition_ergebnis to lt_spedition_ergebnis_result.
    endloop.
*
*   Aktualisierte Tabelle in Kontext speichern
*
    lo_nd_spedition_ergebnis->bind_table( new_items = lt_spedition_ergebnis_result set_initial_elements = abap_true ).
  endif.
*
*   Popup schließen
*
  data lv_wc type ref to if_wd_window_controller.
  data lv_view type ref to if_wd_view_controller.
  data lo_window  type ref to if_wd_window.
  lv_view = wd_this->wd_get_api( ).
  lv_wc = lv_view->get_embedding_window_ctlr( ).
  lo_window =  lv_wc->get_window( ).
  lo_window->close( ).
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method ONACTIONCONFIRM .
  DATA: LS_DRUCK_ansprechprtnr type ZVST_DRUCKORT_ANSPRECHPARTNER.
  FIELD-SYMBOLS: <ls_druck_ansprech> type zvst_druckort_ansprechpartner.
  if wd_this->GET_NUM_OF_SELECTIONS( ) > 0.
    if wd_this->check_ansp_exist( ) eq abap_true.
*
*   Zu ergänzende Tabelle lesen
*
      DATA lo_nd_druck_ansprechprtnr TYPE REF TO if_wd_context_node.
      DATA lt_druck_ansprechprtnr TYPE ZVTT_DRUCKORT_ANSPRECHPARTNER.
      lo_nd_druck_ansprechprtnr = wd_context->get_child_node( name = wd_this->wdctx_druck_ansprechprtnr ).
      lo_nd_druck_ansprechprtnr->get_static_attributes_table( importing table = lt_druck_ansprechprtnr ).
*
*   Hinzuzufügende Tabelle lesen
*
      DATA lo_nd_druckort_ergebnis TYPE REF TO if_wd_context_node.
      DATA lt_druckort_ergebnis TYPE ZVTT_DRUCKORT_ANSPRECHPARTNER.
      lo_nd_druckort_ergebnis = wd_context->get_child_node( name = wd_this->wdctx_druckort_ergebnis ).
      lo_nd_druckort_ergebnis->get_static_attributes_table( importing table = lt_druckort_ergebnis ).
*
*   Tabellen zusammenfügen
*
      DATA ls_druckort_ergebnis TYPE ZVST_DRUCKORT_ANSPRECHPARTNER.
      FIELD-SYMBOLS: <ls_druckort_ergebnis> type zvst_druckort_ansprechpartner.
      loop at LT_DRUCK_ANSPRECHPRTNR assigning <ls_druck_ansprech>.
        loop at LT_DRUCKORT_ERGEBNIS assigning <LS_DRUCKORT_ERGEBNIS>.
          if <LS_DRUCK_ANSPRECH>-DRUCKORT_NR EQ <LS_DRUCKORT_ERGEBNIS>-DRUCKORT_NR
            and <LS_DRUCKORT_ERGEBNIS>-SELECTED EQ 'X'.
            <LS_DRUCKORT_ERGEBNIS>-ACTION = '1'.
            <LS_DRUCK_ANSPRECH> = <LS_DRUCKORT_ERGEBNIS>.
            clear <ls_druckort_ergebnis>.
          endif.
        endloop.
      endloop.
      DELETE LT_DRUCKORT_ERGEBNIS where TABLE_LINE is initial.
      DATA lo_nd_druckort_anspr_ddk TYPE REF TO if_wd_context_node.
      DATA lt_druckort_anspr_ddk TYPE wd_this->Elements_druckort_anspr_ddk.
      loop at lt_druckort_ergebnis into ls_druckort_ergebnis.
        if LS_DRUCKORT_ERGEBNIS-ANSPRECHPARTNER_ID is not initial
          AND LS_DRUCKORT_ERGEBNIS-SELECTED EQ 'X'.
          LS_DRUCKORT_ERGEBNIS-ACTION = '1'.
          append ls_druckort_ergebnis to LT_DRUCK_ANSPRECHPRTNR.
          " Eventuelle Löschen-Action-Flags entfernen
          lo_nd_druckort_anspr_ddk = wd_context->get_child_node( name = wd_this->wdctx_druckort_anspr_ddk ).
          lo_nd_druckort_anspr_ddk->get_static_attributes_table( importing table = lt_druckort_anspr_ddk ).
          " Zeile aus interner Tabelle löschen
          DELETE LT_DRUCKORT_ANSPR_DDK WHERE
          DRUCKORT_NR EQ LS_DRUCKORT_ERGEBNIS-DRUCKORT_NR.
          SORT lt_druckort_anspr_ddk ASCENDING.
          " Tabelle neu binden
          lo_nd_druckort_anspr_ddk = wd_context->get_child_node( name = WD_COMP_CONTROLLER->wdctx_druckort_anspr_ddk ).
          lo_nd_druckort_anspr_ddk->bind_table( new_items = lt_druckort_anspr_ddk set_initial_elements = abap_true ).
        endif.
      endloop.
      sort LT_DRUCK_ANSPRECHPRTNR by DRUCKORT_NR.
*
*   Zusammengesetzte Tabelle in Kontext speichern
*
      lo_nd_druck_ansprechprtnr = wd_context->get_child_node( name = wd_this->wdctx_druck_ansprechprtnr ).
      lo_nd_druck_ansprechprtnr->bind_table( new_items = lt_druck_ansprechprtnr set_initial_elements = abap_true ).
*
*   Popup schließen
*
      DATA lv_wc TYPE REF TO IF_WD_WINDOW_CONTROLLER.
      data lv_view TYPE REF TO IF_WD_VIEW_CONTROLLER.
      data lo_window  type ref to if_wd_window.
      lv_view = wd_this->wd_get_api( ).
      lv_wc = lv_view->GET_EMBEDDING_WINDOW_CTLR( ).
      lo_window =  lv_wc->GET_WINDOW( ).
      lo_window->CLOSE( ).
    else.
      WD_COMP_CONTROLLER->write_transaction_msg( msg_type = 'ERROR' msg_text = 'Jeder Druckort benötigt einen Ansprechpartner' ).
    endif.
  else.
    WD_COMP_CONTROLLER->write_transaction_msg( msg_type = 'ERROR' msg_text = 'Zum Übernehmen muss mindestens ein Druckort gewählt werden.' ).
  endif.
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method ONACTIONCONFIRM .
  DATA: LS_sped_ansprechprtnr type ZVST_versand_spedition.
  DATA lv_spedition_nr TYPE zvispspdnr.
  FIELD-SYMBOLS: <ls_spdn_ansprech> type ZVST_versand_spedition.
  if wd_this->GET_NUM_OF_SELECTIONS( ) EQ 1.
    if wd_this->check_ansp_exist( ) eq abap_true.
*
*   Ersetzende Tabelle lesen
*
      DATA lo_nd_spedition_ergebnis TYPE REF TO if_wd_context_node.
      DATA lt_spedition_ergebnis TYPE ZVTT_spedition_ANSPRECHPARTNER.
      lo_nd_spedition_ergebnis = wd_context->get_child_node( name = wd_this->wdctx_spedition_ergebnis ).
      lo_nd_spedition_ergebnis->get_static_attributes_table( importing table = lt_spedition_ergebnis ).
*
*   Bestehende Tabellen ersetzen
*
      DATA lo_nd_spdn_ansprechpartner TYPE REF TO if_wd_context_node.
      DATA lt_spdn_ansprechpartner TYPE wd_this->Elements_spdn_ansprechpartner.
      lo_nd_spdn_ansprechpartner = wd_context->get_child_node( name = wd_this->wdctx_spdn_ansprechpartner ).
      lo_nd_spdn_ansprechpartner->get_static_attributes_table( importing table = lt_spdn_ansprechpartner ).
      CLEAR LT_SPDN_ANSPRECHPARTNER.
      loop at LT_SPEDITION_ERGEBNIS assigning <LS_SPDN_ANSPRECH>.
        if <LS_SPDN_ANSPRECH>-ANSPRECHPARTNER_ID is not initial.
          lv_spedition_nr = <LS_SPDN_ANSPRECH>-SPEDITION_NR.
          append <LS_SPDN_ANSPRECH> to LT_SPDN_ANSPRECHPARTNER.
        endif.
      endloop.
      lo_nd_spdn_ansprechpartner->bind_table( new_items = lt_spdn_ansprechpartner set_initial_elements = abap_true ).
*
*   Speditionsnummer in Kontext setzen
*
  DATA lo_nd_e_str_object_init TYPE REF TO if_wd_context_node.
  DATA lo_el_e_str_object_init TYPE REF TO if_wd_context_element.
  DATA ls_e_str_object_init TYPE wd_this->Element_e_str_object_init.
  DATA lv_zzspdnr TYPE wd_this->Element_e_str_object_init-zzspdnr.
  lo_nd_e_str_object_init = wd_context->path_get_node( path = `INIT_OBJ_VERSAND.EXPORTING_INIT.E_STR_OBJECT_INIT` ).
  lo_el_e_str_object_init = lo_nd_e_str_object_init->get_element( ).
  lo_el_e_str_object_init->set_attribute(
    name =  `ZZSPDNR`
    value = lv_spedition_nr ).
*
*   Popup schließen
*
      DATA lv_wc TYPE REF TO IF_WD_WINDOW_CONTROLLER.
      data lv_view TYPE REF TO IF_WD_VIEW_CONTROLLER.
      data lo_window  type ref to if_wd_window.
      lv_view = wd_this->wd_get_api( ).
      lv_wc = lv_view->GET_EMBEDDING_WINDOW_CTLR( ).
      lo_window =  lv_wc->GET_WINDOW( ).
      lo_window->CLOSE( ).
    else.
      WD_COMP_CONTROLLER->write_transaction_msg( msg_type = 'ERROR' msg_text = 'Die Spedition benötigt einen Ansprechpartner.' ).
    endif.
  else.
    WD_COMP_CONTROLLER->WRITE_TRANSACTION_MSG( msg_type = 'ERROR' msg_text = 'Zum Übernehmen muss genau eine Spedition gewählt sein.' ).
  endif.
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method onactionconfirm .
*
*   Gewählte Zeile auslesen
*
  data: context_node type ref to if_wd_context_node.
  data: lt_ansprechpartner type zvtt_ansprechpartner, "STANDARD TABLE OF IF_WD_VIEW=>element_ansprechpartner_tbl,
        ls_ansprechpartner type zvst_ansprechpartner. "like line of lt_ansprechpartner.
  data: ld_element   type ref to if_wd_context_element.
  context_node = wd_context->get_child_node( name = 'ANSPRECHPARTNER_TBL').
  ld_element   = context_node->get_lead_selection( ).
  if ld_element is not initial.
    ld_element->get_static_attributes( importing
                                        static_attributes = ls_ansprechpartner ).
*
*   Zu speichernde Attribute auslesen und in passende Struktur speichern
*
    data lo_nd_druck_ansp_auswahl type ref to if_wd_context_node.
    data lo_el_druck_ansp_auswahl type ref to if_wd_context_element.
    data ls_druck_ansp_auswahl type wd_this->element_druck_ansp_auswahl.
    data lo_nd_druck_ansp_suche type ref to if_wd_context_node.
    data lo_el_druck_ansp_suche type ref to if_wd_context_element.
    data ls_druck_ansp_suche type wd_this->element_druck_ansp_suche.
    data lv_druckort_nr type wd_this->element_druck_ansp_suche-druckort_nr.
    lo_nd_druck_ansp_suche = wd_context->get_child_node( name = wd_this->wdctx_druck_ansp_suche ).
    lo_el_druck_ansp_suche = lo_nd_druck_ansp_suche->get_element( ).
    lo_el_druck_ansp_suche->get_attribute(
      exporting
        name =  `DRUCKORT_NR`
      importing
        value = lv_druckort_nr ).
    ls_druck_ansp_auswahl-ansprechpartner_id = ls_ansprechpartner-lfdnr_apartner.
    ls_druck_ansp_auswahl-druckort_nr = lv_druckort_nr.
    concatenate ls_ansprechpartner-vorname ls_ansprechpartner-nachname into ls_druck_ansp_auswahl-ansprechpartner_name separated by space.
    lo_nd_druck_ansp_auswahl = wd_context->get_child_node( name = wd_this->wdctx_druck_ansp_auswahl ).
    lo_el_druck_ansp_auswahl = lo_nd_druck_ansp_auswahl->get_element( ).
    lo_el_druck_ansp_auswahl->set_static_attributes(
       static_attributes = ls_druck_ansp_auswahl ).
*
*   Ergebnistabelle aktualisieren
*
    data lo_nd_druckort_ergebnis type ref to if_wd_context_node.
    data lt_druckort_ergebnis type wd_this->elements_druckort_ergebnis.
    lo_nd_druckort_ergebnis = wd_context->get_child_node( name = wd_this->wdctx_druckort_ergebnis ).
    lo_nd_druckort_ergebnis->get_static_attributes_table( importing table = lt_druckort_ergebnis ).
    data ls_druckort_ergebnis type zvst_druckort_ansprechpartner.
    data lt_druckort_ergebnis_result type wd_this->elements_druckort_ergebnis.
    loop at lt_druckort_ergebnis into ls_druckort_ergebnis.
      if ls_druckort_ergebnis-druckort_nr eq lv_druckort_nr.
        ls_druckort_ergebnis-ansprechpartner_id = ls_druck_ansp_auswahl-ansprechpartner_id.
        ls_druckort_ergebnis-ansprechpartner_name = ls_druck_ansp_auswahl-ansprechpartner_name.
      endif.
      append ls_druckort_ergebnis to lt_druckort_ergebnis_result.
    endloop.
*
*   Aktualisierte Tabelle in Kontext speichern
*
    lo_nd_druckort_ergebnis->bind_table( new_items = lt_druckort_ergebnis_result set_initial_elements = abap_true ).
  endif.
*
*   Popup schließen
*
  data lv_wc type ref to if_wd_window_controller.
  data lv_view type ref to if_wd_view_controller.
  data lo_window  type ref to if_wd_window.
  lv_view = wd_this->wd_get_api( ).
  lv_wc = lv_view->get_embedding_window_ctlr( ).
  lo_window =  lv_wc->get_window( ).
  lo_window->close( ).
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method ONACTIONPOPUP_CLOSE .
  DATA lv_wc TYPE REF TO IF_WD_WINDOW_CONTROLLER.
  data lv_view TYPE REF TO IF_WD_VIEW_CONTROLLER.
  data lo_window  type ref to if_wd_window.
  lv_view = wd_this->wd_get_api( ).
  lv_wc = lv_view->GET_EMBEDDING_WINDOW_CTLR( ).
  lo_window =  lv_wc->GET_WINDOW( ).
  lo_window->CLOSE( ).
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method onactionpopup_select_ansp .
*
*   Nummer des gewählten Druckorts auslesen und in Kontext speichern
*
  data lo_nd_druckort type ref to if_wd_context_node.
  data lo_el_druckort type ref to if_wd_context_element.
  data ls_druckort type wd_this->element_druckort_ergebnis.
  lo_nd_druckort = wd_context->get_child_node( name = wd_this->wdctx_druckort_ergebnis ).
  "lo_nd_druckort = wd_context->path_get_node( path = `DRUCKORT_ERGEBNIS` ).
  context_element->get_static_attributes(
    importing
      static_attributes = ls_druckort ).
  data lo_nd_druck_ansp_suche type ref to if_wd_context_node.
  data lo_el_druck_ansp_suche type ref to if_wd_context_element.
  data ls_druck_ansp_suche type wd_this->element_druck_ansp_suche.
  lo_nd_druck_ansp_suche = wd_context->get_child_node( name = wd_this->wdctx_druck_ansp_suche ).
  lo_el_druck_ansp_suche = lo_nd_druck_ansp_suche->get_element( ).
  ls_druck_ansp_suche = ls_druckort.
  lo_el_druck_ansp_suche->set_attribute(
    exporting
      value = ls_druckort-druckort_nr     " Der Wert des Attributes
      name  = 'DRUCKORT_NR'    " Web Dynpro: Name eines Kontext Elementes
  ).
*
*   Popup öffnen
*
  data: context_node type ref to if_wd_context_node.
  data: lr_popup type ref to if_wd_window,
        lr_view_controller type ref to if_wd_view_controller.
  data: lr_api_comp_controller type ref to if_wd_component,
        lr_window_manager type ref to if_wd_window_manager.
  lr_api_comp_controller = wd_comp_controller->wd_get_api( ).
  lr_window_manager = lr_api_comp_controller->get_window_manager( ).
  lr_popup = lr_window_manager->create_window(
  modal               = abap_true
  window_name         = 'POPUP_ANSP_WINDOW'  "Name of the window created in step 2
  title               = 'Ansprechpartner auswählen:'
  close_button        = abap_true
  button_kind         = if_wd_window=>co_buttons_none
  message_type        = if_wd_window=>co_msg_type_none
  close_in_any_case   = abap_true
*MESSAGE_DISPLAY_MODE = MESSAGE_DISPLAY_MODE
  ).
* set window parameters
  lr_popup->set_window_size( width = '600' height = '200' ).
  lr_popup->set_window_position( position = if_wd_window=>co_center ).
* Adds an action to the popup screen buttons
* lr_view_controller = wd_this->wd_get_api( ).
* lr_popup->subscribe_to_button_event(
* button = if_wd_window=>co_button_ok
* button_text = 'Yes'
* action_name = 'SUBMIT'
* action_view = lr_view_controller ).
  lr_popup->open( ).
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method onactionpopup_select_ansp .
*
*   Nummer des gewählten speditions auslesen und in Kontext speichern
*
  data lo_nd_spedition type ref to if_wd_context_node.
  data lo_el_spedition type ref to if_wd_context_element.
  data ls_spedition type wd_this->element_spedition_ergebnis.
  lo_nd_spedition = wd_context->get_child_node( name = wd_this->wdctx_spedition_ergebnis ).
  "lo_nd_spedition = wd_context->path_get_node( path = `spedition_ERGEBNIS` ).
  context_element->get_static_attributes(
    importing
      static_attributes = ls_spedition ).
  data lo_nd_sped_ansp_suche type ref to if_wd_context_node.
  data lo_el_sped_ansp_suche type ref to if_wd_context_element.
  data ls_sped_ansp_suche type wd_this->element_sped_ansp_suche.
  lo_nd_sped_ansp_suche = wd_context->get_child_node( name = wd_this->wdctx_sped_ansp_suche ).
  lo_el_sped_ansp_suche = lo_nd_sped_ansp_suche->get_element( ).
  ls_sped_ansp_suche = ls_spedition.
  lo_el_sped_ansp_suche->set_attribute(
    exporting
      value = ls_spedition-spedition_nr     " Der Wert des Attributes
      name  = 'SPEDITION'    " Web Dynpro: Name eines Kontext Elementes
  ).
*
*   Popup öffnen
*
  data: context_node type ref to if_wd_context_node.
  data: lr_popup type ref to if_wd_window,
        lr_view_controller type ref to if_wd_view_controller.
  data: lr_api_comp_controller type ref to if_wd_component,
        lr_window_manager type ref to if_wd_window_manager.
  lr_api_comp_controller = wd_comp_controller->wd_get_api( ).
  lr_window_manager = lr_api_comp_controller->get_window_manager( ).
  lr_popup = lr_window_manager->create_window(
  modal               = abap_true
  window_name         = 'POPUP_ANSP_SPED_WIN'  "Name of the window created in step 2
  title               = 'Ansprechpartner auswählen:'
  close_button        = abap_true
  button_kind         = if_wd_window=>co_buttons_none
  message_type        = if_wd_window=>co_msg_type_none
  close_in_any_case   = abap_true
*MESSAGE_DISPLAY_MODE = MESSAGE_DISPLAY_MODE
  ).
* set window parameters
  lr_popup->set_window_size( width = '600' height = '200' ).
  lr_popup->set_window_position( position = if_wd_window=>co_center ).
* Adds an action to the popup screen buttons
* lr_view_controller = wd_this->wd_get_api( ).
* lr_popup->subscribe_to_button_event(
* button = if_wd_window=>co_button_ok
* button_text = 'Yes'
* action_name = 'SUBMIT'
* action_view = lr_view_controller ).
  lr_popup->open( ).
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method ONACTIONPOPUP_CLOSE .
  DATA lv_wc TYPE REF TO IF_WD_WINDOW_CONTROLLER.
  data lv_view TYPE REF TO IF_WD_VIEW_CONTROLLER.
  data lo_window  type ref to if_wd_window.
  lv_view = wd_this->wd_get_api( ).
  lv_wc = lv_view->GET_EMBEDDING_WINDOW_CTLR( ).
  lo_window =  lv_wc->GET_WINDOW( ).
  lo_window->CLOSE( ).
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method init .
  data:
  l_lock_state type wdy_boolean,
  l_object_id  type zvde_objekt.
  l_lock_state = wd_this->get_is_lock(  ).
  l_object_id = wd_this->get_object_id(  ).
  wd_this->init_view( ).
  wd_this->set_sc_init_input( object_id = l_object_id is_locked = l_lock_state ).
  wd_this->sc_init_obj_versand(
    importing
      ev_authorized = EV_AUTHORIZED
  ).
  if ( wd_this->get_current_process( ) eq zcl_vis_properties=>process_create ).
    wd_this->set_is_lock( l_lock_state ).
  else.
    data:
      node_init_obj_versand               type ref to if_wd_context_node,
      node_exporting_init                 type ref to if_wd_context_node,
      elem_exporting_init                 type ref to if_wd_context_element,
      stru_exporting_init                 type if_componentcontroller=>element_exporting_init ,
      item_e_lock                         like stru_exporting_init-e_lock_init.
* navigate from <CONTEXT> to <INIT_OBJ_MASTERDATA> via lead selection
    node_init_obj_versand = wd_context->get_child_node( name = `INIT_OBJ_VERSAND` ).
* navigate from <INIT_OBJ_MASTERDATA> to <EXPORTING_MD> via lead selection
    node_exporting_init = node_init_obj_versand->get_child_node( name = `EXPORTING_INIT` ).
    elem_exporting_init = node_exporting_init->get_element(  ).
    elem_exporting_init->get_attribute(
      exporting
        name =  `E_LOCK_INIT`
      importing
        value = item_e_lock ).
    wd_this->set_is_lock( item_e_lock ).
*    wd_this->vmp_flag = wd_this->get_vmp_value( ).
  endif.
if ev_authorized eq abap_true.
  wd_this->backup_versand_objekt( ).
  wd_this->init_druckerei_table( ).
  wd_this->init_spedition_table( ).
  "Erweiterung 2018 Transportkosten #1082635  Transportkosten
  wd_this->INIT_TRANSPORTCOST_TABLES( ).  "KEMPF_S
  wd_this->INIT_TRANSPORTCOST_TABLES_DDK( ).  "KEMPF_S
  wd_this->init_versandarten_table( ).
  wd_this->init_daten_postversand( ).
  wd_this->init_vs_druckort_ddk( ).
  wd_this->fill_vs_druckort_ddk( ).
  wd_this->init_vs_spedition_ddk( ).
  wd_this->fill_vs_spedition_ddk( ).
  wd_this->init_vs_versandart_ddk( ).
  wd_this->fill_vs_versandart_ddk( ).
  wd_this->set_popup_size( ).
  wd_this->init_radiobutton_sortenbez( ).
  " Freigabestatus
  wd_this->map_status( ).
endif.
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method GET_IS_READONLY .
  "2018 KEMPF_S
    DATA:
    node_object_repository           TYPE REF TO if_wd_context_node,
    elem_object_repository           TYPE REF TO if_wd_context_element,
    stru_object_repository           TYPE if_componentcontroller=>element_OBJECT_REPOSITORY .
* navigate from <CONTEXT> to <OBJECT_REPOSITORY> via lead selection
  node_object_repository = wd_context->get_child_node( name = `OBJECT_REPOSITORY` ).
* get element via lead selection
  elem_object_repository = node_object_repository->get_element(  ).
* get all declared attributes
  elem_object_repository->get_static_attributes(
    IMPORTING
      static_attributes = stru_object_repository ).
  read_only = stru_object_repository-IS_READONLY.
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method INIT_SPEDITION_TABLE .
  DATA: ltab_result type ZVTT_SPEDITION_ANSPRECHPARTNER,
        lv_objekt   type ZVDE_OBJEKT,
        ltab_return type zvtt_return.
  DATA lo_nd_object_repository TYPE REF TO if_wd_context_node.
  DATA lo_el_object_repository TYPE REF TO if_wd_context_element.
  DATA ls_object_repository TYPE wd_this->Element_object_repository.
  lo_nd_object_repository = wd_context->get_child_node( name = wd_this->wdctx_object_repository ).
  lo_el_object_repository = lo_nd_object_repository->get_element( ).
* get single attribute
  lo_el_object_repository->get_attribute(
    EXPORTING
      name =  `OBJECT_ID`
    IMPORTING
      value = lv_objekt ).
CALL FUNCTION 'ZV_GET_SPEDITION_MAPI'
  EXPORTING
    IV_OBJ            = lv_objekt
 IMPORTING
   ETAB_RESULT       = ltab_result
   ETAB_RETURN       = ltab_return
          .
  DATA lo_nd_spedition_ansprechprtnr TYPE REF TO if_wd_context_node.
  DATA lt_spdn_ansprechpartner TYPE wd_this->Elements_spdn_ansprechpartner.
  lo_nd_spedition_ansprechprtnr = wd_context->get_child_node( name = wd_this->wdctx_spdn_ansprechpartner ).
  lo_nd_spedition_ansprechprtnr->BIND_TABLE(
    EXPORTING
      NEW_ITEMS            =  ltab_result   " Liste von Elementen oder Modeldaten
*      SET_INITIAL_ELEMENTS = ABAP_TRUE    " Falls TRUE setzen der initialen Elemente, sonst Anfügen
*      INDEX                =     " Index eines Kontext Elementes
  ).
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method APPEND_TRANSCOST_DELETED .
  "Gerufen von ACTION DEL_TRANSCOST
  "Flag in DDK Tab setzen = 3 für gelöscht.
  "Die Tabelle hat evt. redundante Einträge, da hier angehängt wird.
  "Allerdings haben die angehängten dann ACTION = 3 und können damit unterschieden werden.
   DATA(lo_nd_node) = wd_context->path_get_node( path = IV_PATH ).
   IF NOT lo_nd_node IS BOUND.
     "+ ERROR Message
     RETURN.
   ENDIF.
*  append a line to the node
   lo_nd_node->bind_structure( new_item = is_data set_initial_elements = abap_false ).
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method INIT_TRANSPORTCOST_TABLES_DDK .
    DATA:
     lo_nd_node_vortrans_ddk   TYPE REF TO if_wd_context_node,
     lt_vortransport           TYPE wd_this->Elements_node_vortrans_ddk,
     lo_nd_node_uebernahme_ddk TYPE REF TO if_wd_context_node,
     lt_uebernahme             TYPE wd_this->Elements_node_uebernahme_ddk,
     lo_nd_node_ecotax_ddk     TYPE REF TO if_wd_context_node,
     lt_ecotax                 TYPE wd_this->Elements_node_ecotax_ddk,
     lo_nd_node_maut_ddk       TYPE REF TO if_wd_context_node,
     lt_maut                   TYPE wd_this->Elements_node_maut_ddk,
     lo_nd_object_repository   TYPE REF TO if_wd_context_node,
     lo_el_object_repository   TYPE REF TO if_wd_context_element,
     lv_objekt                 TYPE ZVDE_OBJEKT,
     lt_return                 TYPE zvtt_return.
     lo_nd_object_repository = wd_context->get_child_node( name = wd_this->wdctx_object_repository ).
     lo_el_object_repository = lo_nd_object_repository->get_element( ).
* get single attribute
    lo_el_object_repository->get_attribute(
      EXPORTING
        name =  `OBJECT_ID`
      IMPORTING
        value = lv_objekt ).
    CALL FUNCTION 'ZV_GET_TRANSCOST_MAPI'
    EXPORTING
      IV_OBJ                = lv_objekt
   IMPORTING
     ET_MAUT               = lt_maut
     ET_VORTRANSPORT       = lt_vortransport
     ET_UEBERNAHME         = lt_uebernahme
     ET_ECOTAX             = lt_ecotax
     ET_RETURN             = lt_return
            .
*   navigate from <CONTEXT> to <NODE_VORTRANS_DDK> via lead selection
    lo_nd_node_vortrans_ddk = wd_context->path_get_node( path = `NODE_TRANS_COST.NODE_VORTRANS_DDK` ).
*   @TODO handle non existent child
   IF NOT lo_nd_node_vortrans_ddk IS INITIAL.
      "leeren
    lo_nd_node_vortrans_ddk->bind_table( new_items = lt_vortransport set_initial_elements = abap_true ).
   ENDIF.
*   navigate from <CONTEXT> to <NODE_VORTRANS_DDK> via lead selection
    lo_nd_node_maut_ddk = wd_context->path_get_node( path = `NODE_TRANS_COST.NODE_MAUT_DDK` ).
*   @TODO handle non existant child
   IF NOT lo_nd_node_maut_ddk IS INITIAL.
      "leeren
    lo_nd_node_maut_ddk->bind_table( new_items = lt_maut set_initial_elements = abap_true ).
   ENDIF.
*   navigate from <CONTEXT> to <NODE_VORTRANS_DDK> via lead selection
    lo_nd_node_uebernahme_ddk = wd_context->path_get_node( path = `NODE_TRANS_COST.NODE_UEBERNAHME_DDK` ).
*   @TODO handle non existant child
   IF NOT lo_nd_node_uebernahme_ddk IS INITIAL.
      "leeren
    lo_nd_node_uebernahme_ddk->bind_table( new_items = lt_uebernahme set_initial_elements = abap_true ).
   ENDIF.
*   navigate from <CONTEXT> to <NODE_VORTRANS_DDK> via lead selection
    lo_nd_node_ecotax_ddk = wd_context->path_get_node( path = `NODE_TRANS_COST.NODE_ECOTAX_DDK` ).
*   @TODO handle non existant child
   IF NOT lo_nd_node_ecotax_ddk IS INITIAL.
      "leeren
    lo_nd_node_ecotax_ddk->bind_table( new_items = lt_ecotax set_initial_elements = abap_true ).
   ENDIF.
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method ONACTIONON_SELECT_MAUT .
  "KEMPF_S 1/2019
  "Wenn der Eintrag gewählt wird, dann muss der Wert im Mautknoten entsprechend gesetzt werden.
  "Das Event feuert auf dem Knoten NODE_MAUT
  "Der ChildKnoten NODE_MAUT_VALUES hat die Selektion dazu.
  DATA(lr_child) = CONTEXT_ELEMENT->GET_CHILD_NODE( 'NODE_MAUT_VALUES' ).
  DATA(lr_el)    = lr_child->GET_LEAD_SELECTION( ).
  DATA ls_node_maut_values TYPE wd_this->Element_node_maut_values.
*   get all declared attributes
    lr_el->get_static_attributes(
      IMPORTING
        static_attributes = ls_node_maut_values ).
    IF NOT LS_NODE_MAUT_VALUES IS INITIAL.
*       set single attribute
        CONTEXT_ELEMENT->set_attribute(
          name =  `ZZPERCENT_MAUT`
          value = LS_NODE_MAUT_VALUES-PERCENT ).
    ENDIF.
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method ONACTIONON_SELECT_VORTRANSP .
  "KEMPF_S 1/2019
  "Wenn der Eintrag gewählt wird, dann muss der Wert im Datenknoten entsprechend gesetzt werden.
  "Das Event feuert auf dem Knoten NODE_MAUT
  "Der ChildKnoten hat die Selektion dazu.
  DATA(lr_child) = CONTEXT_ELEMENT->GET_CHILD_NODE( 'NODE_VORTRANS_VALUE' ).
  DATA(lr_el)    = lr_child->GET_LEAD_SELECTION( ).
  DATA ls_node_values TYPE wd_this->ELEMENT_NODE_VORTRANS_VALUE.
*   get all declared attributes
    lr_el->get_static_attributes(
      IMPORTING
        static_attributes = LS_NODE_VALUES ).
    IF NOT LS_NODE_VALUES IS INITIAL.
*       set single attribute
        CONTEXT_ELEMENT->set_attribute(
          name =  `ZZBETRAG_VORTRANSPORT`
          value = LS_NODE_VALUES-BETRAG_STRING ).
    ENDIF.
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method ONACTIONON_SELECT_UEBERNAHME .
  "KEMPF_S 1/2019
  "Wenn der Eintrag gewählt wird, dann muss der Wert im Datenknoten entsprechend gesetzt werden.
  "Das Event feuert auf dem Knoten NODE_MAUT
  "Der ChildKnoten hat die Selektion dazu.
  DATA(lr_child) = CONTEXT_ELEMENT->GET_CHILD_NODE( 'NODE_UEBERNAHME_VAL' ).
  DATA(lr_el)    = lr_child->GET_LEAD_SELECTION( ).
  DATA ls_node_values TYPE wd_this->ELEMENT_NODE_UEBERNAHME_VAL.
*   get all declared attributes
    lr_el->get_static_attributes(
      IMPORTING
        static_attributes = LS_NODE_VALUES ).
    IF NOT LS_NODE_VALUES IS INITIAL.
*       set single attribute
        CONTEXT_ELEMENT->set_attribute(
          name =  `ZZBETRAG_UEBERNAHMESATZ`
          value = LS_NODE_VALUES-BETRAG_STRING ).
    ENDIF.
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method ONACTIONON_SELECT_TAB_TRANS .
  IF 1 = 1.
  ENDIF.
  DATA:
        lv_select_tab type string.          "Selected tab value
  DATA:
        lt_events type WDR_EVENT_PARAMETER_LIST,
        ls_events type WDR_EVENT_PARAMETER.
  field-symbols: <fs_value> type any.   "Attribute value in events table
  lt_events = wdevent->parameters.
  read table  lt_events into ls_events with key name = 'TAB'.
  if sy-subrc eq 0.
    assign ls_events-value->* to <fs_value>.
    if sy-subrc eq 0.
      me->WD_THIS->MV_TCOST_ACTIVE_TAB = <fs_value>.                    "Tab selected
    endif.
  endif.
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method GET_SELECTED .
  TRY.
    DATA(LR_SUB_NODE)    = IR_EL->GET_CHILD_NODE( IV_SUB_NODE_NAME ).
    DATA(LR_EL)          = LR_SUB_NODE->GET_LEAD_SELECTION( ).
  CATCH CX_WD_CONTEXT.
    "+Fehlermeldung
    RETURN.
  ENDTRY.
  IF NOT LR_EL IS BOUND.
    RETURN.
  ENDIF.
*   wir brauchen den Wert für das Start-Jahr
  LR_EL->GET_ATTRIBUTE(
    EXPORTING
      NAME  = IV_FIELDNAME
    IMPORTING
      VALUE = RV_VALUE " DATA -> string
  ).
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method FILL_LB_YEAR_FROM.
* 1/2019 KEMPF_S - die Listbox mit den verfügbaren Jahren wird bedarfsweise(eventgesteuert) ausgeführt(abh. v. anderen Listboxen).
  DATA  lo_nd_node TYPE REF TO if_wd_context_node.
  DATA: lt_node    TYPE wd_this->Elements_node_from_year_lb,
        lt_viof    TYPE STANDARD TABLE OF ZVIOF,
        lv_year    TYPE NUMC4.
* navigate from <CONTEXT> to <NODE_FROM_YEAR> via lead selection
  lo_nd_node = wd_context->path_get_node( path = `NODE_TRANS_COST.NODE_FROM_YEAR_LB` ).
  DATA:
       lv_objekt   TYPE ZVIOFOBJEK.
 IF lo_nd_node IS INITIAL.
   "+Fehlermeldung
    RETURN.
 ENDIF.
  DATA(lo_nd_object_repository) = wd_context->get_child_node( name = wd_this->wdctx_object_repository ).
  DATA(lo_el_object_repository) = lo_nd_object_repository->get_element( ).
* get single attribute
  lo_el_object_repository->get_attribute(
    EXPORTING
      name =  `OBJECT_ID`
    IMPORTING
      value = lv_objekt ).
  IF lo_nd_node IS INITIAL.
    "+Fehlermeldung
    RETURN.
  ENDIF.
  "Kein Start-Jahr gesetzt -> wenigstens so ab 2010 holen
  IF IV_START_YEAR IS SUPPLIED AND NOT IV_START_YEAR IS INITIAL.
    lv_year = 10000 - IV_START_YEAR.
  ELSE.
    lv_year = 2010.
    lv_year = 10000 -  lv_year.
  ENDIF.
  IF SY-SYSID = 'MZE'. "Testdaten sind hier nur bedingt gepflegt.
    lv_year = 7993.
  ENDIF.
" Daten aus der Customizing Tabelle holen.
  SELECT ZZCJAHR FROM ZVIOF INTO CORRESPONDING FIELDS OF TABLE lt_viof
    WHERE ZZOBJEK = lv_objekt AND ZZCJAHR <= lv_year
    ORDER BY ZZCJAHR ZZFOLGE.
    DELETE ADJACENT DUPLICATES FROM lt_viof COMPARING  ZZCJAHR ZZFOLGE.
  LOOP AT lt_viof ASSIGNING FIELD-SYMBOL(<lfs_v>).
      APPEND INITIAL LINE TO lt_node ASSIGNING FIELD-SYMBOL(<lfs_data>).
      <lfs_data>-YEAR = 10000 - <lfs_v>-ZZCJAHR.
  ENDLOOP.
  SORT lt_node BY YEAR ASCENDING.
  IF NOT lo_nd_node IS INITIAL.
    lo_nd_node->bind_table( new_items = lt_node set_initial_elements = abap_true ).
  ENDIF.
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method TRANSCOST_UPDATE_LISTBOX.
*KEMPF_S 1/2018
* Ähnlich wie TRANSCOST_ASSOCIATE_LISTBOX - aber für einen einzelnen Wert in einer Tabellenzeile - indentifiziert über iv_index
*Daten eines Knoten werden einem Index einer Listbox zugeordnet.
*Hierfür wird das Feld IV_KEY_FELD verwendet.
*Daten sind jeweils generisch(ohne Typangabe).
  "iv_set_initial_elements -> wenn TRUE kann ein Dump auftreten:
  "Schon während der Supply-Methode wird
  "auf dem selben Knoten COMPONENTCONTROLLER.1.NODE_TRANS_COST.1.NODE_VORTRANSPORT.1.NODE_VT_TO_FOLGE
  "die Invalidate-Methode aufgerufen.
  DATA:  lr_element      TYPE REF TO if_wd_context_element,
         context_node    TYPE REF TO if_wd_context_node,
         lv_selected_idx TYPE I.
  FIELD-SYMBOLS: <lfs_tdata>   TYPE ANY TABLE,
                 <lfs_tvalues> TYPE ANY TABLE.
    ASSIGN it_values TO <lfs_tvalues>.
    context_node = io_node_data.
    "Das entsprechende Element zur Tabellenzeile wird geholt.
    lr_element = context_node->get_element( IV_INDEX ).
    DATA(lr_child_node) = lr_element->GET_CHILD_NODE( IV_NODE_NAME ). "io_node_values->GET_NODE_INFO( )->GET_NAME( )
    "child node ist jetzt dieses Listbox Element der Zeile.
    "Die Daten darin werden gesetzt
*    lr_child_node
    io_node_values->BIND_TABLE(
      EXPORTING
        NEW_ITEMS            = <lfs_tvalues> " Liste von Elementen oder Modeldaten
        SET_INITIAL_ELEMENTS = iv_set_initial_elements " Falls TRUE setzen der initialen Elemente, sonst Anfügen
*        INDEX                = IV_INDEX     "- gibt einen Dump, wenn gesetzt.  " Index eines Kontext Elementes
    ).
    lr_child_node->SET_LEAD_SELECTION_INDEX( INDEX = -1 ).
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method ONACTIONON_SELECT_FROM_YEAR.
  "KEMPF_S 1/2019
  "Wenn der Eintrag gewählt wird, dann muss der Wert in anderen Knoten entsprechend gesetzt werden.
  "Das Event feuert z.B. auf dem Knoten NODE_...
  "Der ChildKnoten hat die Selektion dazu.
  "Damit es nur eine Funktion für alle Listboxen braucht, wird der Knotenname des Unterknotens ermittelt.
  "Wenn des von Jahr verändert wird, dann muss die Listbox mit den von Folgen angepasst werden.
  "Auch das bis Jahr braucht eine Anpassung - es dürfen nur Jahre gelistet werden, die grösser oder gleich dem von Jahr sind.
  DATA(LR_NODE) = CONTEXT_ELEMENT->GET_NODE( ).
  DATA(LV_NAME) = CONTEXT_ELEMENT->GET_NODE( )->GET_NODE_INFO( )->GET_NAME( ). "DEV
  DATA: LV_SUB_NODE_NAME        TYPE STRING.
  DATA: LV_TARGET_SUB_NODE_NAME TYPE STRING.      "hier dann ---TO_...
  DATA: LV_FIELD TYPE STRING VALUE `ZZABJHR`,     "das Feld in der Datenstruktur
        LV_VALUE TYPE STRING,
        LV_JAHR  TYPE ZVDE_JAHR,
        LV_FOLGE TYPE ZVDE_FOLGE.
  DATA: LR_DATA                  TYPE REF TO DATA,
        LR_TDATA                 TYPE REF TO DATA,
        LR_FOLGEN                TYPE REF TO DATA,
        LR_BISJAHR               TYPE REF TO DATA. "listboxwerte f. bis Jahr
  DATA LO_COMPONENTCONTROLLER   TYPE REF TO IG_COMPONENTCONTROLLER .
  FIELD-SYMBOLS: <LFS_TDATA>   TYPE ANY TABLE,
                 <LFS_TVALUES> TYPE ANY TABLE.
  CASE LV_NAME.
    WHEN 'NODE_VORTRANSPORT'.
      LV_SUB_NODE_NAME = 'NODE_VT_FROM_YEAR'.
      CREATE DATA LR_DATA   TYPE WD_THIS->ELEMENT_NODE_VORTRANSPORT.
      CREATE DATA LR_TDATA   TYPE WD_THIS->ELEMENTS_NODE_VORTRANSPORT.
      CREATE DATA LR_FOLGEN TYPE WD_THIS->ELEMENTS_NODE_VT_FROM_FOLGE. "TO_YEAR -> weil das der Zielknoten ist
      CREATE DATA LR_BISJAHR TYPE WD_THIS->ELEMENTS_NODE_VT_TO_YEAR.
    WHEN 'NODE_UEBERNAHME'.
      LV_SUB_NODE_NAME = 'NODE_UN_FROM_YEAR'.
      CREATE DATA LR_TDATA   TYPE WD_THIS->ELEMENTS_NODE_UEBERNAHME.
      CREATE DATA LR_FOLGEN  TYPE WD_THIS->ELEMENTS_NODE_UN_FROM_FOLGE.
      CREATE DATA LR_BISJAHR TYPE WD_THIS->ELEMENTS_NODE_UN_TO_YEAR.
    WHEN 'NODE_MAUT'.
      LV_SUB_NODE_NAME = 'NODE_MAUT_FROM_YEAR'.
      CREATE DATA LR_TDATA   TYPE WD_THIS->ELEMENTS_NODE_MAUT.
      CREATE DATA LR_FOLGEN  TYPE WD_THIS->ELEMENTS_NODE_MAUT_FROM_FOLGE.
      CREATE DATA LR_BISJAHR TYPE WD_THIS->ELEMENTS_NODE_MAUT_TO_YEAR.
    WHEN 'NODE_ECOTAX'.
      LV_SUB_NODE_NAME = 'NODE_ETAX_FROM_YEAR'.
      CREATE DATA LR_TDATA   TYPE WD_THIS->ELEMENTS_NODE_ECOTAX.
      CREATE DATA LR_FOLGEN TYPE WD_THIS->ELEMENTS_NODE_ETAX_FROM_FOLGE.
      CREATE DATA LR_BISJAHR TYPE WD_THIS->ELEMENTS_NODE_ETAX_TO_YEAR.
    WHEN OTHERS.
      RETURN.
  ENDCASE.
  "Das Ziel ist:
  LV_TARGET_SUB_NODE_NAME = LV_SUB_NODE_NAME.
  "REPLACE '_FROM_' IN LV_TARGET_SUB_NODE_NAME WITH '_TO_'. "dieser soll gesetzt werden, abhängig von unseren Werten.
  REPLACE '_YEAR' IN LV_TARGET_SUB_NODE_NAME WITH '_FOLGE'."Abhängig v. Jahr werden die Folgen gesetzt
  LO_COMPONENTCONTROLLER =   WD_THIS->GET_COMPONENTCONTROLLER_CTR( ).
  DATA(LR_YEAR)    = CONTEXT_ELEMENT->GET_CHILD_NODE( LV_SUB_NODE_NAME ).
  DATA(LR_EL_YEAR) = LR_YEAR->GET_LEAD_SELECTION( ).
*   wir brauchen den Wert für das Start-Jahr
  LR_EL_YEAR->GET_ATTRIBUTE(
    EXPORTING
      NAME  = LV_FIELD
    IMPORTING
      VALUE = LV_VALUE " DATA -> string
  ).
  LV_JAHR = LV_VALUE .  "der ausgewählte Wert
  "Der Wert wird eingesetzt, damit dieser beim späteren Speichern verfügbar ist
  IF NOT LV_VALUE IS INITIAL.
    CONTEXT_ELEMENT->SET_ATTRIBUTE(
      NAME =  LV_FIELD
      VALUE = LV_VALUE ).
    ASSIGN LR_TDATA->* TO <LFS_TDATA>. "eine Tabelle
    ASSIGN LR_FOLGEN->* TO <LFS_TVALUES>.
DATA(lv_index) = CONTEXT_ELEMENT->GET_INDEX( ).
  "es wird nur der geänderte Eintrag aktualisiert.
    LR_NODE->GET_STATIC_ATTRIBUTES_TABLE(
*      EXPORTING
*        FROM  = lv_index          " Web Dynpro: Index eines Kontext Elementes
*        TO    = lv_index " Web Dynpro: Index eines Kontext Elementes
      IMPORTING
        TABLE = <LFS_TDATA>
    ).  "( IMPORTING TABLE = <LFS_TDATA> ).
*    ASSIGN LR_DATA TO FIELD-SYMBOL(<lfs_data>).
*    LR_NODE->GET_STATIC_ATTRIBUTES(
***      EXPORTING
***        INDEX             = USE_LEAD_SELECTION " Web Dynpro: Index eines Kontext Elementes
*      IMPORTING
*        STATIC_ATTRIBUTES = <lfs_data>  " $REF$
*    ).
    LO_COMPONENTCONTROLLER->FILL_LB_FOLGE( "die Ab-Folge gemäß den Möglichkeiten des Jahres setzen
        EXPORTING
          NODE = LR_NODE                                 "Referenz zu dem Knoten mit den Daten.
*            PARENT_ELEMENT =                            " obsolet
         IV_JAHR             =  LV_JAHR                  " zvde_jahr
         IV_START_FOLGE      =  LV_FOLGE
         IV_TARGET_NODE_NAME =  LV_TARGET_SUB_NODE_NAME  " csequence
         IV_DATA_FIELD       =  'ZZABFOLGE'              " csequence
         IV_VALUE_FIELD      =  'ZZABFOLGE'              " csequence
         IT_NODE_DATA        =  <LFS_TDATA>              " daten des Knotens
         IV_INDEX            =  LV_INDEX                 "nur diesen Eintrag
       CHANGING
         CT_TARGET_VALUES    =  <LFS_TVALUES>            " -> Listboxwerte, anfänglich leer, werden befüllt
      ).
    "Eventuell muss das BIS-Jahr angepasst werden.
    LV_TARGET_SUB_NODE_NAME = LV_SUB_NODE_NAME.
    REPLACE '_FROM_' IN LV_TARGET_SUB_NODE_NAME WITH '_TO_'.
    ASSIGN LR_BISJAHR->* TO <LFS_TVALUES>.
*    LR_NODE->GET_STATIC_ATTRIBUTES_TABLE(
*           IMPORTING TABLE = <LFS_TDATA> ).
    LO_COMPONENTCONTROLLER->FILL_LB_YEAR( "das Ab-Jahr gemäß den Möglichkeiten  setzen
        EXPORTING
          NODE = LR_NODE                                 "Referenz zu dem Knoten mit den Daten.
         IV_JAHR             =  LV_JAHR                  " zvde_jahr
         IV_TARGET_NODE_NAME =  LV_TARGET_SUB_NODE_NAME  " csequence
         IV_DATA_FIELD       =  'ZZBISJHR'               " der Name des Zielfeldes
         IV_VALUE_FIELD      =  'ZZBISJHR'               " cer Name des Zielfeldes in der Listbox
         IT_NODE_DATA        =  <LFS_TDATA>              " daten des Knotens
         IV_INDEX            =  LV_INDEX                 "nur diesen Eintrag
       CHANGING
         CT_TARGET_VALUES    =  <LFS_TVALUES>            " -> Listboxwerte, anfänglich leer, werden befüllt
      ).
  ENDIF.
*  "KEMPF_S 1/2019
*  "Wenn der Eintrag gewählt wird, dann muss der Wert im Mautknoten entsprechend gesetzt werden.
*  "Das Event feuert auf dem Knoten NODE_MAUT
*  "Der ChildKnoten hat die Selektion dazu.
*  "Damit es nur eine Funktion für alle Listboxen braucht, wird der Knotenname des Unterknotens ermittelt.
*  "Abhängig von der Selektion in der Box, wird es nötig, die entsprechende Box mit der Folge zu befüllen.
*  DATA lv_sub_node_name TYPE STRING.
*  DATA(lv_name) = CONTEXT_ELEMENT->GET_NODE( )->GET_NODE_INFO( )->GET_NAME( ). "DEV
*  DATA lv_value TYPE STRING.
*  CASE lv_name.
*     WHEN 'NODE_VORTRANSPORT'.
*      lv_sub_node_name = 'NODE_VT_FROM_YEAR'.
*     WHEN 'NODE_UEBERNAHME'.
*      lv_sub_node_name = 'NODE_UN_FROM_YEAR'.
*     WHEN 'NODE_MAUT'.
*      lv_sub_node_name = 'NODE_MAUT_FROM_YEAR'.
*    WHEN 'NODE_ECOTAX'.
*      lv_sub_node_name = 'NODE_ETAX_FROM_YEAR'.
*    WHEN OTHERS.
*      RETURN.
*  ENDCASE.
*  DATA(lr_child) = CONTEXT_ELEMENT->GET_CHILD_NODE( LV_SUB_NODE_NAME ).
*  DATA(lr_el)    = lr_child->GET_LEAD_SELECTION( ).
*
*  DATA LO_COMPONENTCONTROLLER TYPE REF TO IG_COMPONENTCONTROLLER .
*  LO_COMPONENTCONTROLLER =   WD_THIS->GET_COMPONENTCONTROLLER_CTR( ).
*
*
**   get all declared attributes
*    lr_el->GET_ATTRIBUTE(
*      EXPORTING
*        NAME  = `ZZABJHR`
*      IMPORTING
*        VALUE = LV_VALUE " DATA
*    ).
*    IF NOT lv_value IS INITIAL.
**       set single attribute
*        CONTEXT_ELEMENT->set_attribute(
*          name =  `ZZABJHR`
*          value = lv_value ).
*        DATA LV_JAHR TYPE ZVDE_JAHR.
*        lv_jahr = lv_value.
*        DATA lt_heftfolge TYPE ZVTT_HEFTFOLGE.
*        LT_HEFTFOLGE = ZCL_HEFTFOLGE=>GET_HEFTFOLGEN_VON_BIS(
*
*        IV_OBJEKT       = '9391'
*        IV_VERMARKTUNG  = '00'
**        IV_AUSGABE      = 0
*        IV_JAHR_VON     = LV_JAHR
**        IV_FOLGE_VON    = IV_FOLGE_VON
**        IV_JAHR_BIS     = IV_JAHR_BIS
**        IV_FOLGE_BIS    = IV_FOLGE_BIS
**        IV_EXKLUSIV_VON = ABAP_FALSE
**        IV_EXKLUSIV_BIS = ABAP_FALSE
*           ).
*
*
**
*
*
*
*    ENDIF.
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method ONACTIONON_SELECT_TO_YEAR .
  "KEMPF_S 1/2019
  "Wenn der Eintrag gewählt wird, dann muss der Wert in anderen Knoten entsprechend gesetzt werden.
  "Das Event feuert z.B. auf dem Knoten NODE_...
  "Der ChildKnoten hat die Selektion dazu.
  "Damit es nur eine Funktion für alle Listboxen braucht, wird der Knotenname des Unterknotens ermittelt.
  "Wenn des von Jahr verändert wird, dann müssen die Listboxen mit den Folgen angepasst werden.
  "Auch das bis Jahr braucht eine Anpassung.
  DATA(LR_NODE) = CONTEXT_ELEMENT->GET_NODE( ).
  DATA(LV_NAME) = CONTEXT_ELEMENT->GET_NODE( )->GET_NODE_INFO( )->GET_NAME( ). "DEV
  DATA: LV_SUB_NODE_NAME        TYPE STRING.
  DATA: LV_TARGET_SUB_NODE_NAME TYPE STRING.      "hier dann ---TO_...
  DATA: LV_FIELD TYPE STRING VALUE `ZZBISJHR`,     "das Feld in der Datenstruktur der Jahreslistbox(bis Jahr).
        LV_VALUE TYPE STRING,
        LV_JAHR  TYPE ZVDE_JAHR,
        LV_FOLGE TYPE ZVDE_FOLGE.
  DATA LR_DATA                  TYPE REF TO DATA.
  DATA LR_VALUES                TYPE REF TO DATA.
  DATA LO_COMPONENTCONTROLLER   TYPE REF TO IG_COMPONENTCONTROLLER .
  FIELD-SYMBOLS: <LFS_TDATA>   TYPE ANY TABLE,
                 <LFS_TVALUES> TYPE ANY TABLE.
  CASE LV_NAME.
    WHEN 'NODE_VORTRANSPORT'.
      LV_SUB_NODE_NAME = 'NODE_VT_TO_YEAR'. "das Jahr wird aus dieser Liste gelesen.
      CREATE DATA LR_DATA   TYPE WD_THIS->ELEMENTS_NODE_VORTRANSPORT.
      CREATE DATA LR_VALUES TYPE WD_THIS->ELEMENTS_NODE_VT_TO_FOLGE. "TO_FOLGE -> weil das der Zielknoten ist
    WHEN 'NODE_UEBERNAHME'.
      LV_SUB_NODE_NAME = 'NODE_UN_TO_YEAR'.
      CREATE DATA LR_DATA TYPE WD_THIS->ELEMENTS_NODE_UEBERNAHME.
      CREATE DATA LR_VALUES TYPE WD_THIS->ELEMENTS_NODE_UN_TO_FOLGE.
    WHEN 'NODE_MAUT'.
      LV_SUB_NODE_NAME = 'NODE_MAUT_TO_YEAR'.
      CREATE DATA LR_DATA TYPE WD_THIS->ELEMENTS_NODE_MAUT.
      CREATE DATA LR_VALUES TYPE WD_THIS->ELEMENTS_NODE_MAUT_TO_FOLGE.
    WHEN 'NODE_ECOTAX'.
      LV_SUB_NODE_NAME = 'NODE_ETAX_TO_YEAR'.
      CREATE DATA LR_DATA TYPE WD_THIS->ELEMENTS_NODE_ECOTAX.
      CREATE DATA LR_VALUES TYPE WD_THIS->ELEMENTS_NODE_ETAX_TO_FOLGE.
    WHEN OTHERS.
      RETURN.
  ENDCASE.
  "Das Ziel ist:
  LV_TARGET_SUB_NODE_NAME = LV_SUB_NODE_NAME.
  "REPLACE '_FROM_' IN LV_TARGET_SUB_NODE_NAME WITH '_TO_'. "dieser soll gesetzt werden, abhängig von unseren Werten.
  REPLACE '_YEAR' IN LV_TARGET_SUB_NODE_NAME WITH '_FOLGE'."Abhängig v. Jahr werden die Folgen gesetzt TO_YEAR -> TO_FOLGE
  LO_COMPONENTCONTROLLER =   WD_THIS->GET_COMPONENTCONTROLLER_CTR( ).
  DATA(LR_YEAR)    = CONTEXT_ELEMENT->GET_CHILD_NODE( LV_SUB_NODE_NAME ).
  DATA(LR_EL_YEAR) = LR_YEAR->GET_LEAD_SELECTION( ).
*   wir brauchen den Wert für das Start-Jahr
  LR_EL_YEAR->GET_ATTRIBUTE(
    EXPORTING
      NAME  = LV_FIELD
    IMPORTING
      VALUE = LV_VALUE " DATA -> string
  ).
  LV_JAHR = LV_VALUE .
    DATA LV_RV_VALUE TYPE STRING.
    LV_RV_VALUE = LV_SUB_NODE_NAME.
    REPLACE '_TO_' IN LV_RV_VALUE WITH '_FROM_'.
    LV_RV_VALUE = WD_THIS->GET_SELECTED(
      IR_EL =   CONTEXT_ELEMENT                          " ref to if_wd_context_element
      IV_FIELDNAME = 'ZZABJHR'
      IV_SUB_NODE_NAME =  LV_RV_VALUE                " csequence
    ).
    IF lv_rv_value = lv_jahr. "dann müssen die Folgen angepasst werden
      "->die aktuell selektierte ab - Folge holen
      LV_RV_VALUE = LV_SUB_NODE_NAME.
      REPLACE '_TO_' IN LV_RV_VALUE WITH '_FROM_'.
      REPLACE 'YEAR' IN LV_RV_VALUE WITH 'FOLGE'.
      LV_RV_VALUE = WD_THIS->GET_SELECTED(
        IR_EL =   CONTEXT_ELEMENT                          " ref to if_wd_context_element
        IV_FIELDNAME = 'ZZABFOLGE'
        IV_SUB_NODE_NAME =  LV_RV_VALUE                " csequence
      ).
      lv_folge = LV_RV_VALUE.
    ENDIF.
  "Der Wert wird eingesetzt, damit dieser beim späteren Speichern verfügbar ist
  IF NOT LV_VALUE IS INITIAL.
    CONTEXT_ELEMENT->SET_ATTRIBUTE(
      NAME =  LV_FIELD
      VALUE = LV_VALUE ).
    ASSIGN LR_DATA->* TO <LFS_TDATA>.
    ASSIGN LR_VALUES->* TO <LFS_TVALUES>.
*    LR_NODE->GET_STATIC_ATTRIBUTES_TABLE( IMPORTING TABLE = <LFS_TDATA> ).
    DATA(lv_index) = CONTEXT_ELEMENT->GET_INDEX( ).
  "es wird nur der geänderte Eintrag aktualisiert.
    LR_NODE->GET_STATIC_ATTRIBUTES_TABLE(
*      EXPORTING
*        FROM  = lv_index          " Web Dynpro: Index eines Kontext Elementes
*        TO    = lv_index " Web Dynpro: Index eines Kontext Elementes
      IMPORTING
        TABLE = <LFS_TDATA>
    ).
    "die abhängige Listbox ist die bis-Folge
    LO_COMPONENTCONTROLLER->FILL_LB_FOLGE(
        EXPORTING
          NODE = LR_NODE                                 "Referenz zu dem Knoten mit den Daten.
*            PARENT_ELEMENT =                            " obsolet
         IV_JAHR             =  LV_JAHR                  " zvde_jahr
         IV_START_FOLGE      =  LV_FOLGE
         IV_TARGET_NODE_NAME =  LV_TARGET_SUB_NODE_NAME  " csequence
         IV_DATA_FIELD       =  'ZZBISFOLGE'              " csequence
         IV_VALUE_FIELD      =  'ZZBISFOLGE'              " csequence
         IT_NODE_DATA        =  <LFS_TDATA>              " daten des Knotens
         IV_INDEX            =  LV_INDEX                 "nur diesen Eintrag
       CHANGING
         CT_TARGET_VALUES    =  <LFS_TVALUES>            " -> Listboxwerte, anfänglich leer, werden befüllt
      ).
  ENDIF.
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method ONACTIONADD_TRANSPORT_COST .
    DATA  lo_el_node       TYPE REF TO if_wd_context_element.
    DATA: ls_node_v        TYPE wd_this->Element_node_vortransport,
          lt_node_v        TYPE TABLE OF wd_this->Element_node_vortransport,
          lt_node_v_lb     TYPE TABLE OF wd_this->ELEMENT_NODE_VORTRANSPORT_LB.
    DATA: ls_node_m        TYPE wd_this->Element_node_maut,
          lt_node_m        TYPE TABLE OF wd_this->Element_node_maut,
          lt_node_m_lb     TYPE TABLE OF wd_this->ELEMENT_NODE_MAUT_PERC.
    DATA: ls_node_u        TYPE wd_this->Element_node_uebernahme,
          lt_node_u        TYPE TABLE OF wd_this->Element_node_uebernahme,
          lt_node_u_lb     TYPE TABLE OF wd_this->ELEMENT_NODE_UEBERNAHME_LB.
    DATA: ls_node_e        TYPE wd_this->Element_node_ecotax,
          lt_node_e        TYPE TABLE OF wd_this->Element_node_ecotax. .
    DATA  lo_nd_node_val   TYPE REF TO if_wd_context_node.
    DATA: ls_node_maut     TYPE wd_this->Element_node_maut,
          lv_node_name     type string,
          lv_key_data      type string,
          lv_key_value     TYPE STRING .
  "noch auszubauen -> abhängig v. aktiven Tab wird eine aktion durchgeführt.
  "Das aktive Tab is in MV_ACTIVE_TAB gespeichert.
    DATA lo_nd_node        TYPE REF TO if_wd_context_node.
    DATA lo_nd_node_values TYPE REF TO if_wd_context_node.
    DATA lr_node           TYPE REF TO DATA.
    FIELD-SYMBOLS: <lfs_tdata>  TYPE TABLE,
                   <lfs_tvalue> TYPE TABLE.
      CASE me->WD_THIS->MV_TCOST_ACTIVE_TAB.
         WHEN 'TAB_VORTRANSPORT'.
            lo_nd_node = wd_context->path_get_node( path = `NODE_TRANS_COST.NODE_VORTRANSPORT` ).
            lo_el_node = lo_nd_node->get_element( ).
            ASSIGN lt_node_v TO <lfs_tdata>.
            LV_NODE_NAME      = 'NODE_VORTRANS_VALUE'.  "der Unter-Knoten in der Data Struktuer(nicht Listbox)
            LV_KEY_DATA       = `ZZBETRAG_VORTRANSPORT` .       "der Name des Feldes in der Tabelle der Daten
            LV_KEY_VALUE      = `BETRAG_STRING`.
            lo_nd_node_values =  wd_context->path_get_node( path = `NODE_TRANS_COST.NODE_VORTRANSPORT_LB` )." LO_EL_NODE->GET_CHILD_NODE( 'NODE_MAUT_VALUES' ).
            ASSIGN lt_node_v_LB TO <lfs_tvalue>.
            lo_nd_node_values->get_static_attributes_table( importing table = <lfs_tvalue> ).
          WHEN 'TAB_MAUT'.
            lo_nd_node = wd_context->path_get_node( path = `NODE_TRANS_COST.NODE_MAUT` ).
            lo_el_node = lo_nd_node->get_element( ).
            ASSIGN lt_node_m TO <lfs_tdata>.
            LV_NODE_NAME      = 'NODE_MAUT_VALUES'. "der Unter-Knoten in der Data Struktuer(nicht Listbox)
            LV_KEY_DATA       = `ZZPERCENT_MAUT` .       "der Name des Feldes in der Tabelle der Daten
            LV_KEY_VALUE      = `PERCENT`.
            lo_nd_node_values =  wd_context->path_get_node( path = `NODE_TRANS_COST.NODE_MAUT_PERC` )." LO_EL_NODE->GET_CHILD_NODE( 'NODE_MAUT_VALUES' ).
            ASSIGN lt_node_m_LB TO <lfs_tvalue>.
            lo_nd_node_values->get_static_attributes_table( importing table = <lfs_tvalue> ).
           WHEN 'TAB_UEBERNAHME'.
             lo_nd_node = wd_context->path_get_node( path = `NODE_TRANS_COST.NODE_UEBERNAHME` ).
             lo_el_node = lo_nd_node->get_element( ).
             ASSIGN lt_node_u TO <lfs_tdata>.
             LV_NODE_NAME      = 'NODE_UEBERNAHME_VAL'.  "der Unter-Knoten in der Data Struktuer(nicht Listbox)
             LV_KEY_DATA       = `ZZBETRAG_UEBERNAHME_SATZ` .       "der Name des Feldes in der Tabelle der Daten
             LV_KEY_VALUE      = `BETRAG_STRING`.
             lo_nd_node_values =  wd_context->path_get_node( path = `NODE_TRANS_COST.NODE_UEBERNAHME_LB` )." LO_EL_NODE->GET_CHILD_NODE( 'NODE_MAUT_VALUES' ).
             ASSIGN lt_node_u_LB TO <lfs_tvalue>.
             lo_nd_node_values->get_static_attributes_table( importing table = <lfs_tvalue> ).
           WHEN 'TAB_ECOTAX'.
              lo_nd_node = wd_context->path_get_node( path = `NODE_TRANS_COST.NODE_ECOTAX` ).
              lo_el_node = lo_nd_node->get_element( ).
              ASSIGN lt_node_e TO <lfs_tdata>.
      ENDCASE.
      "wenn der Knoten erfolgreich verarbeitet wurde, dann eine neue Zeile anhängen
      IF lo_nd_node IS BOUND.
        lo_nd_node->get_static_attributes_table( importing table = <lfs_tdata> ). "Daten in interne Tabelle holen.
        APPEND INITIAL LINE TO <lfs_tdata> ASSIGNING FIELD-SYMBOL(<lfs_data>).    "Einen neuen Eintrag hinzufügen
        lo_nd_node->bind_table( new_items = <lfs_tdata> set_initial_elements = abap_true ).
"        lo_nd_node_values->bind_table( new_items = <lfs_tvalue> set_initial_elements = abap_true ).
        "Für das neue element muss eine Listbox angeschlossen werden.
        IF lo_nd_node IS BOUND AND lo_nd_node_values IS BOUND.
          "dieses füllt die Listbox mit den auswählbaren Kosten.
          "Die Jahr/Folge Listboxen werden separat befüllt.
          me->WD_COMP_CONTROLLER->TRANSCOST_ASSOCIATE_LISTBOX(
              exporting
                IO_NODE_DATA    = lo_nd_node
                IO_NODE_VALUES  = lo_nd_node_values
                IV_NODE_NAME    = LV_NODE_NAME "lo_nd_node_values->GET_NODE_INFO( )->GET_NAME( )   "
                IV_DATA_FIELD   = LV_KEY_DATA        "der Name des Feldes in der Tabelle der Daten
                IV_VALUE_FIELD  = LV_KEY_VALUE
                IT_DATA =   <lfs_tdata>
                IT_VALUES = <lfs_tvalue>
            ).
         ENDIF.
      ENDIF.
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
METHOD ONACTIONON_SELECT_FROM_FOLGE .
  "KEMPF_S 1/2019
  "Wenn der Eintrag gewählt wird, dann muss der Wert im Mautknoten entsprechend gesetzt werden.
  "Das Event feuert z.B. auf dem Knoten NODE_MAUT
  "Der ChildKnoten hat die Selektion dazu.
  "Damit es nur eine Funktion für alle Listboxen braucht, wird der Knotenname des Unterknotens ermittelt.
  DATA(LR_NODE) = CONTEXT_ELEMENT->GET_NODE( ).
  DATA(LV_NAME) = CONTEXT_ELEMENT->GET_NODE( )->GET_NODE_INFO( )->GET_NAME( ). "DEV
  DATA: LV_SUB_NODE_NAME        TYPE STRING.
  DATA: LV_TARGET_SUB_NODE_NAME TYPE STRING.      "hier dann ---TO_FOLGE
  DATA: LV_FIELD TYPE STRING VALUE `ZZABFOLGE`,
        LV_VALUE TYPE STRING,
        LV_JAHR  TYPE ZVDE_JAHR,
        LV_FOLGE TYPE ZVDE_FOLGE.
  DATA LR_DATA                  TYPE REF TO DATA.
  DATA LR_VALUES                TYPE REF TO DATA.
  DATA LO_COMPONENTCONTROLLER   TYPE REF TO IG_COMPONENTCONTROLLER .
  FIELD-SYMBOLS: <LFS_TDATA>   TYPE ANY TABLE,
                 <LFS_TVALUES> TYPE ANY TABLE.
  CASE LV_NAME.
    WHEN 'NODE_VORTRANSPORT'.
      LV_SUB_NODE_NAME = 'NODE_VT_FROM_FOLGE'.
      CREATE DATA LR_DATA   TYPE WD_THIS->ELEMENTS_NODE_VORTRANSPORT.
      CREATE DATA LR_VALUES TYPE WD_THIS->ELEMENTS_NODE_VT_TO_FOLGE. "TO_FOLGE -> weil das der Zielknoten ist
    WHEN 'NODE_UEBERNAHME'.
      LV_SUB_NODE_NAME = 'NODE_UN_FROM_FOLGE'.
      CREATE DATA LR_DATA TYPE WD_THIS->ELEMENTS_NODE_UEBERNAHME.
      CREATE DATA LR_VALUES TYPE WD_THIS->ELEMENTS_NODE_UN_TO_FOLGE.
    WHEN 'NODE_MAUT'.
      LV_SUB_NODE_NAME = 'NODE_MAUT_FROM_FOLGE'.
      CREATE DATA LR_DATA   TYPE WD_THIS->ELEMENTS_NODE_MAUT.
      CREATE DATA LR_VALUES TYPE WD_THIS->ELEMENTS_NODE_MAUT_TO_FOLGE.
    WHEN 'NODE_ECOTAX'.
      LV_SUB_NODE_NAME = 'NODE_ETAX_FROM_FOLGE'.
      CREATE DATA LR_DATA   TYPE WD_THIS->ELEMENTS_NODE_ECOTAX.
      CREATE DATA LR_VALUES TYPE WD_THIS->ELEMENTS_NODE_ETAX_TO_FOLGE.
    WHEN OTHERS.
      RETURN.
  ENDCASE.
  LV_TARGET_SUB_NODE_NAME = LV_SUB_NODE_NAME.
  REPLACE '_FROM_' IN LV_TARGET_SUB_NODE_NAME WITH '_TO_'. "dieser soll gesetzt werden, abhängig von unseren Werten.
  LO_COMPONENTCONTROLLER =   WD_THIS->GET_COMPONENTCONTROLLER_CTR( ).
  DATA(LR_FOLGE)    = CONTEXT_ELEMENT->GET_CHILD_NODE( LV_SUB_NODE_NAME ).
  DATA(LR_EL_FOLGE) = LR_FOLGE->GET_LEAD_SELECTION( ).
  REPLACE '_FOLGE' IN LV_SUB_NODE_NAME WITH '_YEAR'. "'NODE_MAUT_FROM_FOLGE' -> 'NODE_MAUT_FROM_YEAR'
  DATA(LR_JAHR)       = CONTEXT_ELEMENT->GET_CHILD_NODE( LV_SUB_NODE_NAME ).
  DATA(LR_EL_JAHR)    = LR_JAHR->GET_LEAD_SELECTION( ).
  IF LR_EL_JAHR IS INITIAL. "die Selektion ist damit ungültig und muss zurückgesetzt wreden
    "+Meldung
    LR_FOLGE->SET_LEAD_SELECTION_INDEX( -1 ). "die Folge zurücksetzen
    RETURN.
  ENDIF.
  "WENN DAS JAHR NOCH NICHT GESETZT IST, DANN KANN KEINE FOLGE AUSGEWÄHLT WERDEN.
  LR_EL_JAHR->GET_ATTRIBUTE(
    EXPORTING
      NAME  = 'ZZABJHR'
    IMPORTING
      VALUE = LV_VALUE " DATA -> string
  ).
  lv_jahr = lv_value. "typgerecht umkopieren
*   wir brauchen die Ab-Folge
  LR_EL_FOLGE->GET_ATTRIBUTE(
    EXPORTING
      NAME  = LV_FIELD
    IMPORTING
      VALUE = LV_VALUE " DATA -> string
  ).
  LV_FOLGE = LV_VALUE .
  "Der Wert wird eingesetzt, damit dieser beim späteren Speichern verfügbar ist
  IF NOT LV_VALUE IS INITIAL.
    CONTEXT_ELEMENT->SET_ATTRIBUTE(
      NAME =  LV_FIELD
      VALUE = LV_VALUE ).
    ASSIGN LR_DATA->* TO <LFS_TDATA>.
    ASSIGN LR_VALUES->* TO <LFS_TVALUES>.
*    LR_NODE->GET_STATIC_ATTRIBUTES_TABLE( IMPORTING TABLE = <LFS_TDATA> ).
    DATA(lv_index) = CONTEXT_ELEMENT->GET_INDEX( ).
  "es wird nur der geänderte Eintrag aktualisiert.
    LR_NODE->GET_STATIC_ATTRIBUTES_TABLE(
*      EXPORTING
*        FROM  = lv_index          " Web Dynpro: Index eines Kontext Elementes
*        TO    = lv_index " Web Dynpro: Index eines Kontext Elementes
      IMPORTING
        TABLE = <LFS_TDATA>
    ).
    "Die Listboxwerte f. Bis-Folge wird aktualisiert.
    LO_COMPONENTCONTROLLER->FILL_LB_FOLGE(
    EXPORTING
      NODE = LR_NODE                                 "Referenz zu dem Knoten mit den Daten.
*        PARENT_ELEMENT =                            " obsolet
     IV_JAHR             =  LV_JAHR                  " zvde_jahr
     IV_START_FOLGE      =  LV_FOLGE
     IV_TARGET_NODE_NAME =  LV_TARGET_SUB_NODE_NAME  " csequence
     IV_DATA_FIELD       =  'ZZBISFOLGE'             " csequence
     IV_VALUE_FIELD      =  'ZZBISFOLGE'             " csequence
     IT_NODE_DATA        =  <LFS_TDATA>              " daten des Knotens
     IV_INDEX            =  LV_INDEX                 "nur diesen Eintrag
   CHANGING
     CT_TARGET_VALUES    =  <LFS_TVALUES>            " -> Listboxwerte, anfänglich leer, werden befüllt
  ).
  ENDIF.
ENDMETHOD.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method FILL_LB_VORTRANSPORT.
  DATA lo_nd_node TYPE REF TO if_wd_context_node.
  DATA lt_node TYPE wd_this->Elements_node_vortransport_lb.
* navigate from <CONTEXT> to <NODE_MAUT_PERC> via lead selection
  lo_nd_node = wd_context->path_get_node( path = `NODE_TRANS_COST.NODE_VORTRANSPORT_LB` ).
 IF lo_nd_node IS INITIAL.
   "+Fehlermeldung
    RETURN.
 ENDIF.
  IF lo_nd_node IS INITIAL.
    "+Fehlermeldung
    RETURN.
  ENDIF.
" Daten aus der Customizing Tabelle holen.
DATA LT_VALUES   TYPE ZVTTRANS_VRTR_BTR.
DATA LT_RETURN   TYPE ZVTT_RETURN.
      CALL FUNCTION 'Z_V_LOOKUP_VT_VALUES_BL'
       IMPORTING
         ET_VALUES         = LT_VALUES
         ET_RETURN         = LT_RETURN
                .
  LOOP AT   lt_values ASSIGNING FIELD-SYMBOL(<lfs_value>).
      APPEND INITIAL LINE TO lt_node ASSIGNING FIELD-SYMBOL(<lfs_data>).
      <lfs_data>-BETRAG_STRING = <lfs_value>-BETRAG.
  ENDLOOP.
  IF NOT lo_nd_node IS INITIAL.
    lo_nd_node->bind_table( new_items = lt_node set_initial_elements = abap_true ).
  ENDIF.
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method FILL_LB_UEBERNAHME.
  DATA lo_nd_node TYPE REF TO if_wd_context_node.
  DATA lt_node TYPE wd_this->Elements_node_vortransport_lb.
* navigate from <CONTEXT> to <NODE_MAUT_PERC> via lead selection
  lo_nd_node = wd_context->path_get_node( path = `NODE_TRANS_COST.NODE_UEBERNAHME_LB` ).
 IF lo_nd_node IS INITIAL.
   "+Fehlermeldung
    RETURN.
 ENDIF.
  IF lo_nd_node IS INITIAL.
    "+Fehlermeldung
    RETURN.
  ENDIF.
DATA LT_VALUES TYPE ZVTTRANS_UBRN_BTR.
DATA LT_RETURN TYPE ZVTT_RETURN.
  CALL FUNCTION 'Z_V_LOOKUP_UN_VALUES_BL'
   IMPORTING
     ET_VALUES       = LT_VALUES
     ET_RETURN       = LT_RETURN
            .
*" Daten aus der Customizing Tabelle holen.
*  SELECT * FROM ZVTRANS_UBRN_BTR INTO @DATA(ls_data).
  LOOP AT LT_VALUES ASSIGNING FIELD-SYMBOL(<lfs_value>).
      APPEND INITIAL LINE TO lt_node ASSIGNING FIELD-SYMBOL(<lfs_data>).
      <lfs_data>-BETRAG_STRING = <lfs_value>-BETRAG.
  ENDLOOP.
  IF NOT lo_nd_node IS INITIAL.
    lo_nd_node->bind_table( new_items = lt_node set_initial_elements = abap_true ).
  ENDIF.
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method FILL_LB_MAUT_PERC.
  DATA lo_nd_node_maut_perc TYPE REF TO if_wd_context_node.
  DATA lt_node_maut_perc TYPE wd_this->Elements_node_maut_perc.
* navigate from <CONTEXT> to <NODE_MAUT_PERC> via lead selection
  lo_nd_node_maut_perc = wd_context->path_get_node( path = `NODE_TRANS_COST.NODE_MAUT_PERC` ).
 IF lo_nd_node_maut_perc IS INITIAL.
   "+Fehlermeldung
    RETURN.
 ENDIF.
  IF lo_nd_node_maut_perc IS INITIAL.
    "+Fehlermeldung
    RETURN.
  ENDIF.
DATA LT_VALUES TYPE ZVTTRANS_MAUT_PER.
DATA LT_RETURN TYPE ZVTT_RETURN.
  CALL FUNCTION 'Z_V_LOOKUP_MAUT_VALUES_BL'
   IMPORTING
     ET_VALUES       = LT_VALUES
     ET_RETURN       = LT_RETURN
            .
  LOOP AT LT_VALUES ASSIGNING FIELD-SYMBOL(<lfs_value>).
      APPEND INITIAL LINE TO lt_node_maut_perc ASSIGNING FIELD-SYMBOL(<lfs_m>).
      <lfs_m>-PERCENT = <lfs_value>-PROZENT.
  ENDLOOP.
  IF NOT lo_nd_node_maut_perc IS INITIAL.
    lo_nd_node_maut_perc->bind_table( new_items = lt_node_maut_perc set_initial_elements = abap_true ).
  ENDIF.
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
METHOD TRANSCOST_SAVE_ALL .
  CONSTANTS: LC_DELETE TYPE I VALUE 3.
  "ausgelagert f. Speichern der Transportkosten
  DATA:
    LV_COMMIT TYPE  ZVDE_BOOL,
    LT_RET    TYPE  ZVTT_RETURN.
  DATA LO_ND_NODE_VORTRANS_DDK   TYPE REF TO IF_WD_CONTEXT_NODE.
  DATA LT_NODE_VORTRANS_DDK      TYPE WD_THIS->ELEMENTS_NODE_VORTRANS_DDK.
  DATA LO_ND_NODE_ECOTAX_DDK     TYPE REF TO IF_WD_CONTEXT_NODE.
  DATA LT_NODE_ECOTAX_DDK        TYPE WD_THIS->ELEMENTS_NODE_ECOTAX_DDK.
  DATA LO_ND_NODE_MAUT_DDK       TYPE REF TO IF_WD_CONTEXT_NODE.
  DATA LT_NODE_MAUT_DDK          TYPE WD_THIS->ELEMENTS_NODE_MAUT_DDK.
  DATA LO_ND_NODE_UEBERNAHME_DDK TYPE REF TO IF_WD_CONTEXT_NODE.
  DATA LT_NODE_UEBERNAHME_DDK    TYPE WD_THIS->ELEMENTS_NODE_UEBERNAHME_DDK.
*   navigate from <CONTEXT> to <NODE_VORTRANS_DDK> via lead selection
  LO_ND_NODE_VORTRANS_DDK = WD_CONTEXT->PATH_GET_NODE( PATH = `NODE_TRANS_COST.NODE_VORTRANS_DDK` ).
*   diese sind zum löschen
  IF NOT LO_ND_NODE_VORTRANS_DDK IS INITIAL.
    LO_ND_NODE_VORTRANS_DDK->GET_STATIC_ATTRIBUTES_TABLE( IMPORTING TABLE = LT_NODE_VORTRANS_DDK ).
  ENDIF.
*    navigate from <CONTEXT> to <NODE_MAUT_DDK> via lead selection
  LO_ND_NODE_MAUT_DDK = WD_CONTEXT->PATH_GET_NODE( PATH = `NODE_TRANS_COST.NODE_MAUT_DDK` ).
  IF NOT LO_ND_NODE_MAUT_DDK IS INITIAL.
    LO_ND_NODE_MAUT_DDK->GET_STATIC_ATTRIBUTES_TABLE( IMPORTING TABLE = LT_NODE_MAUT_DDK ).
  ENDIF.
*   navigate from <CONTEXT> to <NODE_UEBERNAHME_DDK> via lead selection
  LO_ND_NODE_UEBERNAHME_DDK = WD_CONTEXT->PATH_GET_NODE( PATH = `NODE_TRANS_COST.NODE_UEBERNAHME_DDK` ).
  IF NOT LO_ND_NODE_UEBERNAHME_DDK IS INITIAL.
    LO_ND_NODE_UEBERNAHME_DDK->GET_STATIC_ATTRIBUTES_TABLE( IMPORTING TABLE = LT_NODE_UEBERNAHME_DDK ).
  ENDIF.
* navigate from <CONTEXT> to <NODE_ECOTAX_DDK> via lead selection
  LO_ND_NODE_ECOTAX_DDK = WD_CONTEXT->PATH_GET_NODE( PATH = `NODE_TRANS_COST.NODE_ECOTAX_DDK` ).
* @TODO handle non existant child
* IF lo_nd_node_ecotax_ddk IS INITIAL.
* ENDIF.
  LO_ND_NODE_ECOTAX_DDK->GET_STATIC_ATTRIBUTES_TABLE( IMPORTING TABLE = LT_NODE_ECOTAX_DDK ).
  LOOP AT LT_NODE_VORTRANS_DDK INTO DATA(LS_V)  WHERE ACTION = LC_DELETE.
    CALL FUNCTION 'ZV_DELETE_OBJV_TRANSCOST_MAPI'
      EXPORTING
        IS_VORTRANSPORT = LS_V
        IV_LOCK         = ABAP_FALSE "nicht mehr sperren
      IMPORTING
        E_COMMIT        = EV_COMMIT
        E_TAB_RETURN    = LT_RET.
    APPEND LINES OF LT_RET TO ET_RET.
  ENDLOOP.
  DELETE  LT_NODE_VORTRANS_DDK WHERE ACTION = LC_DELETE.
  LOOP AT LT_NODE_UEBERNAHME_DDK INTO DATA(LS_U) WHERE ACTION = LC_DELETE.
    CALL FUNCTION 'ZV_DELETE_OBJV_TRANSCOST_MAPI'
      EXPORTING
        IS_UEBERNAHME = LS_U
        IV_LOCK       = ABAP_FALSE "nicht mehr sperren
      IMPORTING
        E_COMMIT      = EV_COMMIT
        E_TAB_RETURN  = LT_RET.
    APPEND LINES OF LT_RET TO ET_RET.
    CLEAR LS_U-ACTION .
    MODIFY LT_NODE_UEBERNAHME_DDK FROM LS_U.
  ENDLOOP.
  DELETE LT_NODE_UEBERNAHME_DDK WHERE ACTION = LC_DELETE.
  LOOP AT LT_NODE_MAUT_DDK INTO DATA(LS_M)  WHERE ACTION = LC_DELETE.
    CALL FUNCTION 'ZV_DELETE_OBJV_TRANSCOST_MAPI'
      EXPORTING
        IS_MAUT      = LS_M
        IV_LOCK      = ABAP_FALSE "nicht mehr sperren
      IMPORTING
        E_COMMIT     = EV_COMMIT
        E_TAB_RETURN = LT_RET.
    APPEND LINES OF LT_RET TO ET_RET.
    CLEAR LS_M-ACTION .
    MODIFY LT_NODE_MAUT_DDK FROM LS_M.
  ENDLOOP.
  DELETE LT_NODE_MAUT_DDK WHERE ACTION = LC_DELETE.
  LOOP AT LT_NODE_ECOTAX_DDK INTO DATA(LS_E)  WHERE ACTION = LC_DELETE.
    CALL FUNCTION 'ZV_DELETE_OBJV_TRANSCOST_MAPI'
      EXPORTING
        IS_ECOTAX    = LS_E
        IV_LOCK      = ABAP_FALSE "nicht mehr sperren
      IMPORTING
        E_COMMIT     = EV_COMMIT
        E_TAB_RETURN = LT_RET.
  ENDLOOP.
  DELETE LT_NODE_ECOTAX_DDK WHERE ACTION = LC_DELETE.
    "Batch Check f. Intervalle: alle Tabellen
  CALL FUNCTION 'ZV_TRANSCOST_CHECK_INTERVALS'
    EXPORTING
      IT_UEBERNAHME   = IT_UEBERNAHME
      IT_VORTRANSPORT = IT_VORTRANSPORT
      IT_MAUT         = IT_MAUT
      IT_ECOTAX       = IT_ECOTAX
    IMPORTING
      ET_RET  = ET_RET.
  APPEND LINES OF LT_RET TO ET_RET.
  "Ökosteuer
  LOOP AT IT_ECOTAX INTO LS_E.
    LS_E-ZZOBJEK = IV_OBJ.
    LS_E-ZZVERM  = IV_VERMARKTUNG.
    CALL FUNCTION 'ZV_SAVE_OBJV_TRANSCOST_MAPI'
      EXPORTING
        IS_ECOTAX    = LS_E
        IV_LOCK      = ABAP_FALSE "nicht mehr sperren
        IV_ROW                = sy-tabix
      IMPORTING
        E_COMMIT     = EV_COMMIT
        E_TAB_RETURN = LT_RET.
  ENDLOOP.
  "Maut
  LOOP AT IT_MAUT INTO LS_M.
    LS_M-ZZOBJEK = IV_OBJ.
    LS_M-ZZVERM  = IV_VERMARKTUNG.
    CALL FUNCTION 'ZV_SAVE_OBJV_TRANSCOST_MAPI'
      EXPORTING
        IS_MAUT      = LS_M
        IV_LOCK      = ABAP_FALSE "nicht mehr sperren
        IV_ROW                = sy-tabix
      IMPORTING
        E_COMMIT     = EV_COMMIT
        E_TAB_RETURN = LT_RET.
    APPEND LINES OF LT_RET TO ET_RET.
  ENDLOOP.
*Übernahmekosten+
  LOOP AT IT_UEBERNAHME  INTO LS_U.
    LS_U-ZZOBJEK = IV_OBJ.
    LS_U-ZZVERM  = IV_VERMARKTUNG.
    CALL FUNCTION 'ZV_SAVE_OBJV_TRANSCOST_MAPI'
      EXPORTING
        IS_UEBERNAHME = LS_U
        IV_LOCK       = ABAP_FALSE "nicht mehr sperren
        IV_ROW                = sy-tabix
      IMPORTING
        E_COMMIT      = EV_COMMIT
        E_TAB_RETURN  = LT_RET.
    APPEND LINES OF LT_RET TO ET_RET.
  ENDLOOP.
*Vortransport Kosten
  LOOP AT IT_VORTRANSPORT INTO LS_V.
    LS_V-ZZOBJEK = IV_OBJ.
    LS_V-ZZVERM  = IV_VERMARKTUNG.
    CALL FUNCTION 'ZV_SAVE_OBJV_TRANSCOST_MAPI'
      EXPORTING
        IS_VORTRANSPORT = LS_V
        IV_LOCK         = ABAP_FALSE "nicht mehr sperren
        IV_ROW          = sy-tabix
      IMPORTING
        E_COMMIT        = EV_COMMIT
        E_TAB_RETURN    = LT_RET.
    APPEND LINES OF LT_RET TO ET_RET.
  ENDLOOP.
  me->PRINT_ALL_RETURN_MESSAGES( et_ret ).
ENDMETHOD.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method sc_save_obj_versand .
* declarations for context navigation
  data:
    node_save_obj_versand   type ref to if_wd_context_node.
  data:
    node_exporting_save   type ref to if_wd_context_node.
  data:
    node_e_tab_return   type ref to if_wd_context_node.
* declarations for fuba parameters
  data:
    attr_e_commit    type zvde_bool.
  data:
    itab_c_e_tab_return    type if_componentcontroller=>elements_e_tab_return,
    stru_c_e_tab_return    like line of itab_c_e_tab_return,
    itab_f_e_tab_return    type zvtt_return.
  field-symbols:
    <stru_f_e_tab_return>    like line of itab_f_e_tab_return.
*  DATA:
*    stru_c_i_str_object    TYPE if_componentcontroller=>element_i_str_object.
* Map Objekt
  data lstr_objekt type zvst_objekt.
  lstr_objekt = str_object.
* Map Aufklebertyp
  data lo_nd_value_sets type ref to if_wd_context_node.
  data lo_el_value_sets type ref to if_wd_context_element.
  data ls_value_sets type wd_this->element_value_sets.
  data lv_aufklebertyp_ddk type wd_this->element_value_sets-aufklebertyp_ddk.
  lo_nd_value_sets = wd_context->get_child_node( name = wd_this->wdctx_value_sets ).
  lo_el_value_sets = lo_nd_value_sets->get_element( ).
  lo_el_value_sets->get_attribute(
    exporting
      name =  `AUFKLEBERTYP_DDK`
    importing
      value = lv_aufklebertyp_ddk ).
  lstr_objekt-vs_aufkleber_typ = lv_aufklebertyp_ddk.
* Map Ansprechpartner
  data lv_spedition_nr type wd_this->element_spdn_ansprechpartner-spedition_nr.
  data lv_ansprechpartner_id type wd_this->element_spdn_ansprechpartner-ansprechpartner_id.
  data lv_string type string.
  wd_context->get_child_node( name = wd_this->wdctx_spdn_ansprechpartner )->get_element( )->get_attribute(
    exporting
      name =  `ANSPRECHPARTNER_ID`
    importing
      value = lv_ansprechpartner_id ).
  wd_context->get_child_node( name = wd_this->wdctx_spdn_ansprechpartner )->get_element( )->get_attribute(
    exporting
      name =  `SPEDITION_NR`
    importing
      value = lv_spedition_nr ).
  concatenate lv_spedition_nr lv_ansprechpartner_id into lv_string.
  lstr_objekt-zzspd_apartner_lfdnr = lv_string.
* get all involved child nodes
  node_save_obj_versand = wd_context->get_child_node( `SAVE_OBJ_VERSAND` ).
  node_exporting_save = node_save_obj_versand->get_child_node( `EXPORTING_SAVE` ).
  node_e_tab_return = node_exporting_save->get_child_node( `E_TAB_RETURN` ).
* the invocation - errors are always fatal !!!
  call function 'ZV_SAVE_OBJ_VERSAND_MAPI'
    exporting
      i_str_object = lstr_objekt
    importing
      e_commit     = e_commit
      e_tab_return = itab_c_e_tab_return.
*
* Get Druckereiobj
*
  data lv_objekt type zvst_objekt-objekt.
  data lstr_druckereiobj type zvst_druckereiobj.
  lv_objekt = str_object-objekt.
  data lo_nd_druck_ansprechprtnr type ref to if_wd_context_node.
  data lt_druck_ansprechprtnr type wd_this->elements_druck_ansprechprtnr.
  "2018 - KEMPF_S Transportkosten
    DATA lo_nd_node_uebernahme   TYPE REF TO if_wd_context_node.
    DATA lt_node_uebernahme      TYPE wd_this->Elements_node_uebernahme.
    DATA lo_nd_node_ecotax       TYPE REF TO if_wd_context_node.
    DATA lt_node_ecotax          TYPE wd_this->Elements_node_ecotax.
    DATA lo_nd_node_vortransport TYPE REF TO if_wd_context_node.
    DATA lt_node_vortransport    TYPE wd_this->Elements_node_vortransport.
    DATA lo_nd_node_maut         TYPE REF TO if_wd_context_node.
    DATA lt_node_maut            TYPE wd_this->Elements_node_maut.
    lo_nd_node_maut = wd_context->path_get_node( path = `NODE_TRANS_COST.NODE_MAUT` ).
    lo_nd_node_maut->get_static_attributes_table( importing table = lt_node_maut ).
*     navigate from <CONTEXT> to <NODE_UEBERNAHME> via lead selection
    lo_nd_node_uebernahme = wd_context->path_get_node( path = `NODE_TRANS_COST.NODE_UEBERNAHME` ).
*     @TODO handle non existant child
     IF not lo_nd_node_uebernahme IS INITIAL.
        lo_nd_node_uebernahme->get_static_attributes_table( importing table = lt_node_uebernahme ).
     ENDIF.
*   navigate from <CONTEXT> to <NODE_ECOTAX> via lead selection
     lo_nd_node_ecotax = wd_context->path_get_node( path = `NODE_TRANS_COST.NODE_ECOTAX` ).
     IF NOT lo_nd_node_ecotax IS INITIAL.
       lo_nd_node_ecotax->get_static_attributes_table( importing table = lt_node_ecotax ).
     ENDIF.
*     navigate from <CONTEXT> to <NODE_VORTRANSPORT> via lead selection
    lo_nd_node_vortransport = wd_context->path_get_node( path = `NODE_TRANS_COST.NODE_VORTRANSPORT` ).
     IF NOT lo_nd_node_vortransport IS INITIAL.
      lo_nd_node_vortransport->get_static_attributes_table( importing table = lt_node_vortransport ).
     ENDIF.
   "->nur vorläufig - werte müssen z.T. aus den Listboxen kommen
  "DATA(lv_objekt) = me->GET_OBJECT_ID( ).
   DATA lv_vermarktung TYPE ZVDE_VERMARKTUNG.
   LV_VERMARKTUNG = me->WD_THIS->GET_VERMARKTUNG( lv_objekt ).
   me->TRANSCOST_SAVE_ALL(
     exporting
       IV_VERMARKTUNG  = lv_vermarktung
       IV_OBJ          = lv_objekt
       IT_MAUT         = lt_node_maut
       IT_UEBERNAHME   = lt_node_uebernahme
       IT_VORTRANSPORT = LT_NODE_VORTRANSPORT
       IT_ECOTAX       = lt_node_ecotax
     IMPORTING
       et_ret          = itab_c_e_tab_return
   ).
  lo_nd_druck_ansprechprtnr = wd_context->get_child_node( name = wd_this->wdctx_druck_ansprechprtnr ).
  lo_nd_druck_ansprechprtnr->get_static_attributes_table( importing table = lt_druck_ansprechprtnr ).
  data lo_el_druck_ansprechprtnr type ref to if_wd_context_element.
  data ls_druck_ansprechprtnr type wd_this->element_druck_ansprechprtnr.
*
*   Zu löschende Elemente aus DDK holen
*
  data lo_nd_druckort_anspr_ddk type ref to if_wd_context_node.
  data lt_druckort_anspr_ddk type wd_this->elements_druckort_anspr_ddk.
  data ls_druck_ansprechprtnr_ddk type wd_this->element_druckort_anspr_ddk.
  lo_nd_druckort_anspr_ddk = wd_context->get_child_node( name = wd_this->wdctx_druckort_anspr_ddk ).
  lo_nd_druckort_anspr_ddk->get_static_attributes_table( importing table = lt_druckort_anspr_ddk ).
  "Tabelle zum Hinzufügen in Struktur schleifen
  loop at lt_druck_ansprechprtnr into ls_druck_ansprechprtnr.
    if ls_druck_ansprechprtnr-action eq '1'.
      move-corresponding ls_druck_ansprechprtnr to lstr_druckereiobj.
      lstr_druckereiobj-objekt_nr = lv_objekt.
      call function 'ZV_SAVE_OBJV_DRUCKORT_MAPI'
        exporting
          i_str_druckereiobj = lstr_druckereiobj
        importing
          e_commit           = e_commit
          e_tab_return       = itab_c_e_tab_return.
    endif.
  endloop.
  "Tabelle zum Löschen in Struktur schleifen
  loop at lt_druckort_anspr_ddk into ls_druck_ansprechprtnr_ddk.
    if ls_druck_ansprechprtnr_ddk-action eq '3'.
      move-corresponding ls_druck_ansprechprtnr_ddk to lstr_druckereiobj.
      lstr_druckereiobj-objekt_nr = lv_objekt.
      call function 'ZV_DELETE_OBJV_DRUCKORT_MAPI'
        exporting
          i_str_druckereiobj = lstr_druckereiobj
        importing
          e_commit           = e_commit
          e_tab_return       = itab_c_e_tab_return.
    endif.
  endloop.
*
*   Versandarten speichern
*
  """
  data lstr_versandart type zvst_versart.
  lv_objekt = str_object-objekt.
  data lo_nd_versandart type ref to if_wd_context_node.
  data lt_versandart type wd_this->elements_versandarten.
  lo_nd_versandart = wd_context->get_child_node( name = wd_this->wdctx_versandarten ).
  lo_nd_versandart->get_static_attributes_table( importing table = lt_versandart ).
  data lo_el_versandart type ref to if_wd_context_element.
  data ls_versandart type wd_this->element_versandarten.
*
*   Zu löschende Elemente aus DDK holen
*
  data lo_nd_versandart_ddk type ref to if_wd_context_node.
  data lt_versandart_ddk type wd_this->elements_versandart_ddk.
  data ls_versandart_ddk type wd_this->element_versandart_ddk.
  lo_nd_versandart_ddk = wd_context->get_child_node( name = wd_this->wdctx_versandart_ddk ).
  lo_nd_versandart_ddk->get_static_attributes_table( importing table = lt_versandart_ddk ).
  "Tabelle zum Hinzufügen in Struktur schleifen
  loop at lt_versandart into ls_versandart.
    if ls_versandart-action eq '1'.
      move-corresponding ls_versandart to lstr_versandart.
      lstr_versandart-zzobjek = lv_objekt.
      call function 'ZV_SAVE_OBJV_VERSART_MAPI'
        exporting
          i_str_versandart = lstr_versandart
        importing
          e_commit         = e_commit
          e_tab_return     = itab_c_e_tab_return.
    endif.
  endloop.
  "Tabelle zum Löschen in Struktur schleifen
  loop at lt_versandart_ddk into ls_versandart_ddk.
    if ls_versandart_ddk-action eq '3'.
      move-corresponding ls_versandart_ddk to lstr_versandart.
      lstr_versandart-zzobjek = lv_objekt.
      call function 'ZV_DELETE_OBJV_VERSART_MAPI'
        exporting
          i_str_versandart = lstr_versandart
        importing
          e_commit         = e_commit
          e_tab_return     = itab_c_e_tab_return.
    endif.
  endloop.
  """
*
*   Daten Postversand speichern
*
  data lo_nd_daten_postversand type ref to if_wd_context_node.
  data lo_el_daten_postversand type ref to if_wd_context_element.
  data ls_daten_postversand type wd_this->element_daten_postversand.
  lo_nd_daten_postversand = wd_context->get_child_node( name = wd_this->wdctx_daten_postversand ).
  lo_el_daten_postversand = lo_nd_daten_postversand->get_element( ).
  lo_el_daten_postversand->get_static_attributes(
    importing
      static_attributes = ls_daten_postversand ).
  " Objekt ID ergänzen
  ls_daten_postversand-zzobjek = lv_objekt.
  call function 'ZV_SAVE_OBJV_POSTDATEN_MAPI'
    exporting
      i_str_daten_postversand = ls_daten_postversand
    importing
      e_commit                = e_commit
      e_tab_return            = itab_c_e_tab_return.
* store output to context
  loop at itab_f_e_tab_return[] assigning <stru_f_e_tab_return>.
    move-corresponding <stru_f_e_tab_return> to stru_c_e_tab_return.
    insert stru_c_e_tab_return into table itab_c_e_tab_return[].
    wd_this->print_return_message(
      function = 'SC_SAVE_OBJ_VERSAND'
      message = stru_c_e_tab_return-message
    ).
  endloop.
  node_e_tab_return->bind_table( itab_c_e_tab_return[] ).
  clear: itab_f_e_tab_return[], itab_c_e_tab_return[].
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method FILL_LB_YEAR.
  "1/2019 KEMPF_S -> literale hier, damit der Code besser kopiert und geändert werden kann.
  DATA: lv_node_data_name     TYPE STRING VALUE `NODE_TRANS_COST.NODE_UEBERNAHME`.
  DATA: lv_node_values_name   TYPE STRING .
  "DATA: lv_node_sub_name      TYPE STRING VALUE 'NODE_UN_FROM_FOLGE'.
  DATA LO_ND_NODE_VALUES      TYPE REF TO IF_WD_CONTEXT_NODE.
  DATA LT_NODE_VALUES         TYPE WD_THIS->ELEMENTS_NODE_UN_FROM_FOLGE.
* 1/2019 KEMPF_S - die Listbox mit den verfügbaren Jahren wird bedarfsweise(eventgesteuert) ausgeführt(abh. v. anderen Listboxen).
  DATA:  lo_nd_node_data TYPE REF TO if_wd_context_node,
         lv_objekt   TYPE ZVIOFOBJEK, "f. Komplementberechnung
*  DATA LO_ND_NODE_DATA TYPE REF TO IF_WD_CONTEXT_NODE.
          LO_EL_NODE_DATA TYPE REF TO IF_WD_CONTEXT_ELEMENT,
         " LS_NODE_DATA    TYPE WD_THIS->ELEMENT_NODE_UEBERNAHME,
         " LT_NODE_DATA    TYPE WD_THIS->ELEMENTS_NODE_UEBERNAHME,
          LV_VERMARKTUNG  TYPE ZVDE_VERMARKTUNG,
          LT_HEFTFOLGE    TYPE ZVTT_HEFTFOLGE.
  DATA: lv_jahr TYPE ZVDE_JAHR.
  DATA(x) = NODE->GET_NODE_INFO( )->GET_NAME( ).
  DATA(lo_nd_object_repository) = wd_context->get_child_node( name = wd_this->wdctx_object_repository ).
  DATA(lo_el_object_repository) = lo_nd_object_repository->get_element( ).
  FIELD-SYMBOLS: <lfs_data> TYPE ANY,
                 <lfs_v> TYPE ANY.
  "zusammengesetzt
  lv_node_data_name = NODE->GET_NODE_INFO( )->GET_NAME( ).
* get single attribute
  lo_el_object_repository->get_attribute(
    EXPORTING
      name =  `OBJECT_ID`
    IMPORTING
      value = lv_objekt ).
    lv_vermarktung = wd_this->GET_VERMARKTUNG( IV_OBJEKT = lv_objekt ).
    lv_jahr = iv_jahr.
    LT_HEFTFOLGE = ZCL_HEFTFOLGE=>GET_HEFTFOLGEN_VON_BIS(
        IV_OBJEKT       = LV_OBJEKT
        IV_VERMARKTUNG  = lv_vermarktung
*        IV_AUSGABE      = 0
         IV_JAHR_VON     = lv_jahr
*         IV_FOLGE_VON    = IV_START_FOLGE
*        IV_JAHR_BIS     = IV_JAHR_BIS
*        IV_FOLGE_BIS    = IV_FOLGE_BIS
*        IV_EXKLUSIV_VON = ABAP_FALSE
*        IV_EXKLUSIV_BIS = ABAP_FALSE
           ).
    DELETE LT_HEFTFOLGE WHERE JAHR < lv_jahr. "das geht auch, wenn das Jahr initial ist.
    Sort LT_HEFTFOLGE BY JAHR ASCENDING.
    DELETE ADJACENT DUPLICATES FROM LT_HEFTFOLGE COMPARING JAHR.
     "Die Jahre aufsammeln.
     LOOP AT LT_HEFTFOLGE ASSIGNING FIELD-SYMBOL(<lfs_folge>).
          APPEND INITIAL LINE TO CT_TARGET_VALUES  ASSIGNING <lfs_data>.
          ASSIGN COMPONENT IV_DATA_FIELD OF STRUCTURE <lfs_data> TO FIELD-SYMBOL(<lfs_value>).
          "<lfs_data>-ZZABFOLGE
          <lfs_value> = <lfs_folge>-JAHR. "value ( ZCL_HEFTFOLGE=>GET_VIS_JAHR( <lfs_v>-ZZCJAHR ) ).
     ENDLOOP.
*
*  IF NOT lo_nd_node_values IS INITIAL.
*     LO_ND_NODE_VALUES->bind_table( new_items = CT_TARGET_VALUES  set_initial_elements = abap_true ).
*  ENDIF.
*
IF IV_INDEX IS SUPPLIED AND IV_INDEX > 0 AND LINES( IT_NODE_DATA ) >= IV_INDEX. "nur diesen updaten
  "z.B. NODE_TRANS_COST.NODE_VORTRANSPORT.NODE_VT_TO_FOLGE
  "Der Knoten mit den Listboxen
  LO_ND_NODE_VALUES = NODE->GET_CHILD_NODE(
                          INDEX = IV_INDEX
                          NAME  = IV_TARGET_NODE_NAME
                        ) .
    IF LO_ND_NODE_VALUES IS INITIAL.
      RETURN.
    ENDIF.
    lv_node_values_name =   LO_ND_NODE_VALUES->GET_PATH( ). "            && `.` && IV_TARGET_NODE_NAME.
    TRANSCOST_UPDATE_LISTBOX(
      EXPORTING
        IO_NODE_DATA            = NODE
        IO_NODE_VALUES          = LO_ND_NODE_VALUES
        IV_NODE_NAME            = IV_TARGET_NODE_NAME
        IT_VALUES               = CT_TARGET_VALUES
        IS_DATA                 = IT_NODE_DATA[ IV_INDEX ]
        IV_DATA_FIELD           = IV_DATA_FIELD
        IV_VALUE_FIELD          = IV_VALUE_FIELD "in der Strucktur der Listbox
        IV_SET_INITIAL_ELEMENTS = ABAP_TRUE
        IV_INDEX                = IV_INDEX
    ).
  ELSE."alle aktualisieren.
    LO_ND_NODE_VALUES = NODE->GET_CHILD_NODE( "ohne Indexangabe holen
                          NAME  = IV_TARGET_NODE_NAME
                        ) .
    TRANSCOST_ASSOCIATE_LISTBOX(
      EXPORTING
        IO_NODE_DATA            = NODE
        IO_NODE_VALUES          = LO_ND_NODE_VALUES
        IV_NODE_NAME            = IV_TARGET_NODE_NAME
        IT_VALUES               = CT_TARGET_VALUES
        IT_DATA                 = IT_NODE_DATA
        IV_DATA_FIELD           = IV_DATA_FIELD
        IV_VALUE_FIELD          = IV_VALUE_FIELD "in der Strucktur der Listbox
        IV_SET_INITIAL_ELEMENTS = ABAP_TRUE
    ).
  ENDIF.
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
METHOD SPLY_FROM_YEAR_UN.
  "Die ersten Deklarationen hier sind das Customizing für die Methode mit den Literalen für die Knoten und Felder...
 DATA:  lv_node_path   TYPE STRING VALUE `NODE_TRANS_COST.NODE_UEBERNAHME`,
        lv_node_values TYPE STRING VALUE `NODE_UN_FROM_YEAR`,
        lv_data_field  TYPE STRING VALUE `ZZABJHR`,
        lv_value_field TYPE STRING VALUE `ZZABJHR`.
 DATA:  LO_ND_NODE_VALUES     TYPE REF TO IF_WD_CONTEXT_NODE,
        LT_NODE_VALUES        TYPE WD_THIS->ELEMENTS_NODE_UN_FROM_YEAR,
        LO_ND_NODE_DATA       TYPE REF TO IF_WD_CONTEXT_NODE,
        LT_NODE_DATA          TYPE WD_THIS->ELEMENTS_NODE_UEBERNAHME,
* 1/2019 KEMPF_S - die Listbox mit den verfügbaren Jahren wird bedarfsweise(eventgesteuert) ausgeführt(abh. v. anderen Listboxen).
        lv_objekt  TYPE ZVIOFOBJEK. "f. Komplementberechnung
  DATA(lo_nd_object_repository) = wd_context->get_child_node( name = wd_this->wdctx_object_repository ).
  DATA(lo_el_object_repository) = lo_nd_object_repository->get_element( ).
  DATA(x) = NODE->GET_NODE_INFO( )->GET_NAME( ). "nur dev
* get single attribute
  lo_el_object_repository->get_attribute(
    EXPORTING
      name =  `OBJECT_ID`
    IMPORTING
      value = lv_objekt ).
*   navigate from <CONTEXT> to <NODE_TO_YEAR> via lead selection
   LO_ND_NODE_VALUES = WD_CONTEXT->PATH_GET_NODE( PATH = lv_node_path && `.` && lv_node_values ).
   IF lo_nd_node_values IS INITIAL.
      RETURN.
   ENDIF.
   LO_ND_NODE_DATA = WD_CONTEXT->PATH_GET_NODE( PATH = lv_node_path ).
   IF LO_ND_NODE_DATA IS INITIAL.
      RETURN.
   ENDIF.
   LO_ND_NODE_DATA->GET_STATIC_ATTRIBUTES_TABLE( IMPORTING TABLE = LT_NODE_DATA ).
   LO_ND_NODE_VALUES->GET_STATIC_ATTRIBUTES_TABLE( IMPORTING TABLE = LT_NODE_VALUES ).
*   CURRENT: die Supply Funktionen sollen nur noch die entsprechende Listbox Fuüllfunktion aufrufen.
*   Dadurch wird der Code und das Verhalten der Anwendung kontrollierbarer.
   me->FILL_LB_YEAR( "das Ab-Jahr gemäß den Möglichkeiten  setzen
        EXPORTING
         NODE = LO_ND_NODE_DATA                         "Referenz zu dem Knoten mit den Daten.
* GESAMTE JAHRE      IV_JAHR             =  LV_JAHR                  " zvde_jahr
         IV_TARGET_NODE_NAME =  lv_node_values           "i.e.:   'NODE_UN_FROM_YEAR'        " csequence
         IV_DATA_FIELD       =  lv_data_field            " der Name des Zielfeldes
         IV_VALUE_FIELD      =  lv_value_field           " cer Name des Zielfeldes in der Listbox
         IT_NODE_DATA        =  LT_NODE_DATA             " daten des Knotens
       CHANGING
         CT_TARGET_VALUES    =  LT_NODE_VALUES           " -> Listboxwerte, anfänglich leer, werden befüllt
      ).
ENDMETHOD.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
METHOD SPLY_FROM_YEAR_MAUT.
 "Die ersten Deklarationen hier sind das Customizing für die Methode mit den Literalen für die Knoten und Felder...
 DATA:  lv_node_path   TYPE STRING VALUE `NODE_TRANS_COST.NODE_MAUT`,
        lv_node_values TYPE STRING VALUE `NODE_MAUT_FROM_YEAR`,
        lv_data_field  TYPE STRING VALUE `ZZABJHR`,
        lv_value_field TYPE STRING VALUE `ZZABJHR`.
 DATA:  LO_ND_NODE_VALUES     TYPE REF TO IF_WD_CONTEXT_NODE,
        LT_NODE_VALUES        TYPE WD_THIS->ELEMENTS_NODE_MAUT_FROM_YEAR,
        LO_ND_NODE_DATA       TYPE REF TO IF_WD_CONTEXT_NODE,
        LT_NODE_DATA          TYPE WD_THIS->ELEMENTS_NODE_MAUT,
* 1/2019 KEMPF_S - die Listbox mit den verfügbaren Jahren wird bedarfsweise(eventgesteuert) ausgeführt(abh. v. anderen Listboxen).
        lv_objekt  TYPE ZVIOFOBJEK. "f. Komplementberechnung
  DATA(lo_nd_object_repository) = wd_context->get_child_node( name = wd_this->wdctx_object_repository ).
  DATA(lo_el_object_repository) = lo_nd_object_repository->get_element( ).
  DATA(x) = NODE->GET_NODE_INFO( )->GET_NAME( ). "nur dev
* get single attribute
  lo_el_object_repository->get_attribute(
    EXPORTING
      name =  `OBJECT_ID`
    IMPORTING
      value = lv_objekt ).
*   navigate from <CONTEXT> to <NODE_TO_YEAR> via lead selection
   LO_ND_NODE_VALUES = WD_CONTEXT->PATH_GET_NODE( PATH = lv_node_path && `.` && lv_node_values ).
   IF lo_nd_node_values IS INITIAL.
      RETURN.
   ENDIF.
   LO_ND_NODE_DATA = WD_CONTEXT->PATH_GET_NODE( PATH = lv_node_path ).
   IF LO_ND_NODE_DATA IS INITIAL.
      RETURN.
   ENDIF.
   LO_ND_NODE_DATA->GET_STATIC_ATTRIBUTES_TABLE( IMPORTING TABLE = LT_NODE_DATA ).
   LO_ND_NODE_VALUES->GET_STATIC_ATTRIBUTES_TABLE( IMPORTING TABLE = LT_NODE_VALUES ).
*   CURRENT: die Supply Funktionen sollen nur noch die entsprechende Listbox Fuüllfunktion aufrufen.
*   Dadurch wird der Code und das Verhalten der Anwendung kontrollierbarer.
   me->FILL_LB_YEAR( "das Ab-Jahr gemäß den Möglichkeiten  setzen
        EXPORTING
         NODE = LO_ND_NODE_DATA                         "Referenz zu dem Knoten mit den Daten.
* GESAMTE JAHRE      IV_JAHR             =  LV_JAHR                  " zvde_jahr
         IV_TARGET_NODE_NAME =  lv_node_values           "i.e.:   'NODE_UN_FROM_YEAR'        " csequence
         IV_DATA_FIELD       =  lv_data_field            " der Name des Zielfeldes
         IV_VALUE_FIELD      =  lv_value_field           " cer Name des Zielfeldes in der Listbox
         IT_NODE_DATA        =  LT_NODE_DATA             " daten des Knotens
       CHANGING
         CT_TARGET_VALUES    =  LT_NODE_VALUES           " -> Listboxwerte, anfänglich leer, werden befüllt
      ).
ENDMETHOD.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
METHOD SPLY_FROM_YEAR_ECOTAX.
  "Die ersten Deklarationen hier sind das Customizing für die Methode mit den Literalen für die Knoten und Felder...
 DATA:  lv_node_path   TYPE STRING VALUE `NODE_TRANS_COST.NODE_ECOTAX`,
        lv_node_values TYPE STRING VALUE `NODE_ETAX_FROM_YEAR`,
        lv_data_field  TYPE STRING VALUE `ZZABJHR`,
        lv_value_field TYPE STRING VALUE `ZZABJHR`.
 DATA:  LO_ND_NODE_VALUES     TYPE REF TO IF_WD_CONTEXT_NODE,
        LT_NODE_VALUES        TYPE WD_THIS->ELEMENTS_NODE_ETAX_FROM_YEAR,
        LO_ND_NODE_DATA       TYPE REF TO IF_WD_CONTEXT_NODE,
        LT_NODE_DATA          TYPE WD_THIS->ELEMENTS_NODE_ECOTAX,
* 1/2019 KEMPF_S - die Listbox mit den verfügbaren Jahren wird bedarfsweise(eventgesteuert) ausgeführt(abh. v. anderen Listboxen).
        lv_objekt  TYPE ZVIOFOBJEK. "f. Komplementberechnung
  DATA(lo_nd_object_repository) = wd_context->get_child_node( name = wd_this->wdctx_object_repository ).
  DATA(lo_el_object_repository) = lo_nd_object_repository->get_element( ).
  DATA(x) = NODE->GET_NODE_INFO( )->GET_NAME( ). "nur dev
* get single attribute
  lo_el_object_repository->get_attribute(
    EXPORTING
      name =  `OBJECT_ID`
    IMPORTING
      value = lv_objekt ).
*   navigate from <CONTEXT> to <NODE_TO_YEAR> via lead selection
   LO_ND_NODE_VALUES = WD_CONTEXT->PATH_GET_NODE( PATH = lv_node_path && `.` && lv_node_values ).
   IF lo_nd_node_values IS INITIAL.
      RETURN.
   ENDIF.
   LO_ND_NODE_DATA = WD_CONTEXT->PATH_GET_NODE( PATH = lv_node_path ).
   IF LO_ND_NODE_DATA IS INITIAL.
      RETURN.
   ENDIF.
   LO_ND_NODE_DATA->GET_STATIC_ATTRIBUTES_TABLE( IMPORTING TABLE = LT_NODE_DATA ).
   LO_ND_NODE_VALUES->GET_STATIC_ATTRIBUTES_TABLE( IMPORTING TABLE = LT_NODE_VALUES ).
*   CURRENT: die Supply Funktionen sollen nur noch die entsprechende Listbox Fuüllfunktion aufrufen.
*   Dadurch wird der Code und das Verhalten der Anwendung kontrollierbarer.
   me->FILL_LB_YEAR( "das Ab-Jahr gemäß den Möglichkeiten  setzen
        EXPORTING
         NODE = LO_ND_NODE_DATA                         "Referenz zu dem Knoten mit den Daten.
* GESAMTE JAHRE      IV_JAHR             =  LV_JAHR                  " zvde_jahr
         IV_TARGET_NODE_NAME =  lv_node_values           "i.e.:   'NODE_UN_FROM_YEAR'        " csequence
         IV_DATA_FIELD       =  lv_data_field            " der Name des Zielfeldes
         IV_VALUE_FIELD      =  lv_value_field           " cer Name des Zielfeldes in der Listbox
         IT_NODE_DATA        =  LT_NODE_DATA             " daten des Knotens
       CHANGING
         CT_TARGET_VALUES    =  LT_NODE_VALUES           " -> Listboxwerte, anfänglich leer, werden befüllt
      ).
ENDMETHOD.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
METHOD SPLY_FROM_YEAR_VT.
"Die ersten Deklarationen hier sind das Customizing für die Methode mit den Literalen für die Knoten und Felder...
 DATA:  lv_node_path   TYPE STRING VALUE `NODE_TRANS_COST.NODE_VORTRANSPORT`,
        lv_node_values TYPE STRING VALUE `NODE_VT_FROM_YEAR`,
        lv_data_field  TYPE STRING VALUE `ZZABJHR`,
        lv_value_field TYPE STRING VALUE `ZZABJHR`.
 DATA:  LO_ND_NODE_VALUES     TYPE REF TO IF_WD_CONTEXT_NODE,
        LT_NODE_VALUES        TYPE WD_THIS->ELEMENTS_NODE_VT_FROM_YEAR,
        LO_ND_NODE_DATA       TYPE REF TO IF_WD_CONTEXT_NODE,
        LT_NODE_DATA          TYPE WD_THIS->ELEMENTS_NODE_VORTRANSPORT,
* 1/2019 KEMPF_S - die Listbox mit den verfügbaren Jahren wird bedarfsweise(eventgesteuert) ausgeführt(abh. v. anderen Listboxen).
        lv_objekt  TYPE ZVIOFOBJEK. "f. Komplementberechnung
  DATA(lo_nd_object_repository) = wd_context->get_child_node( name = wd_this->wdctx_object_repository ).
  DATA(lo_el_object_repository) = lo_nd_object_repository->get_element( ).
  DATA(x) = NODE->GET_NODE_INFO( )->GET_NAME( ). "nur dev
* get single attribute
  lo_el_object_repository->get_attribute(
    EXPORTING
      name =  `OBJECT_ID`
    IMPORTING
      value = lv_objekt ).
*   navigate from <CONTEXT> to <NODE_TO_YEAR> via lead selection
   LO_ND_NODE_VALUES = WD_CONTEXT->PATH_GET_NODE( PATH = lv_node_path && `.` && lv_node_values ).
   IF lo_nd_node_values IS INITIAL.
      RETURN.
   ENDIF.
   LO_ND_NODE_DATA = WD_CONTEXT->PATH_GET_NODE( PATH = lv_node_path ).
   IF LO_ND_NODE_DATA IS INITIAL.
      RETURN.
   ENDIF.
   LO_ND_NODE_DATA->GET_STATIC_ATTRIBUTES_TABLE( IMPORTING TABLE = LT_NODE_DATA ).
   LO_ND_NODE_VALUES->GET_STATIC_ATTRIBUTES_TABLE( IMPORTING TABLE = LT_NODE_VALUES ).
*   CURRENT: die Supply Funktionen sollen nur noch die entsprechende Listbox Fuüllfunktion aufrufen.
*   Dadurch wird der Code und das Verhalten der Anwendung kontrollierbarer.
   me->FILL_LB_YEAR( "das Ab-Jahr gemäß den Möglichkeiten  setzen
        EXPORTING
         NODE = LO_ND_NODE_DATA                         "Referenz zu dem Knoten mit den Daten.
* GESAMTE JAHRE      IV_JAHR             =  LV_JAHR                  " zvde_jahr
         IV_TARGET_NODE_NAME =  lv_node_values           "i.e.:   'NODE_UN_FROM_YEAR'        " csequence
         IV_DATA_FIELD       =  lv_data_field            " der Name des Zielfeldes
         IV_VALUE_FIELD      =  lv_value_field           " cer Name des Zielfeldes in der Listbox
         IT_NODE_DATA        =  LT_NODE_DATA             " daten des Knotens
       CHANGING
         CT_TARGET_VALUES    =  LT_NODE_VALUES           " -> Listboxwerte, anfänglich leer, werden befüllt
      ).
ENDMETHOD.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method SPLY_TO_YEAR_VT.
  "Die ersten Deklarationen hier sind das Customizing für die Methode mit den Literalen für die Knoten und Felder...
 DATA:  lv_node_path   TYPE STRING VALUE `NODE_TRANS_COST.NODE_VORTRANSPORT`,
        lv_node_values TYPE STRING VALUE `NODE_VT_TO_YEAR`,
        lv_data_field  TYPE STRING VALUE `ZZBISJHR`,
        lv_value_field TYPE STRING VALUE `ZZBISJHR`.
 DATA:  LO_ND_NODE_VALUES     TYPE REF TO IF_WD_CONTEXT_NODE,
        LT_NODE_VALUES        TYPE WD_THIS->ELEMENTS_NODE_VT_TO_YEAR,
        LO_ND_NODE_DATA       TYPE REF TO IF_WD_CONTEXT_NODE,
        LT_NODE_DATA          TYPE WD_THIS->ELEMENTS_NODE_VORTRANSPORT,
* 1/2019 KEMPF_S - die Listbox mit den verfügbaren Jahren wird bedarfsweise(eventgesteuert) ausgeführt(abh. v. anderen Listboxen).
        lv_objekt  TYPE ZVIOFOBJEK. "f. Komplementberechnung
  DATA(lo_nd_object_repository) = wd_context->get_child_node( name = wd_this->wdctx_object_repository ).
  DATA(lo_el_object_repository) = lo_nd_object_repository->get_element( ).
  DATA(x) = NODE->GET_NODE_INFO( )->GET_NAME( ). "nur dev
* get single attribute
  lo_el_object_repository->get_attribute(
    EXPORTING
      name =  `OBJECT_ID`
    IMPORTING
      value = lv_objekt ).
*   navigate from <CONTEXT> to <NODE_TO_YEAR> via lead selection
   LO_ND_NODE_VALUES = WD_CONTEXT->PATH_GET_NODE( PATH = lv_node_path && `.` && lv_node_values ).
   IF lo_nd_node_values IS INITIAL.
      RETURN.
   ENDIF.
   LO_ND_NODE_DATA = WD_CONTEXT->PATH_GET_NODE( PATH = lv_node_path ).
   IF LO_ND_NODE_DATA IS INITIAL.
      RETURN.
   ENDIF.
   LO_ND_NODE_DATA->GET_STATIC_ATTRIBUTES_TABLE( IMPORTING TABLE = LT_NODE_DATA ).
   LO_ND_NODE_VALUES->GET_STATIC_ATTRIBUTES_TABLE( IMPORTING TABLE = LT_NODE_VALUES ).
*   CURRENT: die Supply Funktionen sollen nur noch die entsprechende Listbox Fuüllfunktion aufrufen.
*   Dadurch wird der Code und das Verhalten der Anwendung kontrollierbarer.
   me->FILL_LB_YEAR( "das Ab-Jahr gemäß den Möglichkeiten  setzen
        EXPORTING
         NODE = LO_ND_NODE_DATA                         "Referenz zu dem Knoten mit den Daten.
* GESAMTE JAHRE      IV_JAHR             =  LV_JAHR                  " zvde_jahr
         IV_TARGET_NODE_NAME =  lv_node_values           "i.e.:   'NODE_UN_FROM_YEAR'        " csequence
         IV_DATA_FIELD       =  lv_data_field            " der Name des Zielfeldes
         IV_VALUE_FIELD      =  lv_value_field           " cer Name des Zielfeldes in der Listbox
         IT_NODE_DATA        =  LT_NODE_DATA             " daten des Knotens
       CHANGING
         CT_TARGET_VALUES    =  LT_NODE_VALUES           " -> Listboxwerte, anfänglich leer, werden befüllt
      ).
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
METHOD SPLY_TO_YEAR_MAUT.
  "Die ersten Deklarationen hier sind das Customizing für die Methode mit den Literalen für die Knoten und Felder...
 DATA:  lv_node_path   TYPE STRING VALUE `NODE_TRANS_COST.NODE_MAUT`,
        lv_node_values TYPE STRING VALUE `NODE_MAUT_TO_YEAR`,
        lv_data_field  TYPE STRING VALUE `ZZBISJHR`,
        lv_value_field TYPE STRING VALUE `ZZBISJHR`.
 DATA:  LO_ND_NODE_VALUES     TYPE REF TO IF_WD_CONTEXT_NODE,
        LT_NODE_VALUES        TYPE WD_THIS->ELEMENTS_NODE_VT_TO_YEAR,
        LO_ND_NODE_DATA       TYPE REF TO IF_WD_CONTEXT_NODE,
        LT_NODE_DATA          TYPE WD_THIS->ELEMENTS_NODE_VORTRANSPORT,
* 1/2019 KEMPF_S - die Listbox mit den verfügbaren Jahren wird bedarfsweise(eventgesteuert) ausgeführt(abh. v. anderen Listboxen).
        lv_objekt  TYPE ZVIOFOBJEK. "f. Komplementberechnung
  DATA(lo_nd_object_repository) = wd_context->get_child_node( name = wd_this->wdctx_object_repository ).
  DATA(lo_el_object_repository) = lo_nd_object_repository->get_element( ).
  DATA(x) = NODE->GET_NODE_INFO( )->GET_NAME( ). "nur dev
* get single attribute
  lo_el_object_repository->get_attribute(
    EXPORTING
      name =  `OBJECT_ID`
    IMPORTING
      value = lv_objekt ).
*   navigate from <CONTEXT> to <NODE_TO_YEAR> via lead selection
   LO_ND_NODE_VALUES = WD_CONTEXT->PATH_GET_NODE( PATH = lv_node_path && `.` && lv_node_values ).
   IF lo_nd_node_values IS INITIAL.
      RETURN.
   ENDIF.
   LO_ND_NODE_DATA = WD_CONTEXT->PATH_GET_NODE( PATH = lv_node_path ).
   IF LO_ND_NODE_DATA IS INITIAL.
      RETURN.
   ENDIF.
   LO_ND_NODE_DATA->GET_STATIC_ATTRIBUTES_TABLE( IMPORTING TABLE = LT_NODE_DATA ).
   LO_ND_NODE_VALUES->GET_STATIC_ATTRIBUTES_TABLE( IMPORTING TABLE = LT_NODE_VALUES ).
*   CURRENT: die Supply Funktionen sollen nur noch die entsprechende Listbox Fuüllfunktion aufrufen.
*   Dadurch wird der Code und das Verhalten der Anwendung kontrollierbarer.
   me->FILL_LB_YEAR( "das Ab-Jahr gemäß den Möglichkeiten  setzen
        EXPORTING
         NODE = LO_ND_NODE_DATA                         "Referenz zu dem Knoten mit den Daten.
* GESAMTE JAHRE      IV_JAHR             =  LV_JAHR                  " zvde_jahr
         IV_TARGET_NODE_NAME =  lv_node_values           "i.e.:   'NODE_UN_FROM_YEAR'        " csequence
         IV_DATA_FIELD       =  lv_data_field            " der Name des Zielfeldes
         IV_VALUE_FIELD      =  lv_value_field           " cer Name des Zielfeldes in der Listbox
         IT_NODE_DATA        =  LT_NODE_DATA             " daten des Knotens
       CHANGING
         CT_TARGET_VALUES    =  LT_NODE_VALUES           " -> Listboxwerte, anfänglich leer, werden befüllt
      ).
ENDMETHOD.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method SPLY_TO_YEAR_UN.
"Die ersten Deklarationen hier sind das Customizing für die Methode mit den Literalen für die Knoten und Felder...
 DATA:  lv_node_path   TYPE STRING VALUE `NODE_TRANS_COST.NODE_UEBERNAHME`,
        lv_node_values TYPE STRING VALUE `NODE_UN_TO_YEAR`,
        lv_data_field  TYPE STRING VALUE `ZZBISJHR`,
        lv_value_field TYPE STRING VALUE `ZZBISJHR`.
 DATA:  LO_ND_NODE_VALUES     TYPE REF TO IF_WD_CONTEXT_NODE,
        LT_NODE_VALUES        TYPE WD_THIS->ELEMENTS_NODE_MAUT_TO_YEAR,
        LO_ND_NODE_DATA       TYPE REF TO IF_WD_CONTEXT_NODE,
        LT_NODE_DATA          TYPE WD_THIS->ELEMENTS_NODE_UEBERNAHME,
* 1/2019 KEMPF_S - die Listbox mit den verfügbaren Jahren wird bedarfsweise(eventgesteuert) ausgeführt(abh. v. anderen Listboxen).
        lv_objekt  TYPE ZVIOFOBJEK. "f. Komplementberechnung
  DATA(lo_nd_object_repository) = wd_context->get_child_node( name = wd_this->wdctx_object_repository ).
  DATA(lo_el_object_repository) = lo_nd_object_repository->get_element( ).
  DATA(x) = NODE->GET_NODE_INFO( )->GET_NAME( ). "nur dev
* get single attribute
  lo_el_object_repository->get_attribute(
    EXPORTING
      name =  `OBJECT_ID`
    IMPORTING
      value = lv_objekt ).
*   navigate from <CONTEXT> to <NODE_TO_YEAR> via lead selection
   LO_ND_NODE_VALUES = WD_CONTEXT->PATH_GET_NODE( PATH = lv_node_path && `.` && lv_node_values ).
   IF lo_nd_node_values IS INITIAL.
      RETURN.
   ENDIF.
   LO_ND_NODE_DATA = WD_CONTEXT->PATH_GET_NODE( PATH = lv_node_path ).
   IF LO_ND_NODE_DATA IS INITIAL.
      RETURN.
   ENDIF.
   LO_ND_NODE_DATA->GET_STATIC_ATTRIBUTES_TABLE( IMPORTING TABLE = LT_NODE_DATA ).
   LO_ND_NODE_VALUES->GET_STATIC_ATTRIBUTES_TABLE( IMPORTING TABLE = LT_NODE_VALUES ).
*   CURRENT: die Supply Funktionen sollen nur noch die entsprechende Listbox Fuüllfunktion aufrufen.
*   Dadurch wird der Code und das Verhalten der Anwendung kontrollierbarer.
   me->FILL_LB_YEAR( "das Ab-Jahr gemäß den Möglichkeiten  setzen
        EXPORTING
         NODE = LO_ND_NODE_DATA                         "Referenz zu dem Knoten mit den Daten.
* GESAMTE JAHRE      IV_JAHR             =  LV_JAHR                  " zvde_jahr
         IV_TARGET_NODE_NAME =  lv_node_values           "i.e.:   'NODE_UN_FROM_YEAR'        " csequence
         IV_DATA_FIELD       =  lv_data_field            " der Name des Zielfeldes
         IV_VALUE_FIELD      =  lv_value_field           " cer Name des Zielfeldes in der Listbox
         IT_NODE_DATA        =  LT_NODE_DATA             " daten des Knotens
       CHANGING
         CT_TARGET_VALUES    =  LT_NODE_VALUES           " -> Listboxwerte, anfänglich leer, werden befüllt
      ).
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
METHOD SPLY_TO_YEAR_ECOTAX.
  "Die ersten Deklarationen hier sind das Customizing für die Methode mit den Literalen für die Knoten und Felder...
 DATA:  lv_node_path   TYPE STRING VALUE `NODE_TRANS_COST.NODE_ECOTAX`,
        lv_node_values TYPE STRING VALUE `NODE_ETAX_TO_YEAR`,
        lv_data_field  TYPE STRING VALUE `ZZBISJHR`,
        lv_value_field TYPE STRING VALUE `ZZBISJHR`.
 DATA:  LO_ND_NODE_VALUES     TYPE REF TO IF_WD_CONTEXT_NODE,
        LT_NODE_VALUES        TYPE WD_THIS->ELEMENTS_NODE_ETAX_TO_YEAR,
        LO_ND_NODE_DATA       TYPE REF TO IF_WD_CONTEXT_NODE,
        LT_NODE_DATA          TYPE WD_THIS->ELEMENTS_NODE_ECOTAX,
* 1/2019 KEMPF_S - die Listbox mit den verfügbaren Jahren wird bedarfsweise(eventgesteuert) ausgeführt(abh. v. anderen Listboxen).
        lv_objekt  TYPE ZVIOFOBJEK. "f. Komplementberechnung
  DATA(lo_nd_object_repository) = wd_context->get_child_node( name = wd_this->wdctx_object_repository ).
  DATA(lo_el_object_repository) = lo_nd_object_repository->get_element( ).
  DATA(x) = NODE->GET_NODE_INFO( )->GET_NAME( ). "nur dev
* get single attribute
  lo_el_object_repository->get_attribute(
    EXPORTING
      name =  `OBJECT_ID`
    IMPORTING
      value = lv_objekt ).
*   navigate from <CONTEXT> to <NODE_TO_YEAR> via lead selection
   LO_ND_NODE_VALUES = WD_CONTEXT->PATH_GET_NODE( PATH = lv_node_path && `.` && lv_node_values ).
   IF lo_nd_node_values IS INITIAL.
      RETURN.
   ENDIF.
   LO_ND_NODE_DATA = WD_CONTEXT->PATH_GET_NODE( PATH = lv_node_path ).
   IF LO_ND_NODE_DATA IS INITIAL.
      RETURN.
   ENDIF.
   LO_ND_NODE_DATA->GET_STATIC_ATTRIBUTES_TABLE( IMPORTING TABLE = LT_NODE_DATA ).
   LO_ND_NODE_VALUES->GET_STATIC_ATTRIBUTES_TABLE( IMPORTING TABLE = LT_NODE_VALUES ).
*   CURRENT: die Supply Funktionen sollen nur noch die entsprechende Listbox Fuüllfunktion aufrufen.
*   Dadurch wird der Code und das Verhalten der Anwendung kontrollierbarer.
   me->FILL_LB_YEAR( "das Ab-Jahr gemäß den Möglichkeiten  setzen
        EXPORTING
         NODE = LO_ND_NODE_DATA                         "Referenz zu dem Knoten mit den Daten.
* GESAMTE JAHRE      IV_JAHR             =  LV_JAHR                  " zvde_jahr
         IV_TARGET_NODE_NAME =  lv_node_values           "i.e.:   'NODE_UN_FROM_YEAR'        " csequence
         IV_DATA_FIELD       =  lv_data_field            " der Name des Zielfeldes
         IV_VALUE_FIELD      =  lv_value_field           " cer Name des Zielfeldes in der Listbox
         IT_NODE_DATA        =  LT_NODE_DATA             " daten des Knotens
       CHANGING
         CT_TARGET_VALUES    =  LT_NODE_VALUES           " -> Listboxwerte, anfänglich leer, werden befüllt
      ).
ENDMETHOD.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method SPLY_TO_FOLGE_VT.
"Die ersten Deklarationen hier sind das Customizing für die Methode mit den Literalen für die Knoten und Felder...
 DATA:  lv_node_path   TYPE STRING VALUE `NODE_TRANS_COST.NODE_VORTRANSPORT`,
        lv_node_values TYPE STRING VALUE `NODE_VT_TO_FOLGE`,
        lv_data_field  TYPE STRING VALUE `ZZBISFOLGE`,
        lv_value_field TYPE STRING VALUE `ZZBISFOLGE`.
 DATA:  LO_ND_NODE_VALUES     TYPE REF TO IF_WD_CONTEXT_NODE,
        LT_NODE_VALUES        TYPE WD_THIS->ELEMENTS_NODE_VT_TO_FOLGE,
        LO_ND_NODE_DATA       TYPE REF TO IF_WD_CONTEXT_NODE,
        LT_NODE_DATA          TYPE WD_THIS->ELEMENTS_NODE_VORTRANSPORT,
* 1/2019 KEMPF_S - die Listbox mit den verfügbaren Jahren wird bedarfsweise(eventgesteuert) ausgeführt(abh. v. anderen Listboxen).
        lv_objekt  TYPE ZVIOFOBJEK. "f. Komplementberechnung
  DATA(lo_nd_object_repository) = wd_context->get_child_node( name = wd_this->wdctx_object_repository ).
  DATA(lo_el_object_repository) = lo_nd_object_repository->get_element( ).
  DATA(x) = NODE->GET_NODE_INFO( )->GET_NAME( ). "nur dev
* get single attribute
  lo_el_object_repository->get_attribute(
    EXPORTING
      name =  `OBJECT_ID`
    IMPORTING
      value = lv_objekt ).
*   navigate from <CONTEXT> to <NODE_TO_YEAR> via lead selection
   LO_ND_NODE_VALUES = WD_CONTEXT->PATH_GET_NODE( PATH = lv_node_path && `.` && lv_node_values ).
   IF lo_nd_node_values IS INITIAL.
      RETURN.
   ENDIF.
   LO_ND_NODE_DATA = WD_CONTEXT->PATH_GET_NODE( PATH = lv_node_path ).
   IF LO_ND_NODE_DATA IS INITIAL.
      RETURN.
   ENDIF.
   LO_ND_NODE_DATA->GET_STATIC_ATTRIBUTES_TABLE( IMPORTING TABLE = LT_NODE_DATA ).
   LO_ND_NODE_VALUES->GET_STATIC_ATTRIBUTES_TABLE( IMPORTING TABLE = LT_NODE_VALUES ).
*   CURRENT: die Supply Funktionen sollen nur noch die entsprechende Listbox Fuüllfunktion aufrufen.
*   Dadurch wird der Code und das Verhalten der Anwendung kontrollierbarer.
   me->FILL_LB_FOLGE( "das Ab-Jahr gemäß den Möglichkeiten  setzen
        EXPORTING
         NODE = LO_ND_NODE_DATA                         "Referenz zu dem Knoten mit den Daten.
* GESAMTE JAHRE      IV_JAHR             =  LV_JAHR                  " zvde_jahr
         IV_TARGET_NODE_NAME =  lv_node_values           "i.e.:   'NODE_UN_FROM_YEAR'        " csequence
         IV_DATA_FIELD       =  lv_data_field            " der Name des Zielfeldes
         IV_VALUE_FIELD      =  lv_value_field           " cer Name des Zielfeldes in der Listbox
         IT_NODE_DATA        =  LT_NODE_DATA             " daten des Knotens
       CHANGING
         CT_TARGET_VALUES    =  LT_NODE_VALUES           " -> Listboxwerte, anfänglich leer, werden befüllt
      ).
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method SPLY_TO_FOLGE_UN.
"Die ersten Deklarationen hier sind das Customizing für die Methode mit den Literalen für die Knoten und Felder...
 DATA:  lv_node_path   TYPE STRING VALUE `NODE_TRANS_COST.NODE_UEBERNAHME`,
        lv_node_values TYPE STRING VALUE `NODE_UN_TO_FOLGE`,
        lv_data_field  TYPE STRING VALUE `ZZBISFOLGE`,
        lv_value_field TYPE STRING VALUE `ZZBISFOLGE`.
 DATA:  LO_ND_NODE_VALUES     TYPE REF TO IF_WD_CONTEXT_NODE,
        LT_NODE_VALUES        TYPE WD_THIS->ELEMENTS_NODE_VT_TO_FOLGE,
        LO_ND_NODE_DATA       TYPE REF TO IF_WD_CONTEXT_NODE,
        LT_NODE_DATA          TYPE WD_THIS->ELEMENTS_NODE_UEBERNAHME,
* 1/2019 KEMPF_S - die Listbox mit den verfügbaren Jahren wird bedarfsweise(eventgesteuert) ausgeführt(abh. v. anderen Listboxen).
        lv_objekt  TYPE ZVIOFOBJEK. "f. Komplementberechnung
  DATA(lo_nd_object_repository) = wd_context->get_child_node( name = wd_this->wdctx_object_repository ).
  DATA(lo_el_object_repository) = lo_nd_object_repository->get_element( ).
  DATA(x) = NODE->GET_NODE_INFO( )->GET_NAME( ). "nur dev
* get single attribute
  lo_el_object_repository->get_attribute(
    EXPORTING
      name =  `OBJECT_ID`
    IMPORTING
      value = lv_objekt ).
*   navigate from <CONTEXT> to <NODE_TO_YEAR> via lead selection
   LO_ND_NODE_VALUES = WD_CONTEXT->PATH_GET_NODE( PATH = lv_node_path && `.` && lv_node_values ).
   IF lo_nd_node_values IS INITIAL.
      RETURN.
   ENDIF.
   LO_ND_NODE_DATA = WD_CONTEXT->PATH_GET_NODE( PATH = lv_node_path ).
   IF LO_ND_NODE_DATA IS INITIAL.
      RETURN.
   ENDIF.
   LO_ND_NODE_DATA->GET_STATIC_ATTRIBUTES_TABLE( IMPORTING TABLE = LT_NODE_DATA ).
   LO_ND_NODE_VALUES->GET_STATIC_ATTRIBUTES_TABLE( IMPORTING TABLE = LT_NODE_VALUES ).
*   CURRENT: die Supply Funktionen sollen nur noch die entsprechende Listbox Fuüllfunktion aufrufen.
*   Dadurch wird der Code und das Verhalten der Anwendung kontrollierbarer.
   me->FILL_LB_FOLGE( "das Ab-Jahr gemäß den Möglichkeiten  setzen
        EXPORTING
         NODE = LO_ND_NODE_DATA                         "Referenz zu dem Knoten mit den Daten.
* GESAMTE JAHRE      IV_JAHR             =  LV_JAHR                  " zvde_jahr
         IV_TARGET_NODE_NAME =  lv_node_values           "i.e.:   'NODE_UN_FROM_YEAR'        " csequence
         IV_DATA_FIELD       =  lv_data_field            " der Name des Zielfeldes
         IV_VALUE_FIELD      =  lv_value_field           " cer Name des Zielfeldes in der Listbox
         IT_NODE_DATA        =  LT_NODE_DATA             " daten des Knotens
       CHANGING
         CT_TARGET_VALUES    =  LT_NODE_VALUES           " -> Listboxwerte, anfänglich leer, werden befüllt
      ).
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method SPLY_TO_FOLGE_MAUT.
"Die ersten Deklarationen hier sind das Customizing für die Methode mit den Literalen für die Knoten und Felder...
 DATA:  lv_node_path   TYPE STRING VALUE `NODE_TRANS_COST.NODE_MAUT`,
        lv_node_values TYPE STRING VALUE `NODE_MAUT_TO_FOLGE`,
        lv_data_field  TYPE STRING VALUE `ZZBISFOLGE`,
        lv_value_field TYPE STRING VALUE `ZZBISFOLGE`.
 DATA:  LO_ND_NODE_VALUES     TYPE REF TO IF_WD_CONTEXT_NODE,
        LT_NODE_VALUES        TYPE WD_THIS->ELEMENTS_NODE_MAUT_TO_FOLGE,
        LO_ND_NODE_DATA       TYPE REF TO IF_WD_CONTEXT_NODE,
        LT_NODE_DATA          TYPE WD_THIS->ELEMENTS_NODE_MAUT,
* 1/2019 KEMPF_S - die Listbox mit den verfügbaren Jahren wird bedarfsweise(eventgesteuert) ausgeführt(abh. v. anderen Listboxen).
        lv_objekt  TYPE ZVIOFOBJEK. "f. Komplementberechnung
  DATA(lo_nd_object_repository) = wd_context->get_child_node( name = wd_this->wdctx_object_repository ).
  DATA(lo_el_object_repository) = lo_nd_object_repository->get_element( ).
  DATA(x) = NODE->GET_NODE_INFO( )->GET_NAME( ). "nur dev
* get single attribute
  lo_el_object_repository->get_attribute(
    EXPORTING
      name =  `OBJECT_ID`
    IMPORTING
      value = lv_objekt ).
*   navigate from <CONTEXT> to <NODE_TO_YEAR> via lead selection
   LO_ND_NODE_VALUES = WD_CONTEXT->PATH_GET_NODE( PATH = lv_node_path && `.` && lv_node_values ).
   IF lo_nd_node_values IS INITIAL.
      RETURN.
   ENDIF.
   LO_ND_NODE_DATA = WD_CONTEXT->PATH_GET_NODE( PATH = lv_node_path ).
   IF LO_ND_NODE_DATA IS INITIAL.
      RETURN.
   ENDIF.
   LO_ND_NODE_DATA->GET_STATIC_ATTRIBUTES_TABLE( IMPORTING TABLE = LT_NODE_DATA ).
   LO_ND_NODE_VALUES->GET_STATIC_ATTRIBUTES_TABLE( IMPORTING TABLE = LT_NODE_VALUES ).
*   CURRENT: die Supply Funktionen sollen nur noch die entsprechende Listbox Fuüllfunktion aufrufen.
*   Dadurch wird der Code und das Verhalten der Anwendung kontrollierbarer.
   me->FILL_LB_FOLGE( "das Ab-Jahr gemäß den Möglichkeiten  setzen
        EXPORTING
         NODE = LO_ND_NODE_DATA                         "Referenz zu dem Knoten mit den Daten.
* GESAMTE JAHRE      IV_JAHR             =  LV_JAHR                  " zvde_jahr
         IV_TARGET_NODE_NAME =  lv_node_values           "i.e.:   'NODE_UN_FROM_YEAR'        " csequence
         IV_DATA_FIELD       =  lv_data_field            " der Name des Zielfeldes
         IV_VALUE_FIELD      =  lv_value_field           " cer Name des Zielfeldes in der Listbox
         IT_NODE_DATA        =  LT_NODE_DATA             " daten des Knotens
       CHANGING
         CT_TARGET_VALUES    =  LT_NODE_VALUES           " -> Listboxwerte, anfänglich leer, werden befüllt
      ).
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method SPLY_TO_FOLGE_ETAX.
"Die ersten Deklarationen hier sind das Customizing für die Methode mit den Literalen für die Knoten und Felder...
 DATA:  lv_node_path   TYPE STRING VALUE `NODE_TRANS_COST.NODE_ECOTAX`,
        lv_node_values TYPE STRING VALUE `NODE_ETAX_TO_FOLGE`,
        lv_data_field  TYPE STRING VALUE `ZZBISFOLGE`,
        lv_value_field TYPE STRING VALUE `ZZBISFOLGE`.
 DATA:  LO_ND_NODE_VALUES     TYPE REF TO IF_WD_CONTEXT_NODE,
        LT_NODE_VALUES        TYPE WD_THIS->ELEMENTS_NODE_ETAX_TO_FOLGE,
        LO_ND_NODE_DATA       TYPE REF TO IF_WD_CONTEXT_NODE,
        LT_NODE_DATA          TYPE WD_THIS->ELEMENTS_NODE_ECOTAX,
* 1/2019 KEMPF_S - die Listbox mit den verfügbaren Jahren wird bedarfsweise(eventgesteuert) ausgeführt(abh. v. anderen Listboxen).
        lv_objekt  TYPE ZVIOFOBJEK. "f. Komplementberechnung
  DATA(lo_nd_object_repository) = wd_context->get_child_node( name = wd_this->wdctx_object_repository ).
  DATA(lo_el_object_repository) = lo_nd_object_repository->get_element( ).
  DATA(x) = NODE->GET_NODE_INFO( )->GET_NAME( ). "nur dev
* get single attribute
  lo_el_object_repository->get_attribute(
    EXPORTING
      name =  `OBJECT_ID`
    IMPORTING
      value = lv_objekt ).
*   navigate from <CONTEXT> to <NODE_TO_YEAR> via lead selection
   LO_ND_NODE_VALUES = WD_CONTEXT->PATH_GET_NODE( PATH = lv_node_path && `.` && lv_node_values ).
   IF lo_nd_node_values IS INITIAL.
      RETURN.
   ENDIF.
   LO_ND_NODE_DATA = WD_CONTEXT->PATH_GET_NODE( PATH = lv_node_path ).
   IF LO_ND_NODE_DATA IS INITIAL.
      RETURN.
   ENDIF.
   LO_ND_NODE_DATA->GET_STATIC_ATTRIBUTES_TABLE( IMPORTING TABLE = LT_NODE_DATA ).
   LO_ND_NODE_VALUES->GET_STATIC_ATTRIBUTES_TABLE( IMPORTING TABLE = LT_NODE_VALUES ).
*   CURRENT: die Supply Funktionen sollen nur noch die entsprechende Listbox Fuüllfunktion aufrufen.
*   Dadurch wird der Code und das Verhalten der Anwendung kontrollierbarer.
   me->FILL_LB_FOLGE( "das Ab-Jahr gemäß den Möglichkeiten  setzen
        EXPORTING
         NODE = LO_ND_NODE_DATA                         "Referenz zu dem Knoten mit den Daten.
* GESAMTE JAHRE      IV_JAHR             =  LV_JAHR                  " zvde_jahr
         IV_TARGET_NODE_NAME =  lv_node_values           "i.e.:   'NODE_UN_FROM_YEAR'        " csequence
         IV_DATA_FIELD       =  lv_data_field            " der Name des Zielfeldes
         IV_VALUE_FIELD      =  lv_value_field           " cer Name des Zielfeldes in der Listbox
         IT_NODE_DATA        =  LT_NODE_DATA             " daten des Knotens
       CHANGING
         CT_TARGET_VALUES    =  LT_NODE_VALUES           " -> Listboxwerte, anfänglich leer, werden befüllt
      ).
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method INIT_TRANSPORTCOST_TABLES .
"2018 - Ticket #1082635  Transportkosten - Vortransport Tabell
  DATA: ltab_result            type ZVTT_TRANS_VORTRANSPORT,
        lv_objekt              type ZVDE_OBJEKT,
        ltab_return            type zvtt_return.
  DATA lo_nd_object_repository TYPE REF TO if_wd_context_node.
  DATA lo_el_object_repository TYPE REF TO if_wd_context_element.
  DATA ls_object_repository    TYPE wd_this->Element_object_repository.
  DATA IV_OBJ                  TYPE ZVDE_OBJEKT.
  DATA LT_RETURN               TYPE ZVTT_RETURN.
  DATA lo_nd_node_vortransport TYPE REF TO if_wd_context_node.
  DATA lt_vortransport         TYPE wd_this->Elements_node_vortransport.
  DATA lo_nd_node_uebernahme   TYPE REF TO if_wd_context_node.
  DATA lt_uebernahme           TYPE wd_this->Elements_node_uebernahme.
  DATA lo_nd_node_maut         TYPE REF TO if_wd_context_node.
  DATA lt_maut                 TYPE wd_this->Elements_node_maut.
  DATA lo_nd_node_ecotax       TYPE REF TO if_wd_context_node.
  DATA lt_ecotax               TYPE wd_this->Elements_node_ecotax.
  DATA lv_locked               TYPE ZVDE_SPERRKENNZEICHEN.
  DATA lt_zviof                TYPE ZVTT_ZVIOF.
  DATA lt_node_vortrans_lb TYPE wd_this->ELEMENTS_NODE_VORTRANSPORT_LB.DATA lo_nd_node_vortransport_lb TYPE REF TO if_wd_context_node.
  DATA lo_el_node_vortransport_lb TYPE REF TO if_wd_context_element.
  DATA ls_node_vortransport_lb TYPE wd_this->Element_node_vortransport_lb.
  DATA:  lr_element TYPE REF TO if_wd_context_element,
        context_node type ref to if_wd_context_node,
        lv_selected_idx   TYPE I.
  DATA lo_nd_node_maut_values TYPE REF TO if_wd_context_node.
  DATA lt_node_maut_values TYPE wd_this->Elements_node_maut_values.  "Das ist der Knoten unter den Transportkosten
  DATA lt_node_uebernahme_lb TYPE wd_this->ELEMENTS_NODE_UEBERNAHME_LB.
  DATA lt_node_from_year_lb TYPE wd_this->ELEMENTS_NODE_FROM_YEAR_LB.
  DATA lo_nd_node TYPE REF TO if_wd_context_node.
  lo_nd_object_repository = wd_context->get_child_node( name = wd_this->wdctx_object_repository ).
  lo_el_object_repository = lo_nd_object_repository->get_element( ).
* get single attribute
  lo_el_object_repository->get_attribute(
    EXPORTING
      name =  `OBJECT_ID`
    IMPORTING
      value = lv_objekt ).
  CALL FUNCTION 'ZV_GET_TRANSCOST_MAPI'
    EXPORTING
      IV_OBJ                = lv_objekt
   IMPORTING
     ET_MAUT               = lt_maut
     ET_VORTRANSPORT       = lt_vortransport
     ET_UEBERNAHME         = lt_uebernahme
     ET_ECOTAX             = lt_ecotax
     ET_ZVIOF              = lt_zviof
     ET_RETURN             = lt_return
            .
  "Daten in die ContextKnoten einsetzen.
* navigate from <CONTEXT> to <NODE_VORTRANSPORT> via lead selection
  lo_nd_node_vortransport = wd_context->path_get_node( path = `NODE_TRANS_COST.NODE_VORTRANSPORT` ).
  lo_nd_node_vortransport->bind_table( new_items = lt_vortransport set_initial_elements = abap_true ).
* navigate from <CONTEXT> to <NODE_UEBERNAHME> via lead selection
  lo_nd_node_uebernahme = wd_context->path_get_node( path = `NODE_TRANS_COST.NODE_UEBERNAHME` ).
  lo_nd_node_uebernahme->bind_table( new_items = lt_uebernahme set_initial_elements = abap_true ).
* navigate from <CONTEXT> to <NODE_MAUT> via lead selection
  lo_nd_node_maut = wd_context->path_get_node( path = `NODE_TRANS_COST.NODE_MAUT` ).
  lo_nd_node_maut->bind_table( new_items = lt_maut set_initial_elements = abap_true ).
*   navigate from <CONTEXT> to <NODE_ECOTAX> via lead selection
  lo_nd_node_ecotax = wd_context->path_get_node( path = `NODE_TRANS_COST.NODE_ECOTAX` ).
  lo_nd_node_ecotax->bind_table( new_items = lt_ecotax set_initial_elements = abap_true ).
  "Die Wertetabelle f. die Maut Prozente füllen.
   FILL_LB_MAUT_PERC( ).
   FILL_LB_VORTRANSPORT( ).
   FILL_LB_UEBERNAHME( ).
*   navigate from <CONTEXT> to <NODE_MAUT_VALUES> via lead selection
    lo_nd_node_maut_values =  wd_context->path_get_node( path = `NODE_TRANS_COST.NODE_MAUT_PERC` ).
    lo_nd_node_maut_values->get_static_attributes_table( importing table = lt_node_maut_values ).
"Generisch - deshalb werden die key-felder als strings reingegeben.
"TRANSCOST_ASSOCIATE_LISTBOXES - fügt jeweils eine Listbox mit den gültigen Werten für die Felder ein, und setzt den LEAD Index.
     TRANSCOST_ASSOCIATE_LISTBOX(
  exporting
    IO_NODE_DATA     = lo_nd_node_maut
    IO_NODE_VALUES   = lo_nd_node_maut_values
    IV_NODE_NAME     = 'NODE_MAUT_VALUES'          "unter dem Knoten der eigentlichen Daten
    IV_DATA_FIELD    = `ZZPERCENT_MAUT`        "der Name des Feldes in der Tabelle der Daten
    IV_VALUE_FIELD   = `PERCENT`                "der Name im Knoten der Listbox/Werte
      IT_DATA =   lt_maut
      IT_VALUES = lt_node_maut_values
).
*   navigate from <CONTEXT> to <NODE_VORTRANSPORT_LB> via lead selection
  lo_nd_node_vortransport_lb = wd_context->path_get_node( path = `NODE_TRANS_COST.NODE_VORTRANSPORT_LB` ).
  lo_nd_node_vortransport_lb->get_static_attributes_table( importing table = LT_NODE_VORTRANS_LB ).
  TRANSCOST_ASSOCIATE_LISTBOX(
  exporting
    IO_NODE_DATA     = lo_nd_node_vortransport
    IO_NODE_VALUES   = lo_nd_node_vortransport_lb
    IV_NODE_NAME     = 'NODE_VORTRANS_VALUE'          "unter dem Knoten der eigentlichen Daten
    IV_DATA_FIELD    = `ZZBETRAG_VORTRANSPORT`        "der Name des Feldes in der Tabelle der Daten
    IV_VALUE_FIELD   = `BETRAG_STRING`                "der Name im Knoten der Listbox/Werte
      IT_DATA =   lt_vortransport
      IT_VALUES = lt_node_vortrans_lb
).
*
*
*"Übernahmekosten
*"code muss noch ausgelagert werden
  lo_nd_node = wd_context->path_get_node( path = `NODE_TRANS_COST.NODE_UEBERNAHME_LB` ).
  lo_nd_node->get_static_attributes_table( importing table = LT_NODE_UEBERNAHME_LB ).
  TRANSCOST_ASSOCIATE_LISTBOX(
  exporting
    IO_NODE_DATA   = lo_nd_node_uebernahme
    IO_NODE_VALUES = lo_nd_node
    IV_NODE_NAME   = 'NODE_UEBERNAHME_VAL'
    IV_DATA_FIELD    = `ZZBETRAG_UEBERNAHMESATZ`        "der Name des Feldes in der Tabelle der Daten
    IV_VALUE_FIELD   = `BETRAG_STRING`                  "der Name im Knoten der Listbox/Werte
      IT_DATA =   LT_UEBERNAHME
      IT_VALUES = LT_NODE_UEBERNAHME_LB
).
* Sperre setzen, wenn im Änderungsmodus
  IF me->GET_IS_READONLY( ) = 'X'.
    . "readOnly - bleibt wie es ist.
  ELSE. "LOCK
  READ TABLE lt_maut INDEX 1 INTO DATA(ls_maut).
  READ TABLE lt_uebernahme INDEX 1 INTO DATA(ls_uebernahme).
  READ TABLE lt_vortransport INDEX 1 INTO DATA(ls_vortransport).
  READ TABLE lt_ecotax INDEX 1 INTO DATA(ls_ecotax).
"der Funktion wird jeweils der erste Datensatz übergeben(kann leer sein), um Argumente daraus zu ziehen.
    CALL FUNCTION 'ZV_ENQUEUE_ZVTRANSCOST'
      EXPORTING
       IS_MAUT               = ls_maut
       IS_UEBERNAHME         = ls_uebernahme
       IS_VORTRANSPORT       = ls_vortransport
       IS_ECOTAX             = ls_ecotax
     IMPORTING
       E_LOCKED              = LV_LOCKED
              .
  ENDIF.
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method TRANSCOST_ASSOCIATE_LISTBOX.
*KEMPF_S 1/2018
*Daten eines Knoten werden einem Index einer Listbox zugeordnet.
*Hierfür wird das Feld IV_KEY_FELD verwendet.
*Daten sind jeweils generisch(ohne Typangabe).
  "iv_set_initial_elements -> wenn TRUE kann ein Dump auftreten:
  "Schon während der Supply-Methode wird
  "auf dem selben Knoten COMPONENTCONTROLLER.1.NODE_TRANS_COST.1.NODE_VORTRANSPORT.1.NODE_VT_TO_FOLGE
  "die Invalidate-Methode aufgerufen.
  DATA:  lr_element      TYPE REF TO if_wd_context_element,
         context_node    TYPE REF TO if_wd_context_node,
         lv_selected_idx TYPE I.
  FIELD-SYMBOLS: <lfs_tdata>   TYPE ANY TABLE,
                 <lfs_tvalues> TYPE ANY TABLE.
  ASSIGN it_data   TO <lfs_tdata>.
  ASSIGN it_values TO <lfs_tvalues>.
"die Zuordnung zu den Screen-Elementen erfolgt über sy-tabix!
  LOOP AT <lfs_tdata> ASSIGNING FIELD-SYMBOL(<lfs_data>).
    context_node = io_node_data.
    lr_element = context_node->get_element( sy-tabix ).
    DATA(lr_child_node) = lr_element->get_child_node( IV_NODE_NAME ). "io_node_values->GET_NODE_INFO( )->GET_NAME( )
    DATA(x) = IO_NODE_DATA->GET_NODE_INFO( )->GET_NAME( ).
    x = lr_child_node->GET_NODE_INFO( )->GET_NAME( ).
    "an diesen Knoten werden die Listboxwerte angeklemmt.
    lr_child_node->BIND_TABLE(
      EXPORTING
        NEW_ITEMS            = <lfs_tvalues> " Liste von Elementen oder Modeldaten
        SET_INITIAL_ELEMENTS = iv_set_initial_elements " Falls TRUE setzen der initialen Elemente, sonst Anfügen
*        INDEX                = INDEX     " Index eines Kontext Elementes
    ).
    "der Index muss entsprechend dem Wert gesetzt werden.
    "den Index über den Key in der Wertetabelle suchen.
    ASSIGN COMPONENT IV_DATA_FIELD OF STRUCTURE <lfs_data> TO FIELD-SYMBOL(<lfs_key>).
    IF sy-subrc = 0 AND <lfs_key> IS ASSIGNED AND SY-SUBRC = 0 .
      READ TABLE <lfs_tvalues> WITH KEY (IV_VALUE_FIELD) = <lfs_key> TRANSPORTING NO FIELDS.
      IF SY-SUBRC = 0 .
        lr_child_node->SET_LEAD_SELECTION_INDEX( INDEX = sy-TABIX ).
      ELSE. "auf -1.
        lr_child_node->SET_LEAD_SELECTION_INDEX( INDEX = -1 ).
      ENDIF.
    ENDIF.
  ENDLOOP.
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method SPLY_FROM_FOLGE_UN.
"Die ersten Deklarationen hier sind das Customizing für die Methode mit den Literalen für die Knoten und Felder...
 DATA:  lv_node_path   TYPE STRING VALUE `NODE_TRANS_COST.NODE_UEBERNAHME`,
        lv_node_values TYPE STRING VALUE `NODE_UN_FROM_FOLGE`,
        lv_data_field  TYPE STRING VALUE `ZZABFOLGE`,
        lv_value_field TYPE STRING VALUE `ZZABFOLGE`.
 DATA:  LO_ND_NODE_VALUES     TYPE REF TO IF_WD_CONTEXT_NODE,
        LT_NODE_VALUES        TYPE WD_THIS->ELEMENTS_NODE_UN_FROM_FOLGE,
        LO_ND_NODE_DATA       TYPE REF TO IF_WD_CONTEXT_NODE,
        LT_NODE_DATA          TYPE WD_THIS->ELEMENTS_NODE_UEBERNAHME,
* 1/2019 KEMPF_S - die Listbox mit den verfügbaren Jahren wird bedarfsweise(eventgesteuert) ausgeführt(abh. v. anderen Listboxen).
        lv_objekt  TYPE ZVIOFOBJEK. "f. Komplementberechnung
  DATA(lo_nd_object_repository) = wd_context->get_child_node( name = wd_this->wdctx_object_repository ).
  DATA(lo_el_object_repository) = lo_nd_object_repository->get_element( ).
  DATA(x) = NODE->GET_NODE_INFO( )->GET_NAME( ). "nur dev
* get single attribute
  lo_el_object_repository->get_attribute(
    EXPORTING
      name =  `OBJECT_ID`
    IMPORTING
      value = lv_objekt ).
*   navigate from <CONTEXT> to <NODE_TO_YEAR> via lead selection
   LO_ND_NODE_VALUES = WD_CONTEXT->PATH_GET_NODE( PATH = lv_node_path && `.` && lv_node_values ).
   IF lo_nd_node_values IS INITIAL.
      RETURN.
   ENDIF.
   LO_ND_NODE_DATA = WD_CONTEXT->PATH_GET_NODE( PATH = lv_node_path ).
   IF LO_ND_NODE_DATA IS INITIAL.
      RETURN.
   ENDIF.
   LO_ND_NODE_DATA->GET_STATIC_ATTRIBUTES_TABLE( IMPORTING TABLE = LT_NODE_DATA ).
   LO_ND_NODE_VALUES->GET_STATIC_ATTRIBUTES_TABLE( IMPORTING TABLE = LT_NODE_VALUES ).
*   CURRENT: die Supply Funktionen sollen nur noch die entsprechende Listbox Fuüllfunktion aufrufen.
*   Dadurch wird der Code und das Verhalten der Anwendung kontrollierbarer.
   me->FILL_LB_FOLGE( "das Ab-Jahr gemäß den Möglichkeiten  setzen
        EXPORTING
         NODE = LO_ND_NODE_DATA                         "Referenz zu dem Knoten mit den Daten.
* GESAMTE JAHRE      IV_JAHR             =  LV_JAHR                  " zvde_jahr
         IV_TARGET_NODE_NAME =  lv_node_values           "i.e.:   'NODE_UN_FROM_YEAR'        " csequence
         IV_DATA_FIELD       =  lv_data_field            " der Name des Zielfeldes
         IV_VALUE_FIELD      =  lv_value_field           " cer Name des Zielfeldes in der Listbox
         IT_NODE_DATA        =  LT_NODE_DATA             " daten des Knotens
       CHANGING
         CT_TARGET_VALUES    =  LT_NODE_VALUES           " -> Listboxwerte, anfänglich leer, werden befüllt
      ).
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method SPLY_FROM_FOLGE_VT.
"Die ersten Deklarationen hier sind das Customizing für die Methode mit den Literalen für die Knoten und Felder...
 DATA:  lv_node_path   TYPE STRING VALUE `NODE_TRANS_COST.NODE_VORTRANSPORT`,
        lv_node_values TYPE STRING VALUE `NODE_VT_FROM_FOLGE`,
        lv_data_field  TYPE STRING VALUE `ZZABFOLGE`,
        lv_value_field TYPE STRING VALUE `ZZABFOLGE`.
 DATA:  LO_ND_NODE_VALUES     TYPE REF TO IF_WD_CONTEXT_NODE,
        LT_NODE_VALUES        TYPE WD_THIS->ELEMENTS_NODE_VT_FROM_FOLGE,
        LO_ND_NODE_DATA       TYPE REF TO IF_WD_CONTEXT_NODE,
        LT_NODE_DATA          TYPE WD_THIS->ELEMENTS_NODE_VORTRANSPORT,
* 1/2019 KEMPF_S - die Listbox mit den verfügbaren Jahren wird bedarfsweise(eventgesteuert) ausgeführt(abh. v. anderen Listboxen).
        lv_objekt  TYPE ZVIOFOBJEK. "f. Komplementberechnung
  DATA(lo_nd_object_repository) = wd_context->get_child_node( name = wd_this->wdctx_object_repository ).
  DATA(lo_el_object_repository) = lo_nd_object_repository->get_element( ).
  DATA(x) = NODE->GET_NODE_INFO( )->GET_NAME( ). "nur dev
* get single attribute
  lo_el_object_repository->get_attribute(
    EXPORTING
      name =  `OBJECT_ID`
    IMPORTING
      value = lv_objekt ).
*   navigate from <CONTEXT> to <NODE_TO_YEAR> via lead selection
   LO_ND_NODE_VALUES = WD_CONTEXT->PATH_GET_NODE( PATH = lv_node_path && `.` && lv_node_values ).
   IF lo_nd_node_values IS INITIAL.
      RETURN.
   ENDIF.
   LO_ND_NODE_DATA = WD_CONTEXT->PATH_GET_NODE( PATH = lv_node_path ).
   IF LO_ND_NODE_DATA IS INITIAL.
      RETURN.
   ENDIF.
   LO_ND_NODE_DATA->GET_STATIC_ATTRIBUTES_TABLE( IMPORTING TABLE = LT_NODE_DATA ).
   LO_ND_NODE_VALUES->GET_STATIC_ATTRIBUTES_TABLE( IMPORTING TABLE = LT_NODE_VALUES ).
*   CURRENT: die Supply Funktionen sollen nur noch die entsprechende Listbox Fuüllfunktion aufrufen.
*   Dadurch wird der Code und das Verhalten der Anwendung kontrollierbarer.
   me->FILL_LB_FOLGE( "das Ab-Jahr gemäß den Möglichkeiten  setzen
        EXPORTING
         NODE = LO_ND_NODE_DATA                         "Referenz zu dem Knoten mit den Daten.
* GESAMTE JAHRE      IV_JAHR             =  LV_JAHR                  " zvde_jahr
         IV_TARGET_NODE_NAME =  lv_node_values           "i.e.:   'NODE_UN_FROM_YEAR'        " csequence
         IV_DATA_FIELD       =  lv_data_field            " der Name des Zielfeldes
         IV_VALUE_FIELD      =  lv_value_field           " cer Name des Zielfeldes in der Listbox
         IT_NODE_DATA        =  LT_NODE_DATA             " daten des Knotens
       CHANGING
         CT_TARGET_VALUES    =  LT_NODE_VALUES           " -> Listboxwerte, anfänglich leer, werden befüllt
      ).
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method SPLY_FROM_FOLGE_MAUT.
  "Die ersten Deklarationen hier sind das Customizing für die Methode mit den Literalen für die Knoten und Felder...
 DATA:  lv_node_path   TYPE STRING VALUE `NODE_TRANS_COST.NODE_MAUT`,
        lv_node_values TYPE STRING VALUE `NODE_MAUT_FROM_FOLGE`,
        lv_data_field  TYPE STRING VALUE `ZZABFOLGE`,
        lv_value_field TYPE STRING VALUE `ZZABFOLGE`.
 DATA:  LO_ND_NODE_VALUES     TYPE REF TO IF_WD_CONTEXT_NODE,
        LT_NODE_VALUES        TYPE WD_THIS->ELEMENTS_NODE_MAUT_FROM_FOLGE,
        LO_ND_NODE_DATA       TYPE REF TO IF_WD_CONTEXT_NODE,
        LT_NODE_DATA          TYPE WD_THIS->ELEMENTS_NODE_MAUT,
* 1/2019 KEMPF_S - die Listbox mit den verfügbaren Jahren wird bedarfsweise(eventgesteuert) ausgeführt(abh. v. anderen Listboxen).
        lv_objekt  TYPE ZVIOFOBJEK. "f. Komplementberechnung
  DATA(lo_nd_object_repository) = wd_context->get_child_node( name = wd_this->wdctx_object_repository ).
  DATA(lo_el_object_repository) = lo_nd_object_repository->get_element( ).
  DATA(x) = NODE->GET_NODE_INFO( )->GET_NAME( ). "nur dev
* get single attribute
  lo_el_object_repository->get_attribute(
    EXPORTING
      name =  `OBJECT_ID`
    IMPORTING
      value = lv_objekt ).
*   navigate from <CONTEXT> to <NODE_TO_YEAR> via lead selection
   LO_ND_NODE_VALUES = WD_CONTEXT->PATH_GET_NODE( PATH = lv_node_path && `.` && lv_node_values ).
   IF lo_nd_node_values IS INITIAL.
      RETURN.
   ENDIF.
   LO_ND_NODE_DATA = WD_CONTEXT->PATH_GET_NODE( PATH = lv_node_path ).
   IF LO_ND_NODE_DATA IS INITIAL.
      RETURN.
   ENDIF.
   LO_ND_NODE_DATA->GET_STATIC_ATTRIBUTES_TABLE( IMPORTING TABLE = LT_NODE_DATA ).
   LO_ND_NODE_VALUES->GET_STATIC_ATTRIBUTES_TABLE( IMPORTING TABLE = LT_NODE_VALUES ).
*   CURRENT: die Supply Funktionen sollen nur noch die entsprechende Listbox Fuüllfunktion aufrufen.
*   Dadurch wird der Code und das Verhalten der Anwendung kontrollierbarer.
   me->FILL_LB_FOLGE( "das Ab-Jahr gemäß den Möglichkeiten  setzen
        EXPORTING
         NODE = LO_ND_NODE_DATA                         "Referenz zu dem Knoten mit den Daten.
* GESAMTE JAHRE      IV_JAHR             =  LV_JAHR                  " zvde_jahr
         IV_TARGET_NODE_NAME =  lv_node_values           "i.e.:   'NODE_UN_FROM_YEAR'        " csequence
         IV_DATA_FIELD       =  lv_data_field            " der Name des Zielfeldes
         IV_VALUE_FIELD      =  lv_value_field           " cer Name des Zielfeldes in der Listbox
         IT_NODE_DATA        =  LT_NODE_DATA             " daten des Knotens
       CHANGING
         CT_TARGET_VALUES    =  LT_NODE_VALUES           " -> Listboxwerte, anfänglich leer, werden befüllt
      ).
endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
method SPLY_FROM_FOLGE_ETAX.
"Die ersten Deklarationen hier sind das Customizing für die Methode mit den Literalen für die Knoten und Felder...
 DATA:  lv_node_path   TYPE STRING VALUE `NODE_TRANS_COST.NODE_ECOTAX`,
        lv_node_values TYPE STRING VALUE `NODE_ETAX_FROM_FOLGE`,
        lv_data_field  TYPE STRING VALUE `ZZABFOLGE`,
        lv_value_field TYPE STRING VALUE `ZZABFOLGE`.
 DATA:  LO_ND_NODE_VALUES     TYPE REF TO IF_WD_CONTEXT_NODE,
        LT_NODE_VALUES        TYPE WD_THIS->ELEMENTS_NODE_ETAX_FROM_FOLGE,
        LO_ND_NODE_DATA       TYPE REF TO IF_WD_CONTEXT_NODE,
        LT_NODE_DATA          TYPE WD_THIS->ELEMENTS_NODE_ECOTAX,
* 1/2019 KEMPF_S - die Listbox mit den verfügbaren Jahren wird bedarfsweise(eventgesteuert) ausgeführt(abh. v. anderen Listboxen).
        lv_objekt  TYPE ZVIOFOBJEK. "f. Komplementberechnung
  DATA(lo_nd_object_repository) = wd_context->get_child_node( name = wd_this->wdctx_object_repository ).
  DATA(lo_el_object_repository) = lo_nd_object_repository->get_element( ).
  DATA(x) = NODE->GET_NODE_INFO( )->GET_NAME( ). "nur dev
* get single attribute
  lo_el_object_repository->get_attribute(
    EXPORTING
      name =  `OBJECT_ID`
    IMPORTING
      value = lv_objekt ).
*   navigate from <CONTEXT> to <NODE_TO_YEAR> via lead selection
   LO_ND_NODE_VALUES = WD_CONTEXT->PATH_GET_NODE( PATH = lv_node_path && `.` && lv_node_values ).
   IF lo_nd_node_values IS INITIAL.
      RETURN.
   ENDIF.
   LO_ND_NODE_DATA = WD_CONTEXT->PATH_GET_NODE( PATH = lv_node_path ).
   IF LO_ND_NODE_DATA IS INITIAL.
      RETURN.
   ENDIF.
   LO_ND_NODE_DATA->GET_STATIC_ATTRIBUTES_TABLE( IMPORTING TABLE = LT_NODE_DATA ).
   LO_ND_NODE_VALUES->GET_STATIC_ATTRIBUTES_TABLE( IMPORTING TABLE = LT_NODE_VALUES ).
*   CURRENT: die Supply Funktionen sollen nur noch die entsprechende Listbox Fuüllfunktion aufrufen.
*   Dadurch wird der Code und das Verhalten der Anwendung kontrollierbarer.
   me->FILL_LB_FOLGE( "das Ab-Jahr gemäß den Möglichkeiten  setzen
        EXPORTING
         NODE = LO_ND_NODE_DATA                         "Referenz zu dem Knoten mit den Daten.
* GESAMTE JAHRE      IV_JAHR             =  LV_JAHR                  " zvde_jahr
         IV_TARGET_NODE_NAME =  lv_node_values           "i.e.:   'NODE_UN_FROM_YEAR'        " csequence
         IV_DATA_FIELD       =  lv_data_field            " der Name des Zielfeldes
         IV_VALUE_FIELD      =  lv_value_field           " cer Name des Zielfeldes in der Listbox
         IT_NODE_DATA        =  LT_NODE_DATA             " daten des Knotens
       CHANGING
         CT_TARGET_VALUES    =  LT_NODE_VALUES           " -> Listboxwerte, anfänglich leer, werden befüllt
      ).endmethod.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
METHOD FILL_LB_FOLGE.
 "1/2019 KEMPF_S -> literale hier, damit der Code besser kopiert und geändert werden kann.
*  DATA: lv_node_data_name     TYPE STRING VALUE `NODE_TRANS_COST.NODE_UEBERNAHME`.
*  DATA: lv_node_values_name   TYPE STRING .
  "DATA: lv_node_sub_name      TYPE STRING VALUE 'NODE_UN_FROM_FOLGE'.
  DATA LO_ND_NODE_VALUES      TYPE REF TO IF_WD_CONTEXT_NODE.
*  DATA LT_NODE_VALUES         TYPE WD_THIS->ELEMENTS_NODE_UN_FROM_FOLGE.
* 1/2019 KEMPF_S - die Listbox mit den verfügbaren Jahren wird bedarfsweise(eventgesteuert) ausgeführt(abh. v. anderen Listboxen).
  DATA:  lo_nd_node_data TYPE REF TO if_wd_context_node,
         lv_objekt   TYPE ZVIOFOBJEK, "f. Komplementberechnung
*  DATA LO_ND_NODE_DATA TYPE REF TO IF_WD_CONTEXT_NODE.
          LO_EL_NODE_DATA TYPE REF TO IF_WD_CONTEXT_ELEMENT,
         " LS_NODE_DATA    TYPE WD_THIS->ELEMENT_NODE_UEBERNAHME,
         " LT_NODE_DATA    TYPE WD_THIS->ELEMENTS_NODE_UEBERNAHME,
          LV_VERMARKTUNG  TYPE ZVDE_VERMARKTUNG,
          LT_HEFTFOLGE    TYPE ZVTT_HEFTFOLGE.
  DATA: lv_jahr TYPE ZVDE_JAHR.
  DATA(x) = NODE->GET_NODE_INFO( )->GET_NAME( ).
  DATA(lo_nd_object_repository) = wd_context->get_child_node( name = wd_this->wdctx_object_repository ).
  DATA(lo_el_object_repository) = lo_nd_object_repository->get_element( ).
  FIELD-SYMBOLS: <lfs_data> TYPE ANY,
                 <lfs_v> TYPE ANY.
  "zusammengesetzt
*  lv_node_data_name = NODE->GET_NODE_INFO( )->GET_NAME( ).
  "lv_node_sub_name = LO_ND_NODE_VALUES->GET_NODE_INFO( )->GET_NAME( ).
* get single attribute
  lo_el_object_repository->get_attribute(
    EXPORTING
      name =  `OBJECT_ID`
    IMPORTING
      value = lv_objekt ).
*   navigate from <CONTEXT> to <NODE_TO_YEAR> via lead selection
*    LO_ND_NODE_VALUES = WD_CONTEXT->PATH_GET_NODE( PATH = lv_node_values_name ).
    "LO_ND_NODE_VALUES->GET_STATIC_ATTRIBUTES_TABLE( IMPORTING TABLE = CT_TARGET_VALUES ).
    lv_vermarktung = wd_this->GET_VERMARKTUNG( IV_OBJEKT = lv_objekt ).
    lv_jahr = iv_jahr. "brauche typgerechte variable
    LT_HEFTFOLGE = ZCL_HEFTFOLGE=>GET_HEFTFOLGEN_VON_BIS(
        IV_OBJEKT       = LV_OBJEKT
        IV_VERMARKTUNG  = lv_vermarktung
         IV_JAHR_VON     = lv_jahr
         IV_FOLGE_VON    = IV_START_FOLGE
    ).
    IF IV_JAHR IS SUPPLIED AND IV_JAHR IS NOT INITIAL .
      DELETE LT_HEFTFOLGE WHERE JAHR <> lv_jahr. "das geht auch, wenn das Jahr initial ist.
    ENDIF. "ELSE: alle
    Sort LT_HEFTFOLGE BY FOLGE ASCENDING.
    DELETE ADJACENT DUPLICATES FROM LT_HEFTFOLGE COMPARING FOLGE.
    LOOP AT LT_HEFTFOLGE ASSIGNING FIELD-SYMBOL(<lfs_folge>).
          APPEND INITIAL LINE TO CT_TARGET_VALUES  ASSIGNING <lfs_data>. "die Auswahlwerte
          ASSIGN COMPONENT IV_DATA_FIELD OF STRUCTURE <lfs_data> TO FIELD-SYMBOL(<lfs_value>).
          <lfs_value> = <lfs_folge>-FOLGE.
    ENDLOOP.
  IF IV_INDEX IS SUPPLIED AND IV_INDEX > 0 AND LINES( IT_NODE_DATA ) >= IV_INDEX. "nur diesen updaten
    "z.B. NODE_TRANS_COST.NODE_VORTRANSPORT.NODE_VT_TO_FOLGE
  "Der Knoten mit den Listboxen
  LO_ND_NODE_VALUES = NODE->GET_CHILD_NODE(
                          INDEX = IV_INDEX
                          NAME  = IV_TARGET_NODE_NAME
                        ) .
    IF LO_ND_NODE_VALUES IS INITIAL.
      RETURN.
    ENDIF.
*    lv_node_values_name =   LO_ND_NODE_VALUES->GET_PATH( ). "            && `.` && IV_TARGET_NODE_NAME.
    TRANSCOST_UPDATE_LISTBOX(
      EXPORTING
        IO_NODE_DATA            = NODE
        IO_NODE_VALUES          = LO_ND_NODE_VALUES
        IV_NODE_NAME            = IV_TARGET_NODE_NAME
        IT_VALUES               = CT_TARGET_VALUES
        IS_DATA                 = IT_NODE_DATA[ IV_INDEX ]
        IV_DATA_FIELD           = IV_DATA_FIELD
        IV_VALUE_FIELD          = IV_VALUE_FIELD "in der Strucktur der Listbox
        IV_SET_INITIAL_ELEMENTS = ABAP_TRUE
        IV_INDEX                = IV_INDEX
    ).
  ELSE."alle aktualisieren.
   LO_ND_NODE_VALUES = NODE->GET_CHILD_NODE(
                         "
                         NAME  = IV_TARGET_NODE_NAME
                       ) .
   IF LO_ND_NODE_VALUES IS INITIAL.
     RETURN.
   ENDIF.
   TRANSCOST_ASSOCIATE_LISTBOX(
      EXPORTING
        IO_NODE_DATA            = NODE
        IO_NODE_VALUES          = LO_ND_NODE_VALUES
        IV_NODE_NAME            = IV_TARGET_NODE_NAME
        IT_VALUES               = CT_TARGET_VALUES
        IT_DATA                 = IT_NODE_DATA
        IV_DATA_FIELD           = IV_DATA_FIELD
        IV_VALUE_FIELD          = IV_VALUE_FIELD "in der Strucktur der Listbox
        IV_SET_INITIAL_ELEMENTS = ABAP_TRUE
    ).
  ENDIF.
ENDMETHOD.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
